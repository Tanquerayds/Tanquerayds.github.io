{"meta":{"title":"Tanqueray","subtitle":"","description":"oyoy","author":"John Doe","url":"http://tanquerayds.site","root":"/"},"pages":[{"title":"","date":"2022-08-18T10:03:58.584Z","updated":"2022-08-18T10:03:58.584Z","comments":false,"path":"about/index.html","permalink":"http://tanquerayds.site/about/index.html","excerpt":"","text":""},{"title":"","date":"2022-08-18T10:03:38.090Z","updated":"2022-08-18T10:03:38.090Z","comments":false,"path":"categories/index.html","permalink":"http://tanquerayds.site/categories/index.html","excerpt":"","text":"layout: categoryindex: truetitle: 所有分类"},{"title":"","date":"2022-09-04T04:40:32.414Z","updated":"2022-09-04T04:40:32.413Z","comments":false,"path":"css/fold_code.css","permalink":"http://tanquerayds.site/css/fold_code.css","excerpt":"","text":".markdown-body .highlight table, .markdown-body .code-wrapper pre { border-radius: 0 0 0.5rem 0.5rem; } .markdown-body .highlight, .markdown-body .code-wrapper { background-color: #e6ebf1; border-radius: 0.625rem; } .markdown-body .highlight > i, .markdown-body .code-wrapper > i { color: #777; margin-left: 10px; line-height: 2rem; transform: none; transition: color 0.2s ease-in-out, transform 0.2s ease-in-out; } .markdown-body .highlight > i.collapsed, .markdown-body .code-wrapper > i.collapsed { transform: rotate(-90deg); } .markdown-body .highlight > span, .markdown-body .code-wrapper > span { color: #777; margin-left: 10px; font-weight: bold; } [data-user-color-scheme='dark'] .markdown-body .highlight, [data-user-color-scheme='dark'] .markdown-body .code-wrapper { background-color: #696969; transition: background-color 0.2s ease-in-out; } [data-user-color-scheme='dark'] .markdown-body .highlight > i, [data-user-color-scheme='dark'] .markdown-body .code-wrapper > i { color: #c4c6c9; } [data-user-color-scheme='dark'] .markdown-body .highlight > span, [data-user-color-scheme='dark'] .markdown-body .code-wrapper > span { color: #c4c6c9; transition: color 0.2s ease-in-out; }"},{"title":"","date":"2022-08-18T10:03:19.548Z","updated":"2022-08-18T10:03:19.548Z","comments":false,"path":"tags/index.html","permalink":"http://tanquerayds.site/tags/index.html","excerpt":"","text":"layout: tagindex: truetitle: 所有标签"}],"posts":[{"title":"老杜笔记","slug":"Servlet-JSP-课堂笔记","date":"2022-09-29T02:16:43.000Z","updated":"2022-11-03T04:31:40.743Z","comments":true,"path":"2022/09/29/Servlet-JSP-课堂笔记/","link":"","permalink":"http://tanquerayds.site/2022/09/29/Servlet-JSP-%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/","excerpt":"","text":"关于直播 什么时间直播？ 晚上8:00到10:00 每周直播几天？ 3天（周一、周三、周五） 本周比较特殊：周四周五周六三天直播，从下周开始就是一三五直播。 直播什么内容？ 从JavaWEB开始。（Servlet为核心，从Servlet开始学习。） JSP（JSP使用较少了，但是还有用，所以时间上少一些。快速地学习一下JSP。） AJAX（异步通信技术。） jQuery（JavaScript库。） MyBatis Spring SpringMVC SpringBoot SpringCloud …. 需要提前准备了哪些技术，接下来的课才能听懂？ JavaSE（Java语言的标准版，Java提供的最基本的类库） Java的开发环境搭建 Java的基础语法 Java的面向对象 数组 常用类 异常 集合 多线程 IO流 反射机制 注解Annotation ….. MySQL（数据库） 最基本的要求是：能够编写增删改查等简单的SQL语句即可。 JDBC（Java语言链接数据库） 这是一套Java语言链接数据库的接口。 WEB前端（会一些） HTML（网页） CSS（层叠样式表语言，修饰HTML） JavaScript（一种脚本语言，运行在浏览器当中，让浏览器中的元素可以增删改。让网页产生更强的交互效果） WEB后端 Servlet（Server Applet：服务器端的Java小程序） JSP AJAX jQuery MyBatis Spring SpringMVC SpringBoot SpringCloud …… Typora软件介绍 Markdown文本编辑器（可以编辑xxx.md文件） java12345public class Test&#123; public static void main(String[] args)&#123; System.out.println(&quot;Test code!&quot;); &#125;&#125; Servlet关于系统架构 系统架构包括什么形式？ C&#x2F;S架构 B&#x2F;S架构 C&#x2F;S架构？ Client &#x2F; Server（客户端 &#x2F; 服务器） C&#x2F;S架构的软件或者说系统有哪些呢？ QQ（先去腾讯官网下载一个QQ软件，几十MB，然后把这个客户端软件安装上去，然后输入QQ号以及密码，登录之后，就可以和你的朋友聊天了，就可以使用这个软件了。） C&#x2F;S架构的特点：需要安装特定的客户端软件。 C&#x2F;S架构的系统优点和缺点分别是什么？ 优点： 速度快（软件中的数据大部分都是集成到客户端软件当中的，很少量的数据从服务器端传送过来，所以C&#x2F;S结构的系统速度快） 体验好（速度又快，界面又酷炫，当然体验好了。） 界面酷炫（专门的语言去实现界面的，更加灵活。） 服务器压力小（因为大量的数据都是集成在客户端软件当中，所以服务器只需要传送很少的数据量，当然服务器压力小。） 安全（因为大量的数据是集成在客户端软件当中的，并且客户端有很多个，服务器虽然只有一个，就算服务器那边地震了，火灾了，服务器受损了，问题也不大，因为大量的数据在多个客户端上有缓存，有存储，所以从这个方面来说，C&#x2F;S结构的系统比较安全。） ….. 缺点： 升级维护比较差劲。（升级维护比较麻烦。成本比较高。每一个客户端软件都需要升级。有一些软件不是那么容易安装的。） B&#x2F;S架构？ B&#x2F;S（Browser &#x2F; Server，浏览器 &#x2F; 服务器） http://www.baidu.com http://www.jd.com http://www.126.com B&#x2F;S结构的系统是不是一个特殊的C&#x2F;S系统？ 实际上B&#x2F;S结构的系统还是一个C&#x2F;S，只不过这个C比较特殊，这个Client是一个固定不变浏览器软件。 B&#x2F;S结构的系统优点和缺点是： 优点： 升级维护方便，成本比较低。（只需要升级服务器端即可。） 不需要安装特定的客户端软件，用户操作极其方便。只需要打开浏览器，输入网址即可。 缺点： 速度慢（不是因为带宽低的问题，是因为所有的数据都是在服务器上，用户发送的每一个请求都是需要服务器全身心的响应数据，所以B&#x2F;S结构的系统在网络中传送的数据量比较大。） 体验差（界面不是那么酷炫，因为浏览器只支持三个语言HTML CSS JavaScript。在加上速度慢。） 不安全（所有的数据都在服务器上，只要服务器发生火灾，地震等不可抗力，最终数据全部丢失。） …. C&#x2F;S和B&#x2F;S结构的系统，哪个好，哪个不好？ 这个问题问的没有水平。并不是哪个好，哪个不好。不同结构的系统在不同的业务场景下有不同的适用场景。 娱乐性软件建议使用？ C&#x2F;S 结构 公司内部使用的一些业务软件建议使用？ 公司内部使用的系统，需要维护成本低。 公司内部使用的系统，不需要很酷炫。 公司内部使用的企业级系统主要是能够进行数据的维护即可。 B&#x2F;S 结构。 注意了：开发B&#x2F;S结构的系统，其实就是开发网站，其实就是开发一个WEB系统。 开发一个WEB系统你需要会哪些技术？ WEB前端（运行在浏览器上的程序。） HTML CSS JavaScript WEB后端（WEB服务器端的程序。） Java可以（Java做WEB开发我们称为JavaWEB开发。JavaWEB开发最核心的规范：Servlet【Server Applet服务器端的Java小程序。】） C语言也可以 C++也可以 Python也行 PHP也可以 …. JavaEE是什么？ Java包括三大块： JavaSE Java标准版（一套类库：别人写好的一套类库，只不过这个类库是标准类库，走EE，或者走ME，这个SE一定是基础，先学。） JavaEE（WEB方向，WEB系统。） Java企业版（也是一套类库：也是别人写好的一套类库，只不过这套类库可以帮助我们完成企业级项目的开发，专门为企业内部提供解决方案的一套（多套）类库。） 别人写好的，你用就行了，用它可以开发企业级项目。 可以开发web系统。 Java比较火爆的就是这个JavaEE方向。 JavaME Java微型版（还是一套类库，只不过这套类库帮助我们进行电子微型设备内核程序的开发） 机顶盒内核程序，吸尘器内核程序，电冰箱内核程序，电饭煲内核程序。。。。。 JavaEE实际上包括很多种规范，13种规范，其中Servlet就是JavaEE规范之一。学Servlet还是Java语言。 B&#x2F;S结构的系统通信原理（没有涉及到Java小程序） WEB系统的访问过程 第一步：打开浏览器 第二步：找到地址栏 第三步：输入一个合法的网址 第四步：回车 第五步：在浏览器上会展示响应的结果。 关于域名： https://www.baidu.com/ （网址） www.baidu.com 是一个域名 在浏览器地址栏上输入域名，回车之后，域名解析器会将域名解析出来一个具体的IP地址和端口号等。 解析结果也许是：http://110.242.68.3:80/index.html IP地址是啥？ 计算机在网络当中的一个身份证号。在同一个网络当中，IP地址是唯一的。 A计算机要想和B计算机通信，首先你需要知道B计算机的IP地址，有了IP地址才能建立连接。 端口号是啥？ 一个端口代表一个软件（一个端口代表一个应用，一个端口仅代表一个服务）。 一个计算机当中有很多软件，每一个软件启动之后都有一个端口号。 在同一个计算机上，端口号具有唯一性。 一个WEB系统的通信原理？通信步骤： 第一步：用户输入网址（URL） 第二步：域名解析器进行域名解析：http://110.242.68.3:80/index.html 第三步：浏览器软件在网络中搜索110.242.68.3这一台主机，直到找到这台主机。 第四步：定位110.242.68.3这台主机上的服务器软件，因为是80端口，可以很轻松的定位到80端口对应的服务器软件。 第五步：80端口对应的服务器软件得知浏览器想要的资源名是：index.html 第六步：服务器软件找到index.html文件，并且将index.html文件中的内容直接输出响应到浏览器上。 第七步：浏览器接收到来自服务器的代码（HTML CSS JS） 第八步：浏览器渲染，执行HTML CSS JS代码，展示效果。 什么是URL？ 统一资源定位符（http://www.baidu.com） 什么是请求，什么是响应？ 请求和响应实际上说的是数据的流向不同。 从Browser端发送数据到Server端，我们称为请求。英语单词：request 从Server端向浏览器Browser端发送数据，我们称为响应。英语单词：response B –&gt; S （请求request） S –&gt; B （响应response） 关于WEB服务器软件 WEB服务器软件都有哪些呢？（这些软件都是提前开发好的。） Tomcat（WEB服务器） jetty（WEB服务器） JBOSS（应用服务器） WebLogic（应用服务器） WebSphere（应用服务器） 应用服务器和WEB服务器的关系？ 应用服务器实现了JavaEE的所有规范。(JavaEE有13个不同的规范。) WEB服务器只实现了JavaEE中的Servlet + JSP两个核心的规范。 通过这个讲解说明了：应用服务器是包含WEB服务器的。 用过JBOSS服务器的同学应该很清楚，JBOSS中内嵌了一个Tomcat服务器。 Tomcat下载 apache官网地址：https://www.apache.org/ tomcat官网地址：https://tomcat.apache.org tomcat开源免费的轻量级WEB服务器。 tomcat还有另外一个名字：catalina（catalina是美国的一个岛屿，风景秀丽，据说作者是在这个风景秀丽的小岛上开发了一个轻量级的WEB服务器，体积小，运行速度快，因此tomcat又被称为catalina） tomcat的logo是一只公猫（寓意表示Tomcat服务器是轻巧的，小巧的，果然，体积小，运行速度快，只实现了Servlet+JSP规范） tomcat是java语言写的。 tomcat服务器要想运行，必须先又jre（Java的运行时环境） Tomcat服务器要想运行，需要先有jre，所以要先安装JDK，配置java运行环境。 JAVA_HOME&#x3D;C:\\Program Files\\Java\\jdk-17.0.1 PATH&#x3D;%JAVA_HOME%\\bin 目前JAVA_HOME没有配置，思考一个问题，这样行不行呢？目前只运行java程序是没问题的。真的没问题吗？ Tomcat服务器的安装： 绿色版本的安装很简单，直接zip包解压即可。解压就是安装。 我有一个好习惯，在C盘的根目录下新建一个dev目录，java开发所有相关的工具都安装到dev目录下，这样比较方便管理。（你随意） 启动Tomcat bin目录下有一个文件：startup.bat,通过它可以启动Tomcat服务器。 xxx.bat文件是个什么文件？bat文件是windows操作系统专用的，bat文件是批处理文件，这种文件中可以编写大量的windows的dos命令，然后执行bat文件就相当于批量的执行dos命令。 startup.sh，这个文件在windows当中无法执行，在Linux环境当中可以使用。在Linux环境下能够执行的是shell命令，大量的shell命令编写在shell文件当中，然后执行这个shell文件可以批量的执行shell命令。 tomcat服务器提供了bat和sh文件，说明了这个tomcat服务器的通用性。 分析startup.bat文件得出，执行这个命令，实际上最后是执行：catalina.bat文件。 catalina.bat文件中有这样一行配置：MAINCLASS&#x3D;org.apache.catalina.startup.Bootstrap （这个类就是main方法所在的类。） tomcat服务器就是Java语言写的，既然是java语言写的，那么启动Tomcat服务器就是执行main方法。 我们尝试打开dos命令窗口，在dos命令窗口中输入startup.bat来启动tomcat服务器。 启动Tomcat服务器只配置path对应的bin目录是不行的。有两个环境变量需要配置： JAVA_HOME&#x3D;JDK的根 CATALINA_HOME&#x3D;Tomcat服务器的根 关于Tomcat服务器的目录 bin ： 这个目录是Tomcat服务器的命令文件存放的目录，比如：启动Tomcat，关闭Tomcat等。 conf： 这个目录是Tomcat服务器的配置文件存放目录。（server.xml文件中可以配置端口号，默认Tomcat端口是8080） lib ：这个目录是Tomcat服务器的核心程序目录，因为Tomcat服务器是Java语言编写的，这里的jar包里面都是class文件。 logs: Tomcat服务器的日志目录，Tomcat服务器启动等信息都会在这个目录下生成日志文件。 temp：Tomcat服务器的临时目录。存储临时文件。 webapps：这个目录当中就是用来存放大量的webapp（web application：web应用） work：这个目录是用来存放JSP文件翻译之后的java文件以及编译之后的class文件。 配置Tomcat服务器需要哪些环境变量？ JAVA_HOME&#x3D;JDK的根 CATALINA_HOME&#x3D;Tomcat服务器的根 PATH&#x3D;%JAVA_HOME%\\bin;%CATALINA_HOME%\\bin 启动Tomcat： startup 关闭Tomcat：stop （shutdown.bat文件重命名为stop.bat，为什么？原因是shutdown命令和windows中的关机命令冲突。所以修改一下。） 怎么测试Tomcat服务器有没有启动成功呢？ 打开浏览器，在浏览器的地址栏上输入URL即可： http://ip地址:端口号 ip地址是什么？端口号我知道，是8080 本机的IP地址是：127.0.0.1，或者是localhost，都行。 实现一个最基本的web应用（这个web应用中没有java小程序） 第一步：找到CATALINA_HOME\\webapps目录 因为所有的webapp要放到webapps目录下。（没有为什么，这是Tomcat服务器的要求。如果不放到这里，Tomcat服务器找不到你的应用。） 第二步：在CATALINA_HOME\\webapps目录下新建一个子目录，起名：oa 这个目录名oa就是你这个webapp的名字。 第三步：在oa目录下新建资源文件，例如：index.html 编写index.html文件的内容。 第四步：启动Tomcat服务器 第五步：打开浏览器，在浏览器地址栏上输入这样的URL： http://127.0.0.1:8080/oa/index.html 思考一个问题： 我们在浏览器上直接输入一个URL，然后回车。这个动作和超链接一样吗？既然是一样的，我们完全可以使用超链接。 html123456&lt;!--注意以下的路径，以/开始，带项目名，是一个绝对路径。不需要添加：http://127.0.0.1:8080--&gt;&lt;a href=&quot;/oa/login.html&quot;&gt;user login2&lt;/a&gt;&lt;!--多个层级也没有关系，正常访问即可。--&gt;&lt;!--注意：我们目前前端上的路径都以“/”开始的，都是加项目名的。--&gt;&lt;a href=&quot;/oa/test/debug/d.html&quot;&gt;d page&lt;/a&gt; http://127.0.0.1:8080/oa/userList.html 访问这个地址，可以展示一个用户列表页面。但是这个用户列表页面是写死在HTML文件当中的。这种资源我们称为静态资源。怎么能变成动态资源。显然需要连接数据库。 连接数据库需要JDBC程序，也就是说需要编写Java程序连接数据库，数据库中有多少条记录，页面上就显示多少条记录，这种技术被称为动态网页技术。（动态网页技术并不是说页面中有flash动画。动态网页技术是说页面中的数据是动态的，根据数据库中数据的变化而变化。） 对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议 有哪些角色（在整个BS结构的系统当中，有哪些人参与进去了） 浏览器软件的开发团队（浏览器软件太多了：谷歌浏览器、火狐浏览器、IE浏览器….） WEB Server的开发团队（WEB Server这个软件也是太多了：Tomcat、Jetty、WebLogic、JBOSS、WebSphere….） DB Server的开发团队（DB Server这个软件也是太多了：Oracle、MySQL…..） webapp的开发团队（WEB应用是我们做为JavaWEB程序员开发的） 角色和角色之间需要遵守哪些规范，哪些协议 webapp的开发团队 和 WEB Server的开发团队 之间有一套规范: JavaEE规范之一Servlet规范。 Servlet规范的作用是什么？ WEB Server 和 webapp解耦合。 Browser 和 WebServer之间有一套传输协议：HTTP协议。（超文本传输协议。） webapp开发团队 和 DB Server的开发团队之间有一套规范：JDBC规范。 Servlet规范是一个什么规范？ 遵循Servlet规范的webapp，这个webapp就可以放在不同的WEB服务器中运行。（因为这个webapp是遵循Servlet规范的。） Servlet规范包括什么呢？ 规范了哪些接口 规范了哪些类 规范了一个web应用中应该有哪些配置文件 规范了一个web应用中配置文件的名字 规范了一个web应用中配置文件存放的路径 规范了一个web应用中配置文件的内容 规范了一个合法有效的web应用它的目录结构应该是怎样的。 ….. 开发一个带有Servlet（Java小程序）的webapp（重点） 开发步骤是怎样的？ 第一步：在webapps目录下新建一个目录，起名crm（这个crm就是webapp的名字）。当然，也可以是其它项目，比如银行项目，可以创建一个目录bank，办公系统可以创建一个oa。 注意：crm就是这个webapp的根 第二步：在webapp的根下新建一个目录：WEB-INF 注意：这个目录的名字是Servlet规范中规定的，必须全部大写，必须一模一样。必须的必须。 第三步：在WEB-INF目录下新建一个目录：classes 注意：这个目录的名字必须是全部小写的classes。这也是Servlet规范中规定的。另外这个目录下一定存放的是Java程序编译之后的class文件（这里存放的是字节码文件）。 第四步：在WEB-INF目录下新建一个目录：lib 注意：这个目录不是必须的。但如果一个webapp需要第三方的jar包的话，这个jar包要放到这个lib目录下，这个目录的名字也不能随意编写，必须是全部小写的lib。例如java语言连接数据库需要数据库的驱动jar包。那么这个jar包就一定要放到lib目录下。这Servlet规范中规定的。 第五步：在WEB-INF目录下新建一个文件：web.xml 注意：这个文件是必须的，这个文件名必须叫做web.xml。这个文件必须放在这里。一个合法的webapp，web.xml文件是必须的，这个web.xml文件就是一个配置文件，在这个配置文件中描述了请求路径和Servlet类之间的对照关系。 这个文件最好从其他的webapp中拷贝，最好别手写。没必要。复制粘贴 &#96;&#96;&#96;xml xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- 第六步：编写一个Java程序，这个小Java程序也不能随意开发，这个小java程序必须实现Servlet接口。 - 这个Servlet接口不在JDK当中。（因为Servlet不是JavaSE了。Servlet属于JavaEE，是另外的一套类库。） - Servlet接口（Servlet.class文件）是Oracle提供的。（最原始的是sun公司提供的。） - Servlet接口是JavaEE的规范中的一员。 - Tomcat服务器实现了Servlet规范，所以Tomcat服务器也需要使用Servlet接口。Tomcat服务器中应该有这个接口，Tomcat服务器的CATALINA_HOME\\lib目录下有一个servlet-api.jar，解压这个servlet-api.jar之后，你会看到里面有一个Servlet.class文件。 - 重点：从JakartaEE9开始，Servlet接口的全名变了：jakarta.servlet.Servlet - 注意：编写这个Java小程序的时候，java源代码你愿意在哪里就在哪里，位置无所谓，你只需要将java源代码编译之后的class文件放到classes目录下即可。- 第七步：编译我们编写的HelloServlet - 重点：你怎么能让你的HelloServlet编译通过呢？配置环境变量CLASSPATH CLASSPATH=.;C:\\dev\\apache-tomcat-10.0.12\\lib\\servlet-api.jar - 思考问题：以上配置的CLASSPATH和Tomcat服务器运行有没有关系？ - 没有任何关系，以上配置这个环境变量只是为了让你的HelloServlet能够正常编译生成class文件。- 第八步：将以上编译之后的HelloServlet.class文件拷贝到WEB-INF\\classes目录下。- 第九步：在web.xml文件中编写配置信息，让“请求路径”和“Servlet类名”关联在一起。 - 这一步用专业术语描述：在web.xml文件中注册Servlet类。 - ```xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot; version=&quot;5.0&quot; metadata-complete=&quot;true&quot;&gt; &lt;!--servlet描述信息--&gt; &lt;!--任何一个servlet都对应一个servlet-mapping --&gt; &lt;servlet&gt; &lt;servlet-name&gt;fdsafdsagfdsafdsa&lt;/servlet-name&gt; &lt;!--这个位置必须是带有包名的全限定类名--&gt; &lt;servlet-class&gt;com.bjpowernode.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--servlet映射信息--&gt; &lt;servlet-mapping&gt; &lt;!--这个也是随便的，不过这里写的内容要和上面的一样。--&gt; &lt;servlet-name&gt;fdsafdsagfdsafdsa&lt;/servlet-name&gt; &lt;!--这里需要一个路径--&gt; &lt;!--这个路径唯一的要求是必须以 / 开始--&gt; &lt;!--当前这个路径可以随便写--&gt; &lt;url-pattern&gt;/fdsa/fd/saf/d/sa/fd/sa/fd&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 第十步：启动Tomcat服务器 第十一步：打开浏览器，在浏览器地址栏上输入一个url，这个URL必须是： http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd 非常重要的一件事：浏览器上的请求路径不能随便写，这个请求路径必须和web.xml文件中的url-pattern一致。 注意：浏览器上的请求路径和web.xml文件中的url-pattern的唯一区别就是：浏览器上的请求路径带项目名：&#x2F;crm 浏览器上编写的路径太复杂，可以使用超链接。（非常重要：html页面只能放到WEB-INF目录外面。） 以后不需要我们编写main方法了。tomcat服务器负责调用main方法，Tomcat服务器启动的时候执行的就是main方法。我们javaweb程序员只需要编写Servlet接口的实现类，然后将其注册到web.xml文件中，即可。 总结一下：一个合法的webapp目录结构应该是怎样的？ jboss-cli12345678910webapproot |------WEB-INF |------classes(存放字节码) |------lib(第三方jar包) |------web.xml(注册Servlet) |------html |------css |------javascript |------image .... 浏览器发送请求，到最终服务器调用Servlet中的方法，是怎样的一个过程？（以下这个过程描述的很粗糙。其中还有很多步骤我省略了。） 用户输入URL，或者直接点击超链接：http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd 然后Tomcat服务器接收到请求，截取路径：&#x2F;crm&#x2F;fdsa&#x2F;fd&#x2F;saf&#x2F;d&#x2F;sa&#x2F;fd&#x2F;sa&#x2F;fd Tomcat服务器找到crm项目 Tomcat服务器在web.xml文件中查找&#x2F;fdsa&#x2F;fd&#x2F;saf&#x2F;d&#x2F;sa&#x2F;fd&#x2F;sa&#x2F;fd 对应的Servlet是：com.bjpowernode.servlet.HelloServlet Tomcat服务器通过反射机制，创建com.bjpowernode.servlet.HelloServlet的对象。 Tomcat服务器调用com.bjpowernode.servlet.HelloServlet对象的service方法。 关于JavaEE的版本 JavaEE目前最高版本是 JavaEE8 JavaEE被Oracle捐献了，Oracle将JavaEE规范捐献给Apache了。 Apache把JavaEE换名了，以后不叫JavaEE了，以后叫做 jakarta EE。 以后没有JavaEE了。以后都叫做Jakarta EE。 JavaEE8版本升级之后的”JavaEE 9”，不再是”JavaEE9”这个名字了，叫做JakartaEE9 JavaEE8的时候对应的Servlet类名是：javax.servlet.Servlet JakartaEE9的时候对应的Servlet类名是：jakarta.servlet.Servlet （包名都换了） 如果你之前的项目还是在使用javax.servlet.Servlet，那么你的项目无法直接部署到Tomcat10+版本上。你只能部署到Tomcat9-版本上。在Tomcat9以及Tomcat9之前的版本中还是能够识别javax.servlet这个包。 解决Tomcat服务器在DOS命令窗口中的乱码问题（控制台乱码）将CATALINA_HOME&#x2F;conf&#x2F;logging.properties文件中的内容修改如下： java.util.logging.ConsoleHandler.encoding &#x3D; GBK 向浏览器响应一段HTML代码java12345public void service(ServletRequest request, ServletResponse response)&#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.print(&quot;&lt;h1&gt;hello servlet!&lt;/h1&gt;&quot;);&#125; 在Servlet中连接数据库，怎么做？ Servlet是Java程序，所以在Servlet中完全可以编写JDBC代码连接数据库。 在一个webapp中去连接数据库，需要将驱动jar包放到WEB-INF&#x2F;lib目录下。（com.mysql.cj.jdbc.Driver 这个类就在驱动jar包当中。） 在集成开发环境当中开发Servlet程序 集成开发工具很多，其中目前使用比较多的是： IntelliJ IDEA（这个居多，IDEA在提示功能方面要强于Eclipse，也就是说IDEA使用起来比Eclipse更加智能，更好用。JetBrain公司开发的。收费的。） Eclipse（这个少一些），Eclipse目前还是有团队使用，只不过处于减少的趋势，自己从事工作之后，可能会遇到。Eclipse是IBM团队开发的。Eclipse寓意是“日食”。“日食”表示将太阳吃掉。太阳是SUN。IBM团队开发Eclipse的寓意是吞并SUN公司，但是2009年的时候SUN公司被Oracle公司并购了。IBM并没有成功并购SUN公司。 使用IDEA集成开发工具开发Servlet 第一步：New Project（我比较习惯先创建一个Empty Project【空工程】，然后在空工程下新建Module【模块】，这不是必须的，只是一种习惯，你可以直接新建非空的Project），这个Empty Project起名为：javaweb（不是必须的，只是一个名字而已。一般情况下新建的Project的名字最好和目录的名字一致。） 第二步：新建模块（File –&gt; new –&gt; Module…） 这里新建的是一个普通的JavaSE模块（这里先不要新建Java Enterprise模块） 这个Module自动会被放在javaweb的project下面。 这个Module起名：servlet01 第三步：让Module变成JavaEE的模块。（让Module变成webapp的模块。符合webapp规范。符合Servlet规范的Module） 在Module上点击右键：Add Framework Support…（添加框架支持） 在弹出的窗口中，选择Web Application（选择的是webapp的支持） 选择了这个webapp的支持之后，IDEA会自动给你生成一个符合Servlet规范的webpp目录结构。 重点，需要注意的：在IDEA工具中根据Web Application模板生成的目录中有一个web目录，这个目录就代表webapp的根 第四步（非必须）：根据Web Application生成的资源中有index.jsp文件，这里我选择删除这个index.jsp文件。 第五步：编写Servlet（StudentServlet） class StudentServlet implements Servlet 这个时候发现Servlet.class文件没有。怎么办？将CATALINA_HOME&#x2F;lib&#x2F;servlet-api.jar和jsp-api.jar添加到classpath当中（这里的classpath说的是IDEA的classpath） File –&gt; Project Structrue –&gt; Modules –&gt; + 加号 –&gt; Add JARS…. 实现jakarta.servlet.Servlet接口中的5个方法。 第六步：在Servlet当中的service方法中编写业务代码（我们这里连接数据库了。） 第七步：在WEB-INF目录下新建了一个子目录：lib（这个目录名可不能随意，必须是全部小写的lib），并且将连接数据库的驱动jar包放到lib目录下。 第八步：在web.xml文件中完成StudentServlet类的注册。（请求路径和Servlet之间对应起来） java12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;studentServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.StudentServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;studentServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/student&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 第九步：给一个html页面，在HTML页面中编写一个超链接，用户点击这个超链接，发送请求，Tomcat执行后台的StudentServlet。 student.html 这个文件不能放到WEB-INF目录里面，只能放到WEB-INF目录外面。 student.html文件的内容 &#96;&#96;&#96;html student page student list markdown12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 - 第十步：让IDEA工具去关联Tomcat服务器。关联的过程当中将webapp部署到Tomcat服务器当中。 - IDEA工具右上角，绿色小锤子右边有一个：Add Configuration - 左上角加号，点击Tomcat Server --&gt; local - 在弹出的界面中设置服务器Server的参数（基本上不用动） - 在当前窗口中有一个Deployment（点击这个用来部署webapp），继续点击加号，部署即可。 - 修改 Application context为：/xmm - 第十一步：启动Tomcat服务器 - 在右上角有绿色的箭头，或者绿色的小虫子，点击这个绿色的小虫子，可以采用debug的模式启动Tomcat服务器。 - 我们开发中建议适用debug模式启动Tomcat - 第十二步：打开浏览器，在浏览器地址栏上输入：http://localhost:8080/xmm/student.html## Servlet对象的生命周期- 什么是Servlet对象生命周期？ - Servlet对象什么时候被创建。 - Servlet对象什么时候被销毁。 - Servlet对象创建了几个？ - Servlet对象的生命周期表示：一个Servlet对象从出生在最后的死亡，整个过程是怎样的。- Servlet对象是由谁来维护的？ - Servlet对象的创建，对象上方法的调用，对象最终的销毁，Javaweb程序员是无权干预的。 - Servlet对象的生命周期是由Tomcat服务器（WEB Server）全权负责的。 - Tomcat服务器通常我们又称为：WEB容器。（这个叫法你要知道【WEB Container】） - WEB容器来管理Servlet对象的死活。- 思考：我们自己new的Servlet对象受WEB容器的管理吗？ - 我们自己new的Servlet对象是不受WEB容器管理的。 - WEB容器创建的Servlet对象，这些Servlet对象都会被放到一个集合当中（HashMap），只有放到这个HashMap集合中的Servlet才能够被WEB容器管理，自己new的Servlet对象不会被WEB容器管理。（自己new的Servlet对象不在容器当中） - web容器底层应该有一个HashMap这样的集合，在这个集合当中存储了Servlet对象和请求路径之间的关系 - ![WEB容器中的Map集合](D:\\course\\01-Servlet\\文档\\WEB容器中的Map集合.png)- 研究：服务器在启动的Servlet对象有没有被创建出来（默认情况下）？ - 在Servlet中提供一个无参数的构造方法，启动服务器的时候看看构造方法是否执行。 - 经过测试得出结论：默认情况下，服务器在启动的时候Servlet对象并不会被实例化。 - 这个设计是合理的。用户没有发送请求之前，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且创建出来的Servlet如果一直没有用户访问，显然这个Servlet对象是一个废物，没必要先创建。- 怎么让服务器启动的时候创建Servlet对象呢？ - 在servlet标签中添加&lt;load-on-startup&gt;子标签，在该子标签中填写整数，越小的整数优先级越高。 - ```xml &lt;servlet&gt; &lt;servlet-name&gt;aservlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.AServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;aservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Servlet对象生命周期 默认情况下服务器启动的时候AServlet对象并没有被实例化 用户发送第一次请求的时候，控制台输出了以下内容： oxygene123AServlet无参数构造方法执行了AServlet&#x27;s init method execute!AServlet&#x27;s service method execute! 根据以上输出内容得出结论： 用户在发送第一次请求的时候Servlet对象被实例化（AServlet的构造方法被执行了。并且执行的是无参数构造方法。） AServlet对象被创建出来之后，Tomcat服务器马上调用了AServlet对象的init方法。（init方法在执行的时候，AServlet对象已经存在了。已经被创建出来了。） 用户发送第一次请求的时候，init方法执行之后，Tomcat服务器马上调用AServlet对象的service方法。 用户继续发送第二次请求，控制台输出了以下内容： ada1AServlet&#x27;s service method execute! 根据以上输出结果得知，用户在发送第二次，或者第三次，或者第四次请求的时候，Servlet对象并没有新建，还是使用之前创建好的Servlet对象，直接调用该Servlet对象的service方法，这说明： 第一：Servlet对象是单例的（单实例的。但是要注意：Servlet对象是单实例的，但是Servlet类并不符合单例模式。我们称之为假单例。之所以单例是因为Servlet对象的创建我们javaweb程序员管不着，这个对象的创建只能是Tomcat来说了算，Tomcat只创建了一个，所以导致了单例，但是属于假单例。真单例模式，构造方法是私有化的。） 第二：无参数构造方法、init方法只在第一次用户发送请求的时候执行。也就是说无参数构造方法只执行一次。init方法也只被Tomcat服务器调用一次。 第三：只要用户发送一次请求：service方法必然会被Tomcat服务器调用一次。发送100次请求，service方法会被调用100次。 关闭服务器的时候，控制台输出了以下内容： ada1AServlet&#x27;s destroy method execute! 通过以上输出内容，可以得出以下结论： Servlet的destroy方法只被Tomcat服务器调用一次。 destroy方法是在什么时候被调用的？ 在服务器关闭的时候。 因为服务器关闭的时候要销毁AServlet对象的内存。 服务器在销毁AServlet对象内存之前，Tomcat服务器会自动调用AServlet对象的destroy方法。 请问：destroy方法调用的时候，对象销毁了还是没有销毁呢？ destroy方法执行的时候AServlet对象还在，没有被销毁。destroy方法执行结束之后，AServlet对象的内存才会被Tomcat释放。 Servlet对象更像一个人的一生： Servlet的无参数构造方法执行：标志着你出生了。 Servlet对象的init方法的执行：标志着你正在接受教育。 Servlet对象的service方法的执行：标志着你已经开始工作了，已经开始为人类提供服务了。 Servlet对象的destroy方法的执行：标志着临终。有什么遗言，抓紧的。要不然，来不及了。 关于Servlet类中方法的调用次数？ 构造方法只执行一次。 init方法只执行一次。 service方法：用户发送一次请求则执行一次，发送N次请求则执行N次。 destroy方法只执行一次。 当我们Servlet类中编写一个有参数的构造方法，如果没有手动编写无参数构造方法会出现什么问题？ 报错了：500错误。 注意：500是一个HTTP协议的错误状态码。 500一般情况下是因为服务器端的Java程序出现了异常。（服务器端的错误都是500错误：服务器内部错误。） 如果没有无参数的构造方法，会导致出现500错误，无法实例化Servlet对象。 所以，一定要注意：在Servlet开发当中，不建议程序员来定义构造方法，因为定义不当，一不小心就会导致无法实例化Servlet对象。 思考：Servlet的无参数构造方法是在对象第一次创建的时候执行，并且只执行一次。init方法也是在对象第一次创建的时候执行，并且只执行一次。那么这个无参数构造方法可以代替掉init方法吗？ 不能。 Servlet规范中有要求，作为javaweb程序员，编写Servlet类的时候，不建议手动编写构造方法，因为编写构造方法，很容易让无参数构造方法消失，这个操作可能会导致Servlet对象无法实例化。所以init方法是有存在的必要的。 init、service、destroy方法中使用最多的是哪个方法？ 使用最多就是service方法，service方法是一定要实现的，因为service方法是处理用户请求的核心方法。 什么时候使用init方法呢？ init方法很少用。 通常在init方法当中做初始化操作，并且这个初始化操作只需要执行一次。例如：初始化数据库连接池，初始化线程池…. 什么时候使用destroy方法呢？ destroy方法也很少用。 通常在destroy方法当中，进行资源的关闭。马上对象要被销毁了，还有什么没有关闭的，抓紧时间关闭资源。还有什么资源没保存的，抓紧时间保存一下。 GenericServlet 我们编写一个Servlet类直接实现Servlet接口有什么缺点？ 我们只需要service方法，其他方法大部分情况下是不需要使用的。代码很丑陋。 适配器设计模式Adapter 手机直接插到220V的电压上，手机直接就报废了。怎么办？可以找一个充电器。这个充电器就是一个适配器。手机连接适配器。适配器连接220V的电压。这样问题就解决了。 编写一个GenericServlet类，这个类是一个抽象类，其中有一个抽象方法service。 GenericServlet实现Servlet接口。 GenericServlet是一个适配器。 以后编写的所有Servlet类继承GenericServlet，重写service方法即可。 思考：GenericServlet类是否需要改造一下？怎么改造？更利于子类程序的编写？ 思考第一个问题：我提供了一个GenericServlet之后，init方法还会执行吗？ 还会执行。会执行GenericServlet类中的init方法。 思考第二个问题：init方法是谁调用的？ Tomcat服务器调用的。 思考第三个问题：init方法中的ServletConfig对象是谁创建的？是谁传过来的？ 都是Tomcat干的。 Tomcat服务器先创建了ServletConfig对象，然后调用init方法，将ServletConfig对象传给了init方法。 思考一下Tomcat服务器伪代码： &#96;&#96;&#96;javapublic class Tomcat {public static void main(String[] args){ &#x2F;&#x2F; ….. &#x2F;&#x2F; Tomcat服务器伪代码 &#x2F;&#x2F; 创建LoginServlet对象（通过反射机制，调用无参数构造方法来实例化LoginServlet对象） Class clazz &#x3D; Class.forName(“com.bjpowernode.javaweb.servlet.LoginServlet”); Object obj &#x3D; clazz.newInstance(); &#x2F;&#x2F; 向下转型 Servlet servlet &#x3D; (Servlet)obj; &#x2F;&#x2F; 创建ServletConfig对象 &#x2F;&#x2F; Tomcat服务器负责将ServletConfig对象实例化出来。 &#x2F;&#x2F; 多态（Tomcat服务器完全实现了Servlet规范） ServletConfig servletConfig &#x3D; new org.apache.catalina.core.StandardWrapperFacade(); &#x2F;&#x2F; 调用Servlet的init方法 servlet.init(servletConfig); &#x2F;&#x2F; 调用Servlet的service方法 &#x2F;&#x2F; ….}}csharp12345678910111213141516171819202122232425## ServletConfig- 什么是ServletConfig？ - Servlet对象的配置信息对象。 - ServletConfig对象中封装了&lt;servlet&gt;&lt;/servlet&gt;标签中的配置信息。（web.xml文件中servlet的配置信息）- 一个Servlet对应一个ServletConfig对象。- Servlet对象是Tomcat服务器创建，并且ServletConfig对象也是Tomcat服务器创建。并且默认情况下，他们都是在用户发送第一次请求的时候创建。- Tomcat服务器调用Servlet对象的init方法的时候需要传一个ServletConfig对象的参数给init方法。- ServletConfig接口的实现类是Tomcat服务器给实现的。（Tomcat服务器说的就是WEB服务器。）- ServletConfig接口有哪些常用的方法？ - ```java public String getInitParameter(String name); // 通过初始化参数的name获取value public Enumeration&lt;String&gt; getInitParameterNames(); // 获取所有的初始化参数的name public ServletContext getServletContext(); // 获取ServletContext对象 public String getServletName(); // 获取Servlet的name 以上方法在Servlet类当中，都可以使用this去调用。因为GenericServlet实现了ServletConfig接口。 ServletContext 一个Servlet对象对应一个ServletConfig。100个Servlet对象则对应100个ServletConfig对象。 只要在同一个webapp当中，只要在同一个应用当中，所有的Servlet对象都是共享同一个ServletContext对象的。 ServletContext对象在服务器启动阶段创建，在服务器关闭的时候销毁。这就是ServletContext对象的生命周期。ServletContext对象是应用级对象。 Tomcat服务器中有一个webapps，这个webapps下可以存放webapp，可以存放多个webapp，假设有100个webapp，那么就有100个ServletContext对象。但是，总之，一个应用，一个webapp肯定是只有一个ServletContext对象。 ServletContext被称为Servlet上下文对象。（Servlet对象的四周环境对象。） 一个ServletContext对象通常对应的是一个web.xml文件。 ServletContext对应显示生活中的什么例子呢？ 一个教室里有多个学生，那么每一个学生就是一个Servlet，这些学生都在同一个教室当中，那么我们可以把这个教室叫做ServletContext对象。那么也就是说放在这个ServletContext对象（环境）当中的数据，在同一个教室当中，物品都是共享的。比如：教室中有一个空调，所有的学生都可以操作。可见，空调是共享的。因为空调放在教室当中。教室就是ServletContext对象。 ServletContext是一个接口，Tomcat服务器对ServletContext接口进行了实现。 ServletContext对象的创建也是Tomcat服务器来完成的。启动webapp的时候创建的。 ServletContext接口中有哪些常用的方法？ public String getInitParameter(String name); // 通过初始化参数的name获取value public Enumeration&lt;String&gt; getInitParameterNames(); // 获取所有的初始化参数的name xml12345678910111213- ```xml &lt;!--以上两个方法是ServletContext对象的方法，这个方法获取的是什么信息？是以下的配置信息--&gt; &lt;context-param&gt; &lt;param-name&gt;pageSize&lt;/param-name&gt; &lt;param-value&gt;10&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;startIndex&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--注意：以上的配置信息属于应用级的配置信息，一般一个项目中共享的配置信息会放到以上的标签当中。--&gt; &lt;!--如果你的配置信息只是想给某一个servlet作为参考，那么你配置到servlet标签当中即可，使用ServletConfig对象来获取。--&gt; // 获取应用的根路径（非常重要），因为在java源代码当中有一些地方可能会需要应用的根路径，这个方法可以动态获取应用的根路径 // 在java源码当中，不要将应用的根路径写死，因为你永远都不知道这个应用在最终部署的时候，起一个什么名字。 public String getContextPath(); //String contextPath = application.getContextPath(); arduino1234- ```java // 获取文件的绝对路径（真实路径） public String getRealPath(String path); &#96;&#96;&#96;java&#x2F;&#x2F; 通过ServletContext对象也是可以记录日志的public void log(String message);public void log(String message, Throwable t);&#x2F;&#x2F; 这些日志信息记录到哪里了？&#x2F;&#x2F; localhost.2021-11-05.log &#x2F;&#x2F; Tomcat服务器的logs目录下都有哪些日志文件？&#x2F;&#x2F;catalina.2021-11-05.log 服务器端的java程序运行的控制台信息。&#x2F;&#x2F;localhost.2021-11-05.log ServletContext对象的log方法记录的日志信息存储到这个文件中。&#x2F;&#x2F;localhost_access_log.2021-11-05.txt 访问日志 awk1234567891011121314151617181920212223- ```java // ServletContext对象还有另一个名字：应用域（后面还有其他域，例如：请求域、会话域） // 如果所有的用户共享一份数据，并且这个数据很少的被修改，并且这个数据量很少，可以将这些数据放到ServletContext这个应用域中 // 为什么是所有用户共享的数据？ 不是共享的没有意义。因为ServletContext这个对象只有一个。只有共享的数据放进去才有意义。 // 为什么数据量要小？ 因为数据量比较大的话，太占用堆内存，并且这个对象的生命周期比较长，服务器关闭的时候，这个对象才会被销毁。大数据量会影响服务器的性能。占用内存较小的数据量可以考虑放进去。 // 为什么这些共享数据很少的修改，或者说几乎不修改？ // 所有用户共享的数据，如果涉及到修改操作，必然会存在线程并发所带来的安全问题。所以放在ServletContext对象中的数据一般都是只读的。 // 数据量小、所有用户共享、又不修改，这样的数据放到ServletContext这个应用域当中，会大大提升效率。因为应用域相当于一个缓存，放到缓存中的数据，下次在用的时候，不需要从数据库中再次获取，大大提升执行效率。 // 存（怎么向ServletContext应用域中存数据） public void setAttribute(String name, Object value); // map.put(k, v) // 取（怎么从ServletContext应用域中取数据） public Object getAttribute(String name); // Object v = map.get(k) // 删（怎么删除ServletContext应用域中的数据） public void removeAttribute(String name); // map.remove(k) 注意：以后我们编写Servlet类的时候，实际上是不会去直接继承GenericServlet类的，因为我们是B&#x2F;S结构的系统，这种系统是基于HTTP超文本传输协议的，在Servlet规范当中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类。我们编写的Servlet类要继承HttpServlet。（HttpServlet是HTTP协议专用的。）使用HttpServlet处理HTTP协议更便捷。但是你需要直到它的继承结构： jakarta.servlet.Servlet（接口）【爷爷】 jakarta.servlet.GenericServlet implements Servlet（抽象类）【儿子】 jakarta.servlet.http.HttpServlet extends GenericServlet（抽象类）【孙子】 我们以后编写的Servlet要继承HttpServlet类。 nestedtext1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889- 大家到目前为止都接触过哪些缓存机制了？ - 堆内存当中的字符串常量池。 - &quot;abc&quot; 先在字符串常量池中查找，如果有，直接拿来用。如果没有则新建，然后再放入字符串常量池。 - 堆内存当中的整数型常量池。 - [-128 ~ 127] 一共256个Integer类型的引用，放在整数型常量池中。没有超出这个范围的话，直接从常量池中取。 - 连接池(Connection Cache) - 这里所说的连接池中的连接是java语言连接数据库的连接对象：java.sql.Connection对象。 - JVM是一个进程。MySQL数据库是一个进程。进程和进程之间建立连接，打开通道是很费劲的。是很耗费资源的。怎么办？可以提前先创建好N个Connection连接对象，将连接对象放到一个集合当中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要再新建连接对象，省去了新建的环节，直接从连接池中获取连接对象，大大提升访问效率。 - 连接池 - 最小连接数 - 最大连接数 - 连接池可以提高用户的访问效率。当然也可以保证数据库的安全性。 - 线程池 - Tomcat服务器本身就是支持多线程的。 - Tomcat服务器是在用户发送一次请求，就新建一个Thread线程对象吗？ - 当然不是，实际上是在Tomcat服务器启动的时候，会先创建好N多个线程Thread对象，然后将线程对象放到集合当中，称为线程池。用户发送请求过来之后，需要有一个对应的线程来处理这个请求，这个时候线程对象就会直接从线程池中拿，效率比较高。 - 所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制。 - redis - NoSQL数据库。非关系型数据库。缓存数据库。 - 向ServletContext应用域中存储数据，也等于是将数据存放到缓存cache当中了。## HTTP协议- 什么是协议？ - 协议实际上是某些人，或者某些组织提前制定好的一套规范，大家都按照这个规范来，这样可以做到沟通无障碍。 - 协议就是一套规范，就是一套标准。由其他人或其他组织来负责制定的。 - 我说的话你能听懂，你说的话，我也能听懂，这说明我们之间是有一套规范的，一套协议的，这套协议就是：中国普通话协议。我们都遵守这套协议，我们之间就可以沟通无障碍。- 什么是HTTP协议？ - HTTP协议：是W3C制定的一种超文本传输协议。（通信协议：发送消息的模板提前被制定好。） - W3C： - 万维网联盟组织 - 负责制定标准的：HTTP HTML4.0 HTML5 XML DOM等规范都是W3C制定的。 - 万维网之父：蒂姆·伯纳斯·李 - 什么是超文本？ - 超文本说的就是：不是普通文本，比如流媒体：声音、视频、图片等。 - HTTP协议支持：不但可以传送普通字符串，同样支持传递声音、视频、图片等流媒体信息。 - 这种协议游走在B和S之间。B向S发数据要遵循HTTP协议。S向B发数据同样需要遵循HTTP协议。这样B和S才能解耦合。 - 什么是解耦合？ - B不依赖S。 - S也不依赖B。 - B/S表示：B/S结构的系统（浏览器访问WEB服务器的系统） - 浏览器 向 WEB服务器发送数据，叫做：请求（request) - WEB服务器 向 浏览器发送数据，叫做：响应（response） - HTTP协议包括： - 请求协议 - 浏览器 向 WEB服务器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。 - 响应协议 - WEB服务器 向 浏览器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。 - HTTP协议就是提前制定好的一种消息模板。 - 不管你是哪个品牌的浏览器，都是这么发。 - 不管你是哪个品牌的WEB服务器，都是这么发。 - FF浏览器 可以向 Tomcat发送请求，也可以向Jetty服务器发送请求。浏览器不依赖具体的服务器品牌。 - WEB服务器也不依赖具体的浏览器品牌。可以是FF浏览器，也可以是Chrome浏览器，可以是IE，都行。- HTTP的请求协议（B --&gt; S） - HTTP的请求协议包括：4部分 - 请求行 - 请求头 - 空白行 - 请求体 - HTTP请求协议的具体报文：GET请求 - ``` GET /servlet05/getServlet?username=lucy&amp;userpwd=1111 HTTP/1.1 请求行 Host: localhost:8080 请求头 Connection: keep-alive sec-ch-ua: &quot;Google Chrome&quot;;v=&quot;95&quot;, &quot;Chromium&quot;;v=&quot;95&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: &quot;Windows&quot; Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: same-origin Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Referer: http://localhost:8080/servlet05/index.html Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 空白行 请求体 HTTP请求协议的具体报文：POST请求 &#96;&#96;&#96;POST &#x2F;servlet05&#x2F;postServlet HTTP&#x2F;1.1 请求行Host: localhost:8080 请求头Connection: keep-aliveContent-Length: 25Cache-Control: max-age&#x3D;0sec-ch-ua: “Google Chrome”;v&#x3D;”95”, “Chromium”;v&#x3D;”95”, “;Not A Brand”;v&#x3D;”99”sec-ch-ua-mobile: ?0sec-ch-ua-platform: “Windows”Upgrade-Insecure-Requests: 1Origin: http://localhost:8080Content-Type: application&#x2F;x-www-form-urlencodedUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.54 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,&#x2F;;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Sec-Fetch-Site: same-originSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentReferer: http://localhost:8080/servlet05/index.htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q&#x3D;0.9 空白行username&#x3D;lisi&amp;userpwd&#x3D;123 请求体nestedtext123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 - 请求行 - 包括三部分： - 第一部分：请求方式（7种） - get（常用的） - post（常用的） - delete - put - head - options - trace - 第二部分：URI - 什么是URI？ 统一资源标识符。代表网络中某个资源的名字。但是通过URI是无法定位资源的。 - 什么是URL？统一资源定位符。代表网络中某个资源，同时，通过URL是可以定位到该资源的。 - URI和URL什么关系，有什么区别？ - URL包括URI - http://localhost:8080/servlet05/index.html 这是URL。 - /servlet05/index.html 这是URI。 - 第三部分：HTTP协议版本号 - 请求头 - 请求的主机 - 主机的端口 - 浏览器信息 - 平台信息 - cookie等信息 - .... - 空白行 - 空白行是用来区分“请求头”和“请求体” - 请求体 - 向服务器发送的具体数据。- HTTP的响应协议（S --&gt; B） - HTTP的响应协议包括：4部分 - 状态行 - 响应头 - 空白行 - 响应体 - HTTP响应协议的具体报文： - ``` HTTP/1.1 200 ok 状态行 Content-Type: text/html;charset=UTF-8 响应头 Content-Length: 160 Date: Mon, 08 Nov 2021 13:19:32 GMT Keep-Alive: timeout=20 Connection: keep-alive 空白行 &lt;!doctype html&gt; 响应体 &lt;html&gt; &lt;head&gt; &lt;title&gt;from get servlet&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;from get servlet&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 状态行 三部分组成 第一部分：协议版本号（HTTP&#x2F;1.1） 第二部分：状态码（HTTP协议中规定的响应状态号。不同的响应结果对应不同的号码。） 200 表示请求响应成功，正常结束。 404表示访问的资源不存在，通常是因为要么是你路径写错了，要么是路径写对了，但是服务器中对应的资源并没有启动成功。总之404错误是前端错误。 405表示前端发送的请求方式与后端请求的处理方式不一致时发生： 比如：前端是POST请求，后端的处理方式按照get方式进行处理时，发生405 比如：前端是GET请求，后端的处理方式按照post方式进行处理时，发生405 500表示服务器端的程序出现了异常。一般会认为是服务器端的错误导致的。 以4开始的，一般是浏览器端的错误导致的。 以5开始的，一般是服务器端的错误导致的。 第三部分：状态的描述信息 ok 表示正常成功结束。 not found 表示资源找不到。 响应头： 响应的内容类型 响应的内容长度 响应的时间 …. 空白行： 用来分隔“响应头”和“响应体”的。 响应体： 响应体就是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果。 怎么查看的协议内容？ 使用chrome浏览器：F12。然后找到network，通过这个面板可以查看协议的具体内容。 怎么向服务器发送GET请求，怎么向服务器发送POST请求？ 到目前为止，只有一种情况可以发送POST请求：使用form表单，并且form标签中的method属性值为：method&#x3D;”post”。 其他所有情况一律都是get请求： 在浏览器地址栏上直接输入URL，敲回车，属于get请求。 在浏览器上直接点击超链接，属于get请求。 使用form表单提交数据时，form标签中没有写method属性，默认就是get 或者使用form的时候，form标签中method属性值为：method&#x3D;”get” …. GET请求和POST请求有什么区别？ get请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个“?”，”?”后面是数据。这样会导致发送的数据回显在浏览器的地址栏上。（get请求在“请求行”上发送数据） http://localhost:8080/servlet05/getServlet?username=zhangsan&amp;userpwd=1111 post请求发送数据的时候，在请求体当中发送。不会回显到浏览器的地址栏上。也就是说post发送的数据，在浏览器地址栏上看不到。（post在“请求体”当中发送数据） get请求只能发送普通的字符串。并且发送的字符串长度有限制，不同的浏览器限制不同。这个没有明确的规范。 get请求无法发送大数据量。 post请求可以发送任何类型的数据，包括普通字符串，流媒体等信息：视频、声音、图片。 post请求可以发送大数据量，理论上没有长度限制。 get请求在W3C中是这样说的：get请求比较适合从服务器端获取数据。 post请求在W3C中是这样说的：post请求比较适合向服务器端传送数据。 get请求是安全的。get请求是绝对安全的。为什么？因为get请求只是为了从服务器上获取数据。不会对服务器造成威胁。（get本身是安全的，你不要用错了。用错了之后又冤枉人家get不安全，你这样不好（太坏了），那是你自己的问题，不是get请求的问题。） post请求是危险的。为什么？因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，服务器是很危险的。另外post是为了提交数据，所以一般情况下拦截请求的时候，大部分会选择拦截（监听）post请求。 get请求支持缓存。 https://n.sinaimg.cn/finance/590/w240h350/20211101/b40c-b425eb67cabc342ff5b9dc018b4b00cc.jpg 任何一个get请求最终的“响应结果”都会被浏览器缓存起来。在浏览器缓存当中： 一个get请求的路径a 对应 一个资源。 一个get请求的路径b 对应 一个资源。 一个get请求的路径c 对应 一个资源。 …… 实际上，你只要发送get请求，浏览器做的第一件事都是先从本地浏览器缓存中找，找不到的时候才会去服务器上获取。这种缓存机制目的是为了提高用户的体验。 有没有这样一个需求：我们不希望get请求走缓存，怎么办？怎么避免走缓存？我希望每一次这个get请求都去服务器上找资源，我不想从本地浏览器的缓存中取。 只要每一次get请求的请求路径不同即可。 https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897898 https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897899 https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=系统毫秒数 怎么解决？可以在路径的后面添加一个每时每刻都在变化的“时间戳”，这样，每一次的请求路径都不一样，浏览器就不走缓存了。 post请求不支持缓存。（POST是用来修改服务器端的资源的。） post请求之后，服务器“响应的结果”不会被浏览器缓存起来。因为这个缓存没有意义。 GET请求和POST请求如何选择，什么时候使用GET请求，什么时候使用POST请求？ 怎么选择GET请求和POST请求呢？衡量标准是什么呢？你这个请求是想获取服务器端的数据，还是想向服务器发送数据。如果你是想从服务器上获取资源，建议使用GET请求，如果你这个请求是为了向服务器提交数据，建议使用POST请求。 大部分的form表单提交，都是post方式，因为form表单中要填写大量的数据，这些数据是收集用户的信息，一般是需要传给服务器，服务器将这些数据保存&#x2F;修改等。 如果表单中有敏感信息，还是建议适用post请求，因为get请求会回显敏感信息到浏览器地址栏上。（例如：密码信息） 做文件上传，一定是post请求。要传的数据不是普通文本。 其他情况都可以使用get请求。 不管你是get请求还是post请求，发送的请求数据格式是完全相同的，只不过位置不同，格式都是统一的： name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value name是什么？ 以form表单为例：form表单中input标签的name。 value是什么？ 以form表单为例：form表单中input标签的value。 模板方法设计模式 什么是设计模式？ 某个问题的固定的解决方案。(可以被重复使用。) 你知道哪些设计模式？ GoF设计模式： 通常我们所说的23种设计模式。（Gang of Four：4人组提出的设计模式） 单例模式 工厂模式 代理模式 门面模式 责任链设计模式 观察者模式 模板方法设计模式 ….. JavaEE设计模式： DAO DTO VO PO pojo …. …. 什么是模板方法设计模式？ 在模板类的模板方法当中定义核心算法骨架，具体的实现步骤可以延迟到子类当中完成。 模板类通常是一个抽象类，模板类当中的模板方法定义核心算法，这个方法通常是final的（但也可以不是final的） 模板类当中的抽象方法就是不确定实现的方法，这个不确定怎么实现的事儿交给子类去做。 HttpServlet源码分析 HttpServlet类是专门为HTTP协议准备的。比GenericServlet更加适合HTTP协议下的开发。 HttpServlet在哪个包下？ jakarta.servlet.http.HttpServlet 到目前为止我们接触了servlet规范中哪些接口？ jakarta.servlet.Servlet 核心接口（接口） jakarta.servlet.ServletConfig Servlet配置信息接口（接口） jakarta.servlet.ServletContext Servlet上下文接口（接口） jakarta.servlet.ServletRequest Servlet请求接口（接口） jakarta.servlet.ServletResponse Servlet响应接口（接口） jakarta.servlet.ServletException Servlet异常（类） jakarta.servlet.GenericServlet 标准通用的Servlet类（抽象类） http包下都有哪些类和接口呢？jakarta.servlet.http.*; jakarta.servlet.http.HttpServlet （HTTP协议专用的Servlet类，抽象类） jakarta.servlet.http.HttpServletRequest （HTTP协议专用的请求对象） jakarta.servlet.http.HttpServletResponse （HTTP协议专用的响应对象） HttpServletRequest对象中封装了什么信息？ HttpServletRequest，简称request对象。 HttpServletRequest中封装了请求协议的全部内容。 Tomcat服务器（WEB服务器）将“请求协议”中的数据全部解析出来，然后将这些数据全部封装到request对象当中了。 也就是说，我们只要面向HttpServletRequest，就可以获取请求协议中的数据。 HttpServletResponse对象是专门用来响应HTTP协议到浏览器的。 回忆Servlet生命周期？ 用户第一次请求 Tomcat服务器通过反射机制，调用无参数构造方法。创建Servlet对象。(web.xml文件中配置的Servlet类对应的对象。) Tomcat服务器调用Servlet对象的init方法完成初始化。 Tomcat服务器调用Servlet对象的service方法处理请求。 用户第二次请求 Tomcat服务器调用Servlet对象的service方法处理请求。 用户第三次请求 Tomcat服务器调用Servlet对象的service方法处理请求。 …. Tomcat服务器调用Servlet对象的service方法处理请求。 服务器关闭 Tomcat服务器调用Servlet对象的destroy方法，做销毁之前的准备工作。 Tomcat服务器销毁Servlet对象。 HttpServlet源码分析： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160public class HelloServlet extends HttpServlet &#123; // 用户第一次请求，创建HelloServlet对象的时候，会执行这个无参数构造方法。 public HelloServlet() &#123; &#125; //override 重写 doGet方法 //override 重写 doPost方法&#125;public abstract class GenericServlet implements Servlet, ServletConfig, java.io.Serializable &#123; // 用户第一次请求的时候，HelloServlet对象第一次被创建之后，这个init方法会执行。 public void init(ServletConfig config) throws ServletException &#123; this.config = config; this.init(); &#125; // 用户第一次请求的时候，带有参数的init(ServletConfig config)执行之后，会执行这个没有参数的init() public void init() throws ServletException &#123; // NOOP by default &#125;&#125;// HttpServlet模板类。public abstract class HttpServlet extends GenericServlet &#123; // 用户发送第一次请求的时候这个service会执行 // 用户发送第N次请求的时候，这个service方法还是会执行。 // 用户只要发送一次请求，这个service方法就会执行一次。 @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request; HttpServletResponse response; try &#123; // 将ServletRequest和ServletResponse向下转型为带有Http的HttpServletRequest和HttpServletResponse request = (HttpServletRequest) req; response = (HttpServletResponse) res; &#125; catch (ClassCastException e) &#123; throw new ServletException(lStrings.getString(&quot;http.non_http&quot;)); &#125; // 调用重载的service方法。 service(request, response); &#125; // 这个service方法的两个参数都是带有Http的。 // 这个service是一个模板方法。 // 在该方法中定义核心算法骨架，具体的实现步骤延迟到子类中去完成。 protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取请求方式 // 这个请求方式最终可能是：&quot;&quot; // 注意：request.getMethod()方法获取的是请求方式，可能是七种之一： // GET POST PUT DELETE HEAD OPTIONS TRACE String method = req.getMethod(); // 如果请求方式是GET请求，则执行doGet方法。 if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn&#x27;t support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince; try &#123; ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); &#125; catch (IllegalArgumentException iae) &#123; // Invalid date header - proceed as if none was set ifModifiedSince = -1; &#125; if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125; &#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); &#125; else if (method.equals(METHOD_POST)) &#123; // 如果请求方式是POST请求，则执行doPost方法。 doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); &#125; &#125; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; // 报405错误 String msg = lStrings.getString(&quot;http.method_get_not_supported&quot;); sendMethodNotAllowed(req, resp, msg); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 报405错误 String msg = lStrings.getString(&quot;http.method_post_not_supported&quot;); sendMethodNotAllowed(req, resp, msg); &#125; &#125;/*通过以上源代码分析： 假设前端发送的请求是get请求，后端程序员重写的方法是doPost 假设前端发送的请求是post请求，后端程序员重写的方法是doGet 会发生什么呢？ 发生405这样的一个错误。 405表示前端的错误，发送的请求方式不对。和服务器不一致。不是服务器需要的请求方式。 通过以上源代码可以知道：只要HttpServlet类中的doGet方法或doPost方法执行了，必然405.怎么避免405的错误呢？ 后端重写了doGet方法，前端一定要发get请求。 后端重写了doPost方法，前端一定要发post请求。 这样可以避免405错误。 这种前端到底需要发什么样的请求，其实应该后端说了算。后端让发什么方式，前端就得发什么方式。 有的人，你会看到为了避免405错误，在Servlet类当中，将doGet和doPost方法都进行了重写。这样，确实可以避免405的发生，但是不建议，405错误还是有用的。该报错的时候就应该让他报错。如果你要是同时重写了doGet和doPost，那还不如你直接重写service方法好了。这样代码还能少写一点。*/ 我们编写的HelloServlet直接继承HttpServlet，直接重写HttpServlet类中的service()方法行吗？ 可以，只不过你享受不到405错误。享受不到HTTP协议专属的东西。 到今天我们终于得到了最终的一个Servlet类的开发步骤： 第一步：编写一个Servlet类，直接继承HttpServlet 第二步：重写doGet方法或者重写doPost方法，到底重写谁，javaweb程序员说了算。 第三步：将Servlet类配置到web.xml文件当中。 第四步：准备前端的页面（form表单），form表单中指定请求路径即可。 关于一个web站点的欢迎页面 什么是一个web站点的欢迎页面？ 对于一个webapp来说，我们是可以设置它的欢迎页面的。 设置了欢迎页面之后，当你访问这个webapp的时候，或者访问这个web站点的时候，没有指定任何“资源路径”，这个时候会默认访问你的欢迎页面。 我们一般的访问方式是： http://localhost:8080/servlet06/login.html 这种方式是指定了要访问的就是login.html资源。 如果我们访问的方式是： http://localhost:8080/servlet06 如果我们访问的就是这个站点，没有指定具体的资源路径。它默认会访问谁呢？ 默认会访问你设置的欢迎页面。 怎么设置欢迎页面呢？ 第一步：我在IDEA工具的web目录下新建了一个文件login.html 第二步：在web.xml文件中进行了以下的配置 &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; markdown123456789101112131415161718192021 - 注意：设置欢迎页面的时候，这个路径不需要以“/”开始。并且这个路径默认是从webapp的根下开始查找。 - 第三步：启动服务器，浏览器地址栏输入地址 - http://localhost:8080/servlet07- 如果在webapp的根下新建一个目录，目录中再给一个文件，那么这个欢迎页该如何设置呢？ - 在webapp根下新建page1 - 在page1下新建page2目录 - 在page2目录下新建page.html页面 - 在web.xml文件中应该这样配置 - ``` &lt;welcome-file-list&gt; &lt;welcome-file&gt;page1/page2/page.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 注意：路径不需要以“&#x2F;”开始，并且路径默认从webapp的根下开始找。 一个webapp是可以设置多个欢迎页面的 &#96;&#96;&#96;xml page1/page2/page.html login.html vim12345678910111213141516171819 - 注意：越靠上的优先级越高。找不到的继续向下找。- 你有没有注意一件事：当我的文件名设置为index.html的时候，不需要在web.xml文件中进行配置欢迎页面。这是为什么？ - 这是因为小猫咪Tomcat服务器已经提前配置好了。 - 实际上配置欢迎页面有两个地方可以配置： - 一个是在webapp内部的web.xml文件中。（在这个地方配置的属于局部配置） - 一个是在CATALINA_HOME/conf/web.xml文件中进行配置。（在这个地方配置的属于全局配置） - ```xml &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; Tomcat服务器的全局欢迎页面是：index.html index.htm index.jsp。如果你一个web站点没有设置局部的欢迎页面，Tomcat服务器就会以index.html index.htm index.jsp作为一个web站点的欢迎页面。 注意原则：局部优先原则。（就近原则） 欢迎页可以是一个Servlet吗？ 当然可以。 你不要多想，欢迎页就是一个资源，既然是一个资源，那么可以是静态资源，也可以是动态资源。 静态资源：index.html welcome.html ….. 动态资源：Servlet类。 步骤： 第一步：写一个Servlet &#96;&#96;&#96;javapublic class WelcomeServlet extends HttpServlet {@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(“text&#x2F;html”); PrintWriter out &#x3D; response.getWriter(); out.print(“welcome to bjpowernode!“);}}xml1234567891011121314 - 第二步：在web.xml文件中配置servlet - ```xml &lt;servlet&gt; &lt;servlet-name&gt;welcomeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.WelcomeServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;welcomeServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/fdsa/fds/a/fds/af/ds/af/dsafdsafdsa&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 第三步：在web.xml文件中配置欢迎页 &#96;&#96;&#96;xml fdsa&#x2F;fds&#x2F;a&#x2F;fds&#x2F;af&#x2F;ds&#x2F;af&#x2F;dsafdsafdsamarkdown12345678910111213141516171819 ## 关于WEB-INF目录- 在WEB-INF目录下新建了一个文件：welcome.html- 打开浏览器访问：http://localhost:8080/servlet07/WEB-INF/welcome.html 出现了404错误。- 注意：放在WEB-INF目录下的资源是受保护的。在浏览器上不能够通过路径直接访问。所以像HTML、CSS、JS、image等静态资源一定要放到WEB-INF目录之外。## HttpServletRequest接口详解- HttpServletRequest是一个接口，全限定名称：jakarta.servlet.http.HttpServletRequest- HttpServletRequest接口是Servlet规范中的一员。- HttpServletRequest接口的父接口：ServletRequest - ```java public interface HttpServletRequest extends ServletRequest &#123;&#125; HttpServletRequest接口的实现类谁写的? HttpServletRequest对象是谁给创建的？ 通过测试：org.apache.catalina.connector.RequestFacade 实现了 HttpServletRequest接口 public class RequestFacade implements HttpServletRequest &#123;&#125; markdown1234567891011121314151617181920212223242526 - 测试结果说明：Tomcat服务器（WEB服务器、WEB容器）实现了HttpServletRequest接口，还是说明了Tomcat服务器实现了Servlet规范。而对于我们javaweb程序员来说，实际上不需要关心这个，我们只需要面向接口编程即可。我们关心的是HttpServletRequest接口中有哪些方法，这些方法可以完成什么功能！！！！- HttpServletRequest对象中都有什么信息？都包装了什么信息？ - HttpServletRequest对象是Tomcat服务器负责创建的。这个对象中封装了什么信息？封装了HTTP的请求协议。 - 实际上是用户发送请求的时候，遵循了HTTP协议，发送的是HTTP的请求协议，Tomcat服务器将HTTP协议中的信息以及数据全部解析出来，然后Tomcat服务器把这些信息封装到HttpServletRequest对象当中，传给了我们javaweb程序员。 - javaweb程序员面向HttpServletRequest接口编程，调用方法就可以获取到请求的信息了。- request和response对象的生命周期？ - request对象和response对象，一个是请求对象，一个是响应对象。这两个对象只在当前请求中有效。 - 一次请求对应一个request。 - 两次请求则对应两个request。 - .....- HttpServletRequest接口中有哪些常用的方法？ - 怎么获取前端浏览器用户提交的数据？ - ```java Map&lt;String,String[]&gt; getParameterMap() 这个是获取Map Enumeration&lt;String&gt; getParameterNames() 这个是获取Map集合中所有的key String[] getParameterValues(String name) 根据key获取Map集合的value String getParameter(String name) 获取value这个一维数组当中的第一个元素。这个方法最常用。 // 以上的4个方法，和获取用户提交的数据有关系。 思考：如果是你，前端的form表单提交了数据之后，你准备怎么存储这些数据，你准备采用什么样的数据结构去存储这些数据呢？ 前端提交的数据格式：username&#x3D;abc&amp;userpwd&#x3D;111&amp;aihao&#x3D;s&amp;aihao&#x3D;d&amp;aihao&#x3D;tt 我会采用Map集合来存储： &#96;&#96;&#96;javaMap&lt;String,String&gt;key存储Stringvalue存储String这种想法对吗？不对。如果采用以上的数据结构存储会发现key重复的时候value覆盖。key value———————username abcuserpwd 111aihao saihao daihao tt这样是不行的，因为map的key不能重复。Map&lt;String, String[]&gt;key存储Stringvalue存储String[]key value——————————-username {“abc”}userpwd {“111”}aihao {“s”,”d”,”tt”}coffeescript123456789101112 - 注意：前端表单提交数据的时候，假设提交了120这样的“数字”，其实是以字符串&quot;120&quot;的方式提交的，所以服务器端获取到的一定是一个字符串的&quot;120&quot;，而不是一个数字。（前端永远提交的是字符串，后端获取的也永远是字符串。） - 手工开发一个webapp。测试HttpServletRequest接口中的相关方法。 - 先测试了4个常用的方法，获取请求参数的四个方法。 - ```java Map&lt;String,String[]&gt; parameterMap = request.getParameterMap(); Enumeration&lt;String&gt; names = request.getParameterNames(); String[] values = request.getParameterValues(&quot;name&quot;); String value = request.getParameter(&quot;name&quot;); request对象实际上又称为“请求域”对象。 应用域对象是什么？ ServletContext （Servlet上下文对象。） 什么情况下会考虑向ServletContext这个应用域当中绑定数据呢？ 第一：所有用户共享的数据。 第二：这个共享的数据量很小。 第三：这个共享的数据很少的修改操作。 在以上三个条件都满足的情况下，使用这个应用域对象，可以大大提高我们程序执行效率。 实际上向应用域当中绑定数据，就相当于把数据放到了缓存（Cache）当中，然后用户访问的时候直接从缓存中取，减少IO的操作，大大提升系统的性能，所以缓存技术是提高系统性能的重要手段。 你见过哪些缓存技术呢？ 字符串常量池 整数型常量池 [-128~127]，但凡是在这个范围当中的Integer对象不再创建新对象，直接从这个整数型常量池中获取。大大提升系统性能。 数据库连接池（提前创建好N个连接对象，将连接对象放到集合当中，使用连接对象的时候，直接从缓存中拿。省去了连接对象的创建过程。效率提升。） 线程池（Tomcat服务器就是支持多线程的。所谓的线程池就是提前先创建好N个线程对象，将线程对象存储到集合中，然后用户请求过来之后，直接从线程池中获取线程对象，直接拿来用。提升系统性能） 后期你还会学习更多的缓存技术，例如：redis、mongoDB….. ServletContext当中有三个操作域的方法： &#96;&#96;&#96;javavoid setAttribute(String name, Object obj); &#x2F;&#x2F; 向域当中绑定数据。Object getAttribute(String name); &#x2F;&#x2F; 从域当中根据name获取数据。void removeAttribute(String name); &#x2F;&#x2F; 将域当中绑定的数据移除 &#x2F;&#x2F; 以上的操作类似于Map集合的操作。Map&lt;String, Object&gt; map;map.put(“name”, obj); &#x2F;&#x2F; 向map集合中放key和valueObject obj &#x3D; map.get(“name”); &#x2F;&#x2F; 通过map集合的key获取valuemap.remove(“name”); &#x2F;&#x2F; 通过Map集合的key删除key和value这个键值对。 arduino12345678910111213- “请求域”对象 - “请求域”对象要比“应用域”对象范围小很多。生命周期短很多。请求域只在一次请求内有效。 - 一个请求对象request对应一个请求域对象。一次请求结束之后，这个请求域就销毁了。 - 请求域对象也有这三个方法： - ```java void setAttribute(String name, Object obj); // 向域当中绑定数据。 Object getAttribute(String name); // 从域当中根据name获取数据。 void removeAttribute(String name); // 将域当中绑定的数据移除 请求域和应用域的选用原则？ 尽量使用小的域对象，因为小的域对象占用的资源较少。 跳转 转发（一次请求） &#96;&#96;&#96;java&#x2F;&#x2F; 第一步：获取请求转发器对象RequestDispatcher dispatcher &#x3D; request.getRequestDispatcher(“&#x2F;b”);&#x2F;&#x2F; 第二步：调用转发器的forward方法完成跳转&#x2F;转发dispatcher.forward(request,response); &#x2F;&#x2F; 第一步和第二步代码可以联合在一起。request.getRequestDispatcher(“&#x2F;b”).forward(request,response); awk123456789101112131415161718192021222324- 两个Servlet怎么共享数据？ - 将数据放到ServletContext应用域当中，当然是可以的，但是应用域范围太大，占用资源太多。不建议使用。 - 可以将数据放到request域当中，然后AServlet转发到BServlet，保证AServlet和BServlet在同一次请求当中，这样就可以做到两个Servlet，或者多个Servlet共享同一份数据。- 转发的下一个资源必须是一个Servlet吗？ - 不一定，只要是Tomcat服务器当中的合法资源，都是可以转发的。例如：html.... - 注意：转发的时候，路径的写法要注意，转发的路径以“/”开始，不加项目名。- 关于request对象中两个非常容易混淆的方法： - ```java // uri?username=zhangsan&amp;userpwd=123&amp;sex=1 String username = request.getParameter(&quot;username&quot;); // 之前一定是执行过：request.setAttribute(&quot;name&quot;, new Object()) Object obj = request.getAttribute(&quot;name&quot;); // 以上两个方法的区别是什么？ // 第一个方法：获取的是用户在浏览器上提交的数据。 // 第二个方法：获取的是请求域当中绑定的数据。 HttpServletRequest接口的其他常用方法： &#96;&#96;&#96;java&#x2F;&#x2F; 获取客户端的IP地址String remoteAddr &#x3D; request.getRemoteAddr(); &#x2F;&#x2F; get请求在请求行上提交数据。&#x2F;&#x2F; post请求在请求体中提交数据。&#x2F;&#x2F; 设置请求体的字符集。（显然这个方法是处理POST请求的乱码问题。这种方式并不能解决get请求的乱码问题。）&#x2F;&#x2F; Tomcat10之后，request请求体当中的字符集默认就是UTF-8，不需要设置字符集，不会出现乱码问题。&#x2F;&#x2F; Tomcat9前（包括9在内），如果前端请求体提交的是中文，后端获取之后出现乱码，怎么解决这个乱码？执行以下代码。request.setCharacterEncoding(“UTF-8”); &#x2F;&#x2F; 在Tomcat9之前（包括9），响应中文也是有乱码的，怎么解决这个响应的乱码？response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”);&#x2F;&#x2F; 在Tomcat10之后，包括10在内，响应中文的时候就不在出现乱码问题了。以上代码就不需要设置UTF-8了。 &#x2F;&#x2F; 注意一个细节&#x2F;&#x2F; 在Tomcat10包括10在内之后的版本，中文将不再出现乱码。（这也体现了中文地位的提升。） &#x2F;&#x2F; get请求乱码问题怎么解决？&#x2F;&#x2F; get请求发送的时候，数据是在请求行上提交的，不是在请求体当中提交的。&#x2F;&#x2F; get请求乱码怎么解决&#x2F;&#x2F; 方案：修改CATALINA_HOME&#x2F;conf&#x2F;server.xml配置文件 // 注意：从Tomcat8之后，URIEncoding的默认值就是UTF-8，所以GET请求也没有乱码问题了。 &#x2F;&#x2F; 获取应用的根路径String contextPath &#x3D; request.getContextPath(); &#x2F;&#x2F; 获取请求方式String method &#x3D; request.getMethod(); &#x2F;&#x2F; 获取请求的URIString uri &#x3D; request.getRequestURI(); &#x2F;&#x2F; &#x2F;aaa&#x2F;testRequest &#x2F;&#x2F; 获取servlet pathString servletPath &#x3D; request.getServletPath(); &#x2F;&#x2F; &#x2F;testRequest sql1234567891011121314151617181920212223## 使用纯Servlet做一个单表的CRUD操作- 使用纯粹的Servlet完成单表【对部门的】的增删改查操作。（B/S结构的。）- 实现步骤 - 第一步：准备一张数据库表。（sql脚本） - ```sql # 部门表 drop table if exists dept; create table dept( deptno int primary key, dname varchar(255), loc varchar(255) ); insert into dept(deptno, dname, loc) values(10, &#x27;XiaoShouBu&#x27;, &#x27;BEIJING&#x27;); insert into dept(deptno, dname, loc) values(20, &#x27;YanFaBu&#x27;, &#x27;SHANGHAI&#x27;); insert into dept(deptno, dname, loc) values(30, &#x27;JiShuBu&#x27;, &#x27;GUANGZHOU&#x27;); insert into dept(deptno, dname, loc) values(40, &#x27;MeiTiBu&#x27;, &#x27;SHENZHEN&#x27;); commit; select * from dept; 第二步：准备一套HTML页面（项目原型）【前端开发工具使用HBuilder】 把HTML页面准备好 然后将HTML页面中的链接都能够跑通。（页面流转没问题。） 应该设计哪些页面呢？ 欢迎页面：index.html 列表页面：list.html（以列表页面为核心，展开其他操作。） 新增页面：add.html 修改页面：edit.html 详情页面：detail.html 第三步：分析我们这个系统包括哪些功能？ 什么叫做一个功能呢？ 只要 这个操作连接了数据库，就表示一个独立的功能。 包括哪些功能？ 查看部门列表 新增部门 删除部门 查看部门详细信息 跳转到修改页面 修改部门 第四步：在IDEA当中搭建开发环境 创建一个webapp（给这个webapp添加servlet-api.jar和jsp-api.jar到classpath当中。） 向webapp中添加连接数据库的jar包（mysql驱动） 必须在WEB-INF目录下新建lib目录，然后将mysql的驱动jar包拷贝到这个lib目录下。这个目录名必须叫做lib，全部小写的。 JDBC的工具类 将所有HTML页面拷贝到web目录下。 第五步：实现第一个功能：查看部门列表 我们应该怎么去实现一个功能呢？ 建议：你可以从后端往前端一步一步写。也可以从前端一步一步往后端写。都可以。但是千万要记住不要想起来什么写什么。你写代码的过程最好是程序的执行过程。也就是说：程序执行到哪里，你就写哪里。这样一个顺序流下来之后，基本上不会出现什么错误、意外。 从哪里开始？ 假设从前端开始，那么一定是从用户点击按钮那里开始的。 第一：先修改前端页面的超链接，因为用户先点击的就是这个超链接。 &#96;&#96;&#96;html查看部门列表xml12345678910111213- 第二：编写web.xml文件 - ```xml &lt;servlet&gt; &lt;servlet-name&gt;list&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.oa.web.action.DeptListServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;list&lt;/servlet-name&gt; &lt;!--web.xml文件中的这个路径也是以“/”开始的，但是不需要加项目名--&gt; &lt;url-pattern&gt;/dept/list&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 第三：编写DeptListServlet类继承HttpServlet类。然后重写doGet方法。 &#96;&#96;&#96;javapackage com.bjpowernode.oa.web.action; import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; public class DeptListServlet extends HttpServlet {@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {}} routeros1234567891011121314151617181920212223242526- 第四：在DeptListServlet类的doGet方法中连接数据库，查询所有的部门，动态的展示部门列表页面. - 分析list.html页面中哪部分是固定死的，哪部分是需要动态展示的。 - list.html页面中的内容所有的双引号要替换成单引号，因为out.print(&quot;&quot;)这里有一个双引号，容易冲突。 - 现在写完这个功能之后，你会有一种感觉，感觉开发很繁琐，只使用servlet写代码太繁琐了。 - ```java while(rs.next())&#123; String deptno = rs.getString(&quot;a&quot;); String dname = rs.getString(&quot;dname&quot;); String loc = rs.getString(&quot;loc&quot;); out.print(&quot; &lt;tr&gt;&quot;); out.print(&quot; &lt;td&gt;&quot;+(++i)+&quot;&lt;/td&gt;&quot;); out.print(&quot; &lt;td&gt;&quot;+deptno+&quot;&lt;/td&gt;&quot;); out.print(&quot; &lt;td&gt;&quot;+dname+&quot;&lt;/td&gt;&quot;); out.print(&quot; &lt;td&gt;&quot;); out.print(&quot; &lt;a href=&#x27;&#x27;&gt;删除&lt;/a&gt;&quot;); out.print(&quot; &lt;a href=&#x27;edit.html&#x27;&gt;修改&lt;/a&gt;&quot;); out.print(&quot; &lt;a href=&#x27;detail.html&#x27;&gt;详情&lt;/a&gt;&quot;); out.print(&quot; &lt;/td&gt;&quot;); out.print(&quot; &lt;/tr&gt;&quot;); &#125; 第六步：查看部门详情。 建议：从前端往后端一步一步实现。首先要考虑的是，用户点击的是什么？用户点击的东西在哪里？ 一定要先找到用户点的“详情”在哪里。找了半天，终于在后端的java程序中找到了 &lt;a href=&#39;写一个路径&#39;&gt;详情&lt;/a&gt; autohotkey123456789 - 详情 是需要连接数据库的，所以这个超链接点击之后也是需要执行一段java代码的。所以要将这个超链接的路径修改一下。 - 注意：修改路径之后，这个路径是需要加项目名的。&quot;/oa/dept/detail&quot;- 技巧： - ```java out.print(&quot;&lt;a href=&#x27;&quot;+contextPath+&quot;/dept/detail?deptno=&quot;+deptno+&quot;&#x27;&gt;详情&lt;/a&gt;&quot;); 重点：向服务器提交数据的格式：uri?name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value 这里的问号，必须是英文的问号。不能中文的问号。 解决404的问题。写web.xml文件。 &#96;&#96;&#96;xml detail com.bjpowernode.oa.web.action.DeptDetailServlet detail /dept/detail scala1234567891011121314151617181920212223- 编写一个类：DeptDetailServlet继承HttpServlet，重写doGet方法。 - ```java package com.bjpowernode.oa.web.action; import jakarta.servlet.ServletException; import jakarta.servlet.http.HttpServlet; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; public class DeptDetailServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //中文思路（思路来源于：你要做什么？目标：查看部门详细信息。） // 第一步：获取部门编号 // 第二步：根据部门编号查询数据库，获取该部门编号对应的部门信息。 // 第三步：将部门信息响应到浏览器上。（显示一个详情。） &#125; &#125; 在doGet方法当中：连接数据库，根据部门编号查询该部门的信息。动态展示部门详情页。 第七步：删除部门 怎么开始？从哪里开始？从前端页面开始，用户点击删除按钮的时候，应该提示用户是否删除。因为删除这个动作是比较危险的。任何系统在进行删除操作之前，是必须要提示用户的，因为这个删除的动作有可能是用户误操作。（在前端页面上写JS代码，来提示用户是否删除。） &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;del(30)&quot; &gt;删除&lt;/a&gt; &lt;script type=&quot;text/javascript&quot;&gt; function del(dno)&#123; if(window.confirm(&quot;亲，删了不可恢复哦！&quot;))&#123; document.location.href = &quot;/oa/dept/delete?deptno=&quot; + dno; &#125; &#125; &lt;/script&gt; pgsql1234567891011121314151617181920 - 以上的前端程序要写到后端的java代码当中： - DeptListServlet类的doGet方法当中，使用out.print()方法，将以上的前端代码输出到浏览器上。 - 解决404的问题： - http://localhost:8080/oa/dept/delete?deptno=30 - web.xml文件 - ```xml &lt;servlet&gt; &lt;servlet-name&gt;delete&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.oa.web.action.DeptDelServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;delete&lt;/servlet-name&gt; &lt;url-pattern&gt;/dept/delete&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 编写DeptDelServlet继承HttpServlet，重写doGet方法。 &#96;&#96;&#96;javapackage com.bjpowernode.oa.web.action; import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; public class DeptDelServlet extends HttpServlet {@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 根据部门编号，删除部门。}} awk1234567891011121314 - 删除成功或者失败的时候的一个处理（这里我们选择了转发，并没有使用重定向机制。） - ```java // 判断删除成功了还是失败了。 if (count == 1) &#123; //删除成功 //仍然跳转到部门列表页面 //部门列表页面的显示需要执行另一个Servlet。怎么办？转发。 request.getRequestDispatcher(&quot;/dept/list&quot;).forward(request, response); &#125;else&#123; // 删除失败 request.getRequestDispatcher(&quot;/error.html&quot;).forward(request, response); &#125; 第八步：新增部门 注意：最后保存成功之后，转发到 &#x2F;dept&#x2F;list 的时候，会出现405，为什么？ 第一：保存用的是post请求。底层要执行doPost方法。 第二：转发是一次请求，之前是post，之后还是post，因为它是一次请求。 第三：&#x2F;dept&#x2F;list Servlet当中只有一个doGet方法。 怎么解决？两种方案 第一种：在&#x2F;dept&#x2F;list Servlet中添加doPost方法，然后在doPost方法中调用doGet。 第二种：重定向。 第九步：跳转到修改部门的页面 第十步：修改部门 在一个web应用中应该如何完成资源的跳转 在一个web应用中通过两种方式，可以完成资源的跳转： 第一种方式：转发 第二种方式：重定向 转发和重定向有什么区别？ 代码上有什么区别？ 转发 &#96;&#96;&#96;java&#x2F;&#x2F; 获取请求转发器对象RequestDispatcher dispatcher &#x3D; request.getRequestDispatcher(“&#x2F;dept&#x2F;list”);&#x2F;&#x2F; 调用请求转发器对象的forward方法完成转发dispatcher.forward(request, response); &#x2F;&#x2F; 合并一行代码request.getRequestDispatcher(“&#x2F;dept&#x2F;list”).forward(request, response);&#x2F;&#x2F; 转发的时候是一次请求，不管你转发了多少次。都是一次请求。&#x2F;&#x2F; AServlet转发到BServlet，再转发到CServlet，再转发到DServlet，不管转发了多少次，都在同一个request当中。&#x2F;&#x2F; 这是因为调用forward方法的时候，会将当前的request和response对象传递给下一个Servlet。 awk123456789- 重定向 - ```java // 注意：路径上要加一个项目名。为什么？ // 浏览器发送请求，请求路径上是需要添加项目名的。 // 以下这一行代码会将请求路径“/oa/dept/list”发送给浏览器 // 浏览器会自发的向服务器发送一次全新的请求：/oa/dept/list response.sendRedirect(&quot;/oa/dept/list&quot;); 形式上有什么区别？ 转发（一次请求） 在浏览器地址栏上发送的请求是：http://localhost:8080/servlet10/a ，最终请求结束之后，浏览器地址栏上的地址还是这个。没变。 重定向（两次请求） 在浏览器地址栏上发送的请求是：http://localhost:8080/servlet10/a ，最终在浏览器地址栏上显示的地址是：http://localhost:8080/servlet10/b 转发和重定向的本质区别？ 转发：是由WEB服务器来控制的。A资源跳转到B资源，这个跳转动作是Tomcat服务器内部完成的。 重定向：是浏览器完成的。具体跳转到哪个资源，是浏览器说了算。 使用一个例子去描述这个转发和重定向 借钱（转发：发送了一次请求） 杜老师没钱了，找张三借钱，其实张三没有钱，但是张三够义气，张三自己找李四借了钱，然后张三把这个钱给了杜老师，杜老师不知道这个钱是李四的，杜老师只求了一个人。杜老师以为这个钱就是张三的。 借钱（重定向：发送了两次请求） 杜老师没钱了，找张三借钱，张三没有钱，张三有一个好哥们，叫李四，李四是个富二代，于是张三将李四的家庭住址告诉了杜老师，杜老师按照这个地址去找到李四，然后从李四那里借了钱。显然杜老师在这个过程中，求了两个人。并且杜老师知道最终这个钱是李四借给俺的。 转发和重定向应该如何选择？什么时候使用转发，什么时候使用重定向？ 如果在上一个Servlet当中向request域当中绑定了数据，希望从下一个Servlet当中把request域里面的数据取出来，使用转发机制。 剩下所有的请求均使用重定向。（重定向使用较多。） 跳转的下一个资源有没有要求呢？必须是一个Servlet吗？ 不一定，跳转的资源只要是服务器内部合法的资源即可。包括：Servlet、JSP、HTML….. 转发会存在浏览器的刷新问题。 将oa项目中的资源跳转修改为合适的跳转方式 删除之后，重定向 修改之后，重定向 保存之后，重定向 重定向： 成功 失败 Servlet注解，简化配置 分析oa项目中的web.xml文件 现在只是一个单标的CRUD，没有复杂的业务逻辑，很简单的一丢丢功能。web.xml文件中就有如此多的配置信息。如果采用这种方式，对于一个大的项目来说，这样的话web.xml文件会非常庞大，有可能最终会达到几十兆。 在web.xml文件中进行servlet信息的配置，显然开发效率比较低，每一个都需要配置一下。 而且在web.xml文件中的配置是很少被修改的，所以这种配置信息能不能直接写到java类当中呢？可以的。 Servlet3.0版本之后，推出了各种Servlet基于注解式开发。优点是什么？ 开发效率高，不需要编写大量的配置信息。直接在java类上使用注解进行标注。 web.xml文件体积变小了。 并不是说注解有了之后，web.xml文件就不需要了： 有一些需要变化的信息，还是要配置到web.xml文件中。一般都是 注解+配置文件 的开发模式。 一些不会经常变化修改的配置建议使用注解。一些可能会被修改的建议写到配置文件中。 我们的第一个注解： &#96;&#96;&#96;jakarta.servlet.annotation.WebServletmarkdown123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113 - 在Servlet类上使用：@WebServlet，WebServlet注解中有哪些属性呢？ - name属性：用来指定Servlet的名字。等同于：&lt;servlet-name&gt; - urlPatterns属性：用来指定Servlet的映射路径。可以指定多个字符串。&lt;url-pattern&gt; - loadOnStartUp属性：用来指定在服务器启动阶段是否加载该Servlet。等同于：&lt;load-on-startup&gt; - value属性：当注解的属性名是value的时候，使用注解的时候，value属性名是可以省略的。 - 注意：不是必须将所有属性都写上，只需要提供需要的。（需要什么用什么。） - 注意：属性是一个数组，如果数组中只有一个元素，使用该注解的时候，属性值的大括号可以省略。- 注解对象的使用格式： - @注解名称(属性名=属性值, 属性名=属性值, 属性名=属性值....)## 使用模板方法设计模式优化oa项目- 上面的注解解决了配置文件的问题。但是现在的oa项目仍然存在一个比较臃肿的问题。 - 一个单标的CRUD，就写了6个Servlet。如果一个复杂的业务系统，这种开发方式，显然会导致类爆炸。（类的数量太大。） - 怎么解决这个类爆炸问题？可以使用模板方法设计模式。- 怎么解决类爆炸问题？ - 以前的设计是一个请求一个Servlet类。1000个请求对应1000个Servlet类。导致类爆炸。 - 可以这样做：一个请求对应一个方法。一个业务对应一个Servlet类。 - 处理部门相关业务的对应一个DeptServlet。处理用户相关业务的对应一个UserServlet。处理银行卡卡片业务对应一个CardServlet。## 分析使用纯粹Servlet开发web应用的缺陷- 在Servlet当中编写HTML/CSS/JavaScript等前端代码。存在什么问题？ - java程序中编写前端代码，编写难度大。麻烦。 - java程序中编写前端代码，显然程序的耦合度非常高。 - java程序中编写前端代码，代码非常不美观。 - java程序中编写前端代码，维护成本太高。（非常难于维护） - 修改小小的一个前端代码，只要有改动，就需要重新编译java代码，生成新的class文件，打一个新的war包，重新发布。- 思考一下，如果是你的话，你准备怎么解决这个问题？ - 思路很重要。使用什么样的思路去做、去解决这个问题 - 上面的那个Servlet（Java程序）能不能不写了，让机器自动生成。我们程序员只需要写这个Servlet程序中的“前端的那段代码”，然后让机器将我们写的“前端代码”自动翻译生成“Servlet这种java程序”。然后机器再自动将“java”程序编译生成&quot;class&quot;文件。然后再使用JVM调用这个class中的方法。## 关于B/S结构系统的会话机制（session机制）- 什么是会话？ - 会话对应的英语单词：session - 用户打开浏览器，进行一系列操作，然后最终将浏览器关闭，这个整个过程叫做：一次会话。会话在服务器端也有一个对应的java对象，这个java对象叫做：session。 - 什么是一次请求：用户在浏览器上点击了一下，然后到页面停下来，可以粗略认为是一次请求。请求对应的服务器端的java对象是：request。 - 一个会话当中包含多次请求。（一次会话对应N次请求。） - 在java的servlet规范当中，session对应的类名：HttpSession（jarkata.servlet.http.HttpSession）- session机制属于B/S结构的一部分。如果使用php语言开发WEB项目，同样也是有session这种机制的。session机制实际上是一个规范。然后不同的语言对这种会话机制都有实现。- session对象最主要的作用是：保存会话状态。（用户登录成功了，这是一种登录成功的状态，你怎么把登录成功的状态一直保存下来呢？使用session对象可以保留会话状态。）- 为什么需要session对象来保存会话状态呢？ - 因为HTTP协议是一种无状态协议。 - 什么是无状态：请求的时候，B和S是连接的，但是请求结束之后，连接就断了。为什么要这么做？HTTP协议为什么要设计成这样？因为这样的无状态协议，可以降低服务器的压力。请求的瞬间是连接的，请求结束之后，连接断开，这样服务器压力小。 - 只要B和S断开了，那么关闭浏览器这个动作，服务器知道吗？ - 不知道。服务器是不知道浏览器关闭的。 - 张三打开一个浏览器A，李四打开一个浏览器B，访问服务器之后，在服务器端会生成： - 张三专属的session对象 - 李四专属的session对象 - 为什么不使用request对象保存会话状态？为什么不使用ServletContext对象保存会话状态？ - request.setAttribute()存，request.getAttribute()取，ServletContext也有这个方法。request是请求域。ServletContext是应用域。 - request是一次请求一个对象。 - ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，这个ServletContext对象只有一个。 - ServletContext对象的域太大。 - request请求域（HttpServletRequest）、session会话域（HttpSession）、application域（ServletContext） - request &lt; session &lt; application - 思考一下：session对象的实现原理。 - HttpSession session = request.getSession(); - 这行代码很神奇。张三访问的时候获取的session对象就是张三的。李四访问的时候获取的session对象就是李四的。 - session的实现原理： - JSESSIONID=xxxxxx 这个是以Cookie的形式保存在浏览器的内存中的。浏览器只要关闭。这个cookie就没有了。 - session列表是一个Map，map的key是sessionid，map的value是session对象。 - 用户第一次请求，服务器生成session对象，同时生成id，将id发送给浏览器。 - 用户第二次请求，自动将浏览器内存中的id发送给服务器，服务器根据id查找session对象。 - 关闭浏览器，内存消失，cookie消失，sessionid消失，会话等同于结束。- Cookie禁用了，session还能找到吗？ - cookie禁用是什么意思？服务器正常发送cookie给浏览器，但是浏览器不要了。拒收了。并不是服务器不发了。 - 找不到了。每一次请求都会获取到新的session对象。 - cookie禁用了，session机制还能实现吗？ - 可以。需要使用URL重写机制。 - http://localhost:8080/servlet12/test/session;jsessionid=19D1C99560DCBF84839FA43D58F56E16 - URL重写机制会提高开发者的成本。开发人员在编写任何请求路径的时候，后面都要添加一个sessionid，给开发带来了很大的难度，很大的成本。所以大部分的网站都是这样设计的：你要是禁用cookie，你就别用了。- 总结一下到目前位置我们所了解的域对象： - request（对应的类名：HttpServletRequest） - 请求域（请求级别的） - session（对应的类名：HttpSession） - 会话域（用户级别的） - application（对应的类名：ServletContext） - 应用域（项目级别的，所有用户共享的。） - 这三个域对象的大小关系 - request &lt; session &lt; application - 他们三个域对象都有以下三个公共的方法： - setAttribute（向域当中绑定数据） - getAttribute（从域当中获取数据） - removeAttribute（删除域当中的数据） - 使用原则：尽量使用小的域。- session掌握之后，我们怎么解决oa项目中的登录问题，怎么能让登录起作用。 - 登录成功之后，可以将用户的登录信息存储到session当中。也就是说session中如果有用户的信息就代表用户登录成功了。session中没有用户信息，表示用户没有登录过。则跳转到登录页面。- 销毁session对象： - ```java session.invalidate(); Cookie session的实现原理中，每一个session对象都会关联一个sessionid，例如： JSESSIONID&#x3D;41C481F0224664BDB28E95081D23D5B8 以上的这个键值对数据其实就是cookie对象。 对于session关联的cookie来说，这个cookie是被保存在浏览器的“运行内存”当中。 只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存中的cookie发送给服务器。 例如，这个Cookie: JSESSIONID&#x3D;41C481F0224664BDB28E95081D23D5B8就会再次发送给服务器。 服务器就是根据41C481F0224664BDB28E95081D23D5B8这个值来找到对应的session对象的。 cookie怎么生成？cookie保存在什么地方？cookie有啥用？浏览器什么时候会发送cookie，发送哪些cookie给服务器？？？？？？？ cookie最终是保存在浏览器客户端上的。 可以保存在运行内存中。（浏览器只要关闭cookie就消失了。） 也可以保存在硬盘文件中。（永久保存。） cookie有啥用呢？ cookie和session机制其实都是为了保存会话的状态。 cookie是将会话的状态保存在浏览器客户端上。（cookie数据存储在浏览器客户端上的。） session是将会话的状态保存在服务器端上。（session对象是存储在服务器上。） 为什么要有cookie和session机制呢？因为HTTP协议是无状态 无连接协议。 cookie的经典案例 京东商城，在未登录的情况下，向购物车中放几件商品。然后关闭商城，再次打开浏览器，访问京东商城的时候，购物车中的商品还在，这是怎么做的？我没有登录，为什么购物车中还有商品呢？ 将购物车中的商品编号放到cookie当中，cookie保存在硬盘文件当中。这样即使关闭浏览器。硬盘上的cookie还在。下一次再打开京东商城的时候，查看购物车的时候，会自动读取本地硬盘中存储的cookie，拿到商品编号，动态展示购物车中的商品。 京东存储购物车中商品的cookie可能是这样的：productIds&#x3D;xxxxx,yyyy,zzz,kkkk 注意：cookie如果清除掉，购物车中的商品就消失了。 126邮箱中有一个功能：十天内免登录 这个功能也是需要cookie来实现的。 怎么实现的呢？ 用户输入正确的用户名和密码，并且同时选择十天内免登录。登录成功后。浏览器客户端会保存一个cookie，这个cookie中保存了用户名和密码等信息，这个cookie是保存在硬盘文件当中的，十天有效。在十天内用户再次访问126的时候，浏览器自动提交126的关联的cookie给服务器，服务器接收到cookie之后，获取用户名和密码，验证，通过之后，自动登录成功。 怎么让cookie失效？ 十天过后自动失效。 或者改密码。 或者在客户端浏览器上清除cookie。 cookie机制和session机制其实都不属于java中的机制，实际上cookie机制和session机制都是HTTP协议的一部分。php开发中也有cookie和session机制，只要是你是做web开发，不管是什么编程语言，cookie和session机制都是需要的。 HTTP协议中规定：任何一个cookie都是由name和value组成的。name和value都是字符串类型的。 在java的servlet中，对cookie提供了哪些支持呢？ 提供了一个Cookie类来专门表示cookie数据。jakarta.servlet.http.Cookie; java程序怎么把cookie数据发送给浏览器呢？response.addCookie(cookie); 在HTTP协议中是这样规定的：当浏览器发送请求的时候，会自动携带该path下的cookie数据给服务器。（URL。） 关于cookie的有效时间 怎么用java设置cookie的有效时间 cookie.setMaxAge(60 * 60); 设置cookie在一小时之后失效。 没有设置有效时间：默认保存在浏览器的运行内存中，浏览器关闭则cookie消失。 只要设置cookie的有效时间 &gt; 0，这个cookie一定会存储到硬盘文件当中。 设置cookie的有效时间 &#x3D; 0 呢？ cookie被删除，同名cookie被删除。 设置cookie的有效时间 &lt; 0 呢？ 保存在运行内存中。和不设置一样。 关于cookie的path，cookie关联的路径： 假设现在发送的请求路径是“http://localhost:8080/servlet13/cookie/generate”生成的cookie，如果cookie没有设置path，默认的path是什么？ 默认的path是：http://localhost:8080/servlet13/cookie 以及它的子路径。 也就是说，以后只要浏览器的请求路径是http://localhost:8080/servlet13/cookie 这个路径以及这个路径下的子路径，cookie都会被发送到服务器。 手动设置cookie的path cookie.setPath(“&#x2F;servlet13”); 表示只要是这个servlet13项目的请求路径，都会提交这个cookie给服务器。 浏览器发送cookie给服务器了，服务器中的java程序怎么接收？ &#96;&#96;&#96;javaCookie[] cookies &#x3D; request.getCookies(); &#x2F;&#x2F; 这个方法可能返回nullif(cookies !&#x3D; null){for(Cookie cookie : cookies){ &#x2F;&#x2F; 获取cookie的name String name &#x3D; cookie.getName(); &#x2F;&#x2F; 获取cookie的value String value &#x3D; cookie.getValue();}} nestedtext123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145- 使用cookie实现一下十天内免登录功能。 - 先实现登录功能 - 登录成功 - 跳转到部门列表页面 - 登录失败 - 跳转到登录失败页面 - 修改前端页面 - 在登录页面给一个复选框，复选框后面给一句话：十天内免登录。 - 用户选择了复选框：表示要支持十天内免登录。 - 用户没有选择复选框：表示用户不想使用十天内免登录功能。 - 修改Servlet中的login方法 - 如果用户登录成功了，并且用户登录时选择了十天内免登录功能，这个时候应该在Servlet的login方法中创建cookie，用来存储用户名和密码，并且设置路径，设置有效期，将cookie响应给浏览器。（浏览器将其自动保存在硬盘文件当中10天） - 用户再次访问该网站的时候，访问这个网站的首页的时候，有两个走向: - 要么跳转到部门列表页面 - 要么跳转到登录页面 - 以上分别有两个走向，这显然是需要编写java程序进行控制的。# JSP- 我的第一个JSP程序： - 在WEB-INF目录之外创建一个index.jsp文件，然后这个文件中没有任何内容。 - 将上面的项目部署之后，启动服务器，打开浏览器，访问以下地址： - http://localhost:8080/jsp/index.jsp 展现在大家面前的是一个空白。 - 实际上访问以上的这个：index.jsp，底层执行的是：index_jsp.class 这个java程序。 - 这个index.jsp会被tomcat翻译生成index_jsp.java文件，然后tomcat服务器又会将index_jsp.java编译生成index_jsp.class文件 - 访问index.jsp，实际上执行的是index_jsp.class中的方法。 - JSP实际上就是一个Servlet。 - index.jsp访问的时候，会自动翻译生成index_jsp.java，会自动编译生成index_jsp.class，那么index_jsp 这就是一个类。 - index_jsp 类继承 HttpJspBase，而HttpJspBase类继承的是HttpServlet。所以index_jsp类就是一个Servlet类。 - jsp的生命周期和Servlet的生命周期完全相同。完全就是一个东西。没有任何区别。 - jsp和servlet一样，都是单例的。（假单例。） - jsp文件第一次访问的时候是比较慢的，为什么？ - 为什么大部分的运维人员在给客户演示项目的时候，为什么提前先把所有的jsp文件先访问一遍。 - 第一次比较麻烦： - 要把jsp文件翻译生成java源文件 - java源文件要编译生成class字节码文件 - 然后通过class去创建servlet对象 - 然后调用servlet对象的init方法 - 最后调用servlet对象的service方法。 - 第二次就比较快了，为什么？ - 因为第二次直接调用单例servlet对象的service方法即可。 - JSP是什么？ - JSP是java程序。（JSP本质还是一个Servlet） - JSP是：JavaServer Pages的缩写。（基于Java语言实现的服务器端的页面。） - Servlet是JavaEE的13个子规范之一，那么JSP也是JavaEE的13个子规范之一。 - JSP是一套规范。所有的web容器/web服务器都是遵循这套规范的，都是按照这套规范进行的“翻译” - 每一个web容器/web服务器都会内置一个JSP翻译引擎。 - 对JSP进行错误调试的时候，还是要直接打开JSP文件对应的java文件，检查java代码。- 开发JSP的最高境界： - 眼前是JSP代码，但是脑袋中呈现的是java代码。 - JSP既然本质上是一个Servlet，那么JSP和Servlet到底有什么区别呢？ - 职责不同： - Servlet的职责是什么：收集数据。（Servlet的强项是逻辑处理，业务处理，然后链接数据库，获取/收集数据。） - JSP的职责是什么：展示数据。（JSP的强项是做数据的展示） - JSP的基础语法 - 在jsp文件中直接编写文字，都会自动被翻译到哪里？ - 翻译到servlet类的service方法的out.write(&quot;翻译到这里&quot;)，直接翻译到双引号里，被java程序当做普通字符串打印输出到浏览器。 - 在JSP中编写的HTML CSS JS代码，这些代码对于JSP来说只是一个普通的字符串。但是JSP把这个普通的字符串一旦输出到浏览器，浏览器就会对HTML CSS JS进行解释执行。展现一个效果。 - JSP的page指令（这个指令后面再详细说，这里先解决一下中文乱码问题），解决响应时的中文乱码问题： - 通过page指令来设置响应的内容类型，在内容类型的最后面添加：charset=UTF-8 - &lt;%@page contentType=&quot;text/html;charset=UTF-8&quot;%&gt;，表示响应的内容类型是text/html，采用的字符集UTF-8 - &lt;%@page import=&quot;java.util.List,java.util.ArrayList&quot;%&gt; - 怎么在JSP中编写Java程序： - &lt;% java语句; %&gt; - 在这个符号当中编写的被视为java程序，被翻译到Servlet类的service方法内部。 - 这里你要细心点，你要思考，在&lt;% %&gt;这个符号里面写java代码的时候，你要时时刻刻的记住你正在“方法体”当中写代码，方法体中可以写什么，不可以写什么，你心里是否明白呢？ - 在service方法当中编写的代码是有顺序的，方法体当中的代码要遵循自上而下的顺序依次逐行执行。 - service方法当中不能写静态代码块，不能写方法，不能定义成员变量。。。。。。 - 在同一个JSP当中 &lt;%%&gt; 这个符号可以出现多个。 - &lt;%! %&gt; - 在这个符号当中编写的java程序会自动翻译到service方法之外。 - 这个语法很少用，为什么？不建议使用，因为在service方法外面写静态变量和实例变量，都会存在线程安全问题，因为JSP就是servlet，servlet是单例的，多线程并发的环境下，这个静态变量和实例变量一旦有修改操作，必然会存在线程安全问题。 - JSP的输出语句 - 怎么向浏览器上输出一个java变量。 - &lt;% String name = “jack”; out.write(&quot;name = &quot; + name); %&gt; - 注意：以上代码中的out是JSP的九大内置对象之一。可以直接拿来用。当然，必须只能在service方法内部使用。 - 如果向浏览器上输出的内容中没有“java代码”，例如输出的字符串是一个固定的字符串，可以直接在jsp中编写，不需要写到&lt;%%&gt; 这里。 - 如果输出的内容中含有“java代码”，这个时候可以使用以下语法格式： - &lt;%= %&gt; 注意：在=的后面编写要输出的内容。 - &lt;%= %&gt; 这个符号会被翻译到哪里？最终翻译成什么？ - 翻译成了这个java代码： out.print(); - 翻译到service方法当中了。 - 什么时候使用&lt;%=%&gt; 输出呢？输出的内容中含有java的变量，输出的内容是一个动态的内容，不是一个死的字符串。如果输出的是一个固定的字符串，直接在JSP文件中编写即可。 - 在JSP中如何编写JSP的专业注释 - &lt;%--JSP的专业注释，不会被翻译到java源代码当中。--%&gt; - &lt;!--这种注释属于HTML的注释，这个注释信息仍然会被翻译到java源代码当中，不建议。--&gt; - JSP基础语法总结： - JSP中直接编写普通字符串 - 翻译到service方法的out.write(&quot;这里&quot;) - &lt;%%&gt; - 翻译到service方法体内部，里面是一条一条的java语句。 - &lt;%! %&gt; - 翻译到service方法之外。 - &lt;%= %&gt; - 翻译到service方法体内部，翻译为：out.print(); - &lt;%@page contentType=&quot;text/html;charset=UTF-8&quot;%&gt; - page指令，通过contentType属性用来设置响应的内容类型。 - 使用Servlet + JSP完成oa项目的改造。 - 使用Servlet处理业务，收集数据。 使用JSP展示数据。 - 将之前原型中的html文件，全部修改为jsp，然后在jsp文件头部添加page指令（指定contentType防止中文乱码），将所有的JSP直接拷贝到web目录下。 - 完成所有页面的正常流转。（页面仍然能够正常的跳转。修改超链接的请求路径。） - &lt;%=request.getContextPath() %&gt; 在JSP中动态的获取应用的根路径。 - Servlet中连接数据库，查询所有的部门，遍历结果集。 - 遍历结果集的过程中，取出部门编号、部门名、位置等信息，封装成java对象。 - 将java对象存放到List集合中。 - 将List集合存储到request域当中。 - 转发forward到jsp。 - 在JSP中： - 从request域当中取出List集合。 - 遍历List集合，取出每个部门对象。动态生成tr。 - 思考一个问题：如果我只用JSP这一个技术，能不能开发web应用？ - 当然可以使用JSP来完成所有的功能。因为JSP就是Servlet，在JSP的&lt;%%&gt;里面写的代码就是在service方法当中的，所以在&lt;%%&gt;当中完全可以编写JDBC代码，连接数据库，查询数据，也可以在这个方法当中编写业务逻辑代码，处理业务，都是可以的，所以使用单独的JSP开发web应用完全没问题。 - 虽然JSP一个技术就可以完成web应用，但是不建议，还是建议采用servlet + jsp的方式进行开发。这样都能将各自的优点发挥出来。JSP就是做数据展示。Servlet就是做数据的收集。（JSP中编写的Java代码越少越好。）一定要职责分明。 - JSP文件的扩展名必须是xxx.jsp吗？ - jsp文件的扩展名是可以配置的。不是固定的。 - 在CATALINA_HOME/conf/web.xml，在这个文件当中配置jsp文件的扩展名。 - ```xml &lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; xxx.jsp文件对于小猫咪来说，只是一个普通的文本文件，web容器会将xxx.jsp文件最终生成java程序，最终调用的是java对象相关的方法，真正执行的时候，和jsp文件就没有关系了。 小窍门：JSP如果看不懂，建议把jsp翻译成java代码，就能看懂了。 同学问：包名bean是什么意思？ javabean（java的logo是一杯冒着热气的咖啡。javabean被翻译为：咖啡豆） java是一杯咖啡，咖啡又是由一粒一粒的咖啡豆研磨而成。 整个java程序中有很多bean的存在。由很多bean组成。 什么是javabean？实际上javabean你可以理解为符合某种规范的java类，比如： 有无参数构造方法 属性私有化 对外提供公开的set和get方法 实现java.io.Serializable接口 重写toString 重写hashCode+equals …. javabean其实就是java中的实体类。负责数据的封装。 由于javabean符合javabean规范，具有更强的通用性。 完成剩下所有功能的改造。 当前的oa应用存在的问题： 任何一个用户都可以访问这个系统，都可以对这个系统当中的数据进行增删改这些危险的操作。我只想让合法的用户去使用这个系统，不合法的用户不能访问这个系统，怎么办？ 加一个登录功能。登录成功的可以访问该系统，登录失败不能访问。 实现登录功能： 步骤1：数据库当中添加一个用户表：t_user t_user表当中存储的是用户的登录信息，最基本的也包括：登录的用户名和登录的密码。 密码一般在数据库表当中存储的是密文。一般不以明文的形式存储。（这里先使用明文方式。） 向t_user表中插入数据。 步骤2：再实现一个登录页面。 登录页面上应该有一个登录的表单。有用户名和密码输入的框。 用户点击登录，提交表单，提交用户名和密码。form是post方式提交。 步骤3：后台要有一个对应的Servlet来处理登录的请求。 登录成功：跳转到部门列表页面。 登录失败：跳转到失败的页面。 步骤4：再提供一个登录失败的页面。 登录功能实现了，目前存在的最大的问题： 这个登录功能目前只是一个摆设，没有任何作用。只要用户知道后端的请求路径，照样可以在不登录的情况下访问。 这个登录没有真正起到拦截的作用。怎么解决？ JSP的指令 指令的作用：指导JSP的翻译引擎如何工作（指导当前的JSP翻译引擎如何翻译JSP文件。） 指令包括哪些呢？ include指令：包含指令，在JSP中完成静态包含，很少用了。（这里不讲） taglib指令：引入标签库的指令。这个到JJSTL标签库的时候再学习。现在先不管。 page指令：目前重点学习一个page指令。 指令的使用语法是什么？ &lt;%@指令名 属性名&#x3D;属性值 属性名&#x3D;属性值 属性名&#x3D;属性值….%&gt; 关于page指令当中都有哪些常用的属性呢？ &lt;%@page session=&quot;true|false&quot; %&gt; true表示启用JSP的内置对象session，表示一定启动session对象。没有session对象会创建。 如果没有设置，默认值就是session=&quot;true&quot; session=&quot;false&quot; 表示不启动内置对象session。当前JSP页面中无法使用内置对象session。 aspectj123456- ``` &lt;%@page contentType=&quot;text/json&quot; %&gt; contentType属性用来设置响应的内容类型 但同时也可以设置字符集。 &lt;%@page contentType=&quot;text/json;charset=UTF-8&quot; %&gt; &lt;%@page pageEncoding=&quot;UTF-8&quot; %&gt; pageEncoding=&quot;UTF-8&quot; 表示设置响应时采用的字符集。 aspectj12345- ``` &lt;%@page import=&quot;java.util.List, java.util.Date, java.util.ArrayList&quot; %&gt; &lt;%@page import=&quot;java.util.*&quot; %&gt; import语句，导包。 &#96;&#96;&#96;&lt;%@page errorPage&#x3D;”&#x2F;error.jsp” %&gt;当前页面出现异常之后，跳转到error.jsp页面。errorPage属性用来指定出错之后的跳转位置。 autohotkey12345- ``` &lt;%@page isErrorPage=&quot;true&quot; %&gt; 表示启用JSP九大内置对象之一：exception 默认值是false。 JSP的九大内置对象 jakarta.servlet.jsp.PageContext pageContext 页面作用域 jakarta.servlet.http.HttpServletRequest request 请求作用域 jakarta.servlet.http.HttpSession session 会话作用域 jakarta.servlet.ServletContext application 应用作用域 pageContext &lt; request &lt; session &lt; application 以上四个作用域都有：setAttribute、getAttribute、removeAttribute方法。 以上作用域的使用原则：尽可能使用小的域。 java.lang.Throwable exception jakarta.servlet.ServletConfig config java.lang.Object page （其实是this，当前的servlet对象） jakarta.servlet.jsp.JspWriter out （负责输出） jakarta.servlet.http.HttpServletResponse response （负责响应） EL表达式 EL表达式是干什么用的？ Expression Language（表达式语言） EL表达式可以代替JSP中的java代码，让JSP文件中的程序看起来更加整洁，美观。 JSP中夹杂着各种java代码，例如&lt;% java代码 %&gt;、&lt;%&#x3D;%&gt;等，导致JSP文件很混乱，不好看，不好维护。所以才有了后期的EL表达式。 EL表达式可以算是JSP语法的一部分。EL表达式归属于JSP。 EL表达式出现在JSP中主要是： 从某个作用域中取数据，然后将其转换成字符串，然后将其输出到浏览器。这就是EL表达式的功效。三大功效： 第一功效：从某个域中取数据。 四个域： pageContext request session application 第二功效：将取出的数据转成字符串。 如果是一个java对象，也会自动调用java对象的toString方法将其转换成字符串。 第三功效：将字符串输出到浏览器。 和这个一样：&lt;%&#x3D; %&gt;，将其输出到浏览器。 EL表达式很好用，基本的语法格式： ${表达式} EL表达式的使用： &lt;% // 创建User对象 User user = new User(); user.setUsername(&quot;jackson&quot;); user.setPassword(&quot;1234&quot;); user.setAge(50); // 将User对象存储到某个域当中。一定要存，因为EL表达式只能从某个范围中取数据。 // 数据是必须存储到四大范围之一的。 request.setAttribute(&quot;userObj&quot;, user); %&gt; &lt;%--使用EL表达式取--%&gt; $&#123;这个位置写什么？？？？这里写的一定是存储到域对象当中时的name&#125; 要这样写： $&#123;userObj&#125; 等同于java代码：&lt;%=request.getAttribute(&quot;userObj&quot;)%&gt; 你不要这样写：$&#123;&quot;userObj&quot;&#125; 面试题： $&#123;abc&#125; 和 $&#123;&quot;abc&quot;&#125;的区别是什么？ $&#123;abc&#125;表示从某个域中取出数据，并且被取的这个数据的name是&quot;abc&quot;，之前一定有这样的代码: 域.setAttribute(&quot;abc&quot;, 对象); $&#123;&quot;abc&quot;&#125; 表示直接将&quot;abc&quot;当做普通字符串输出到浏览器。不会从某个域中取数据了。 $&#123;userObj&#125; 底层是怎么做的？从域中取数据，取出user对象，然后调用user对象的toString方法，转换成字符串，输出到浏览器。 &lt;%--如果想输出对象的属性值，怎么办？--%&gt; $&#123;userObj.username&#125; 使用这个语法的前提是：User对象有getUsername()方法。 $&#123;userObj.password&#125; 使用这个语法的前提是：User对象有getPassword()方法。 $&#123;userObj.age&#125; 使用这个语法的前提是：User对象有getAge()方法。 $&#123;userObj.email&#125; 使用这个语法的前提是：User对象有getEmail()方法。 EL表达式中的. 这个语法，实际上调用了底层的getXxx()方法。 注意：如果没有对应的get方法，则出现异常。报500错误。 $&#123;userObj.addr222.zipcode&#125; 以上EL表达式对应的java代码： user.getAddr222().getZipcode() markdown123456789101112131415161718192021222324252627282930313233343536373839404142- EL表达式优先从小范围中读取数据。 - pageContext &lt; request &lt; session &lt; application- EL表达式中有四个隐含的隐式的范围： - pageScope 对应的是 pageContext范围。 - requestScope 对应的是 request范围。 - sessionScope 对应的是 session范围。 - applicationScope 对应的是 application范围。- EL表达式对null进行了预处理。如果是null，则向浏览器输出一个空字符串。- EL表达式取数据的时候有两种形式： - 第一种：. （大部分使用这种方式） - 第二种：[ ] （如果存储到域的时候，这个name中含有特殊字符，可以使用 [ ]） - request.setAttribute(&quot;abc.def&quot;, &quot;zhangsan&quot;); - $&#123;requestScope.abc.def&#125; 这样是无法取值的。 - 应该这样：$&#123;requestScope[&quot;abc.def&quot;]&#125;- 掌握使用EL表达式，怎么从Map集合中取数据： - $&#123;map.key&#125;- 掌握使用EL表达式，怎么从数组和List集合中取数据： - $&#123;数组[0]&#125; - $&#123;数组[1]&#125; - $&#123;list[0]&#125;- page指令当中，有一个属性，可以忽略EL表达式 - ``` &lt;%@page contentType=&quot;text/html;charset=UTF-8&quot; isELIgnored=&quot;true&quot; %&gt; isELIgnored=&quot;true&quot; 表示忽略EL表达式 isELIgnored=&quot;false&quot; 表示不忽略EL表达式。（这是默认值） isELIgnored=&quot;true&quot; 这个是全局的控制。 可以使用反斜杠进行局部控制：\\$&#123;username&#125; 这样也可以忽略EL表达式。 通过EL表达式获取应用的根： ${pageContext.request.contextPath} EL表达式中其他的隐式对象： pageContext param paramValues initParam EL表达式的运算符 算术运算符 +、-、*、&#x2F;、% 关系运算符 &#x3D;&#x3D; eq !&#x3D; &gt; &gt;&#x3D; &lt; &lt;&#x3D; 逻辑运算符 ! &amp;&amp; || not and or 条件运算符 ? : 取值运算符 [ ]和. empty运算符 empty运算符的结果是boolean类型 ${empty param.username} ${not empty param.username} ${!empty param.password} JSTL标签库 什么是JSTL标签库？ Java Standard Tag Lib（Java标准的标签库） JSTL标签库通常结合EL表达式一起使用。目的是让JSP中的java代码消失。 标签是写在JSP当中的，但实际上最终还是要执行对应的java程序。（java程序在jar包当中。） 使用JSTL标签库的步骤： 第一步：引入JSTL标签库对应的jar包。 tomcat10之后引入的jar包是： jakarta.servlet.jsp.jstl-2.0.0.jar jakarta.servlet.jsp.jstl-api-2.0.0.jar 在IDEA当中怎么引入？ 在WEB-INF下新建lib目录，然后将jar包拷贝到lib当中。然后将其“Add Lib…” 一定是要和mysql的数据库驱动一样，都是放在WEB-INF&#x2F;lib目录下的。 什么时候需要将jar包放到WEB-INF&#x2F;lib目录下？如果这个jar是tomcat服务器没有的。 第二步：在JSP中引入要使用标签库。（使用taglib指令引入标签库。） JSTL提供了很多种标签，你要引入哪个标签？？？？重点掌握核心标签库。 &#96;&#96;&#96;&lt;%@taglib prefix&#x3D;”c” uri&#x3D;”http://java.sun.com/jsp/jstl/core&quot; %&gt;这个就是核心标签库。prefix&#x3D;”这里随便起一个名字就行了，核心标签库，大家默认的叫做c，你随意。” llvm123456789101112 - 第三步：在需要使用标签的位置使用即可。表面使用的是标签，底层实际上还是java程序。 - JSTL标签的原理 - ``` &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 以上uri后面的路径实际上指向了一个xxx.tld文件。 tld文件实际上是一个xml配置文件。 在tld文件中描述了“标签”和“java类”之间的关系。 以上核心标签库对应的tld文件是：c.tld文件。它在哪里。 在jakarta.servlet.jsp.jstl-2.0.0.jar里面META-INF目录下，有一个c.tld文件。 源码解析：配置文件tld解析 &#96;&#96;&#96; 对该标签的描述 catch 标签的名字 org.apache.taglibs.standard.tag.common.core.CatchTag 标签对应的java类。 JSP 标签体当中可以出现的内容，如果是JSP，就表示标签体中可以出现符合JSP所有语法的代码。例如EL表达式。 对这个属性的描述 var 属性名 false false表示该属性不是必须的。true表示该属性是必须的。 false 这个描述说明了该属性是否支持EL表达式。false表示不支持。true表示支持EL表达式。 &lt;c:catch var&#x3D;””&gt;JSP….dust1234567891011121314151617181920212223242526272829 - jstl中的核心标签库core当中有哪些常用的标签呢？ - c:if - &lt;c:if test=&quot;boolean类型，支持EL表达式&quot;&gt;&lt;/c: if&gt; - c:forEach - &lt;c:forEach items=&quot;集合，支持EL表达式&quot; var=&quot;集合中的元素&quot; varStatus=&quot;元素状态对象&quot;&gt; $&#123;元素状态对象.count&#125; &lt;/c: forEach&gt; - &lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;2&quot;&gt; $&#123;i&#125; &lt;/c: forEach&gt; - c:choose c:when c:otherwise - ``` &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;param.age &lt; 18&#125;&quot;&gt; 青少年 &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;param.age &lt; 35&#125;&quot;&gt; 青年 &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;param.age &lt; 55&#125;&quot;&gt; 中年 &lt;/c:when&gt; &lt;c:otherwise&gt; 老年 &lt;/c:otherwise&gt; &lt;/c:choose&gt; 改造OA 使用什么技术改造呢？ Servlet + JSP + EL表达式 + JSTL标签。进行改造。 在前端HTML代码中，有一个标签，叫做base标签，这个标签可以设置整个网页的基础路径。 这是Java的语法，也不是JSP的语法。是HTML中的一个语法。HTML中的一个标签。通常出现在head标签中。 &lt; base href&#x3D;”http://localhost:8080/oa/&quot;&gt; 在当前页面中，凡是路径没有以“&#x2F;”开始的，都会自动将base中的路径添加到这些路径之前。 &lt; a href&#x3D;”ab&#x2F;def”&gt;&lt;&#x2F; a&gt; 等同于：&lt; a href&#x3D;”http://localhost:8080/oa/ab/def&quot;&gt;&lt;&#x2F; a&gt; 需要注意：在JS代码中的路径，保险起见，最好不要依赖base标签。JS代码中的路径最好写上全路径。 &#96;&#96;&#96; css12345678910111213141516171819202122232425262728293031# Filter过滤器- 当前的OA项目存在什么缺陷？ - DeptServlet、EmpServlet、OrderServlet。每一个Servlet都是处理自己相关的业务。在这些Servlet执行之前都是需要判断用户是否登录了。如果用户登录了，可以继续操作，如果没有登录，需要用户登录。这段判断用户是否登录的代码是固定的，并且在每一个Servlet类当中都需要编写，显然代码没有得到重复利用。包括每一个Servlet都要解决中文乱码问题，也有公共的代码。这些代码目前都是重复编写，并没有达到复用。怎么解决这个问题? - 可以使用Servlet规范中的Filter过滤器来解决这个问题。 - Filter是什么，有什么用，执行原理是什么？ - Filter是过滤器。 - Filter可以在Servlet这个目标程序执行之前添加代码。也可以在目标Servlet执行之后添加代码。之前之后都可以添加过滤规则。 - 一般情况下，都是在过滤器当中编写公共代码。 - 一个过滤器怎么写呢？ - 第一步：编写一个Java类实现一个接口：jarkata.servlet.Filter。并且实现这个接口当中所有的方法。 - init方法：在Filter对象第一次被创建之后调用，并且只调用一次。 - doFilter方法：只要用户发送一次请求，则执行一次。发送N次请求，则执行N次。在这个方法中编写过滤规则。 - destroy方法：在Filter对象被释放/销毁之前调用，并且只调用一次。 - 第二步：在web.xml文件中对Filter进行配置。这个配置和Servlet很像。 - ``` &lt;filter&gt; &lt;filter-name&gt;filter2&lt;/filter-name&gt; &lt;filter-class&gt;com.bjpowernode.javaweb.servlet.Filter2&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter2&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 或者使用注解：@WebFilter({“*.do”}) 注意： Servlet对象默认情况下，在服务器启动的时候是不会新建对象的。 Filter对象默认情况下，在服务器启动的时候会新建对象。 Servlet是单例的。Filter也是单例的。（单实例。） 目标Servlet是否执行，取决于两个条件： 第一：在过滤器当中是否编写了：chain.doFilter(request, response); 代码。 第二：用户发送的请求路径是否和Servlet的请求路径一致。 chain.doFilter(request, response); 这行代码的作用： 执行下一个过滤器，如果下面没有过滤器了，执行最终的Servlet。 注意：Filter的优先级，天生的就比Servlet优先级高。 &#x2F;a.do 对应一个Filter，也对应一个Servlet。那么一定是先执行Filter，然后再执行Servlet。 关于Filter的配置路径： &#x2F;a.do、&#x2F;b.do、&#x2F;dept&#x2F;save。这些配置方式都是精确匹配。 &#x2F;* 匹配所有路径。 *.do 后缀匹配。不要以 &#x2F; 开始 &#x2F;dept&#x2F;* 前缀匹配。 在web.xml文件中进行配置的时候，Filter的执行顺序是什么？ 依靠filter-mapping标签的配置位置，越靠上优先级越高。 过滤器的调用顺序，遵循栈数据结构。 使用@WebFilter的时候，Filter的执行顺序是怎样的呢？ 执行顺序是：比较Filter这个类名。 比如：FilterA和FilterB，则先执行FilterA。 比如：Filter1和Filter2，则先执行Filter1. Filter的生命周期？ 和Servlet对象生命周期一致。 唯一的区别：Filter默认情况下，在服务器启动阶段就实例化。Servlet不会。 Filter过滤器这里有一个设计模式： 责任链设计模式。 过滤器最大的优点： 在程序编译阶段不会确定调用顺序。因为Filter的调用顺序是配置到web.xml文件中的，只要修改web.xml配置文件中filter-mapping的顺序就可以调整Filter的执行顺序。显然Filter的执行顺序是在程序运行阶段动态组合的。那么这种设计模式被称为责任链设计模式。 责任链设计模式最大的核心思想： 在程序运行阶段，动态的组合程序的调用顺序。 使用过滤器改造OA项目。 Listener监听器 什么是监听器？ 监听器是Servlet规范中的一员。就像Filter一样。Filter也是Servlet规范中的一员。 在Servlet中，所有的监听器接口都是以“Listener”结尾。 监听器有什么用？ 监听器实际上是Servlet规范留给我们javaweb程序员的特殊时机。 特殊的时刻如果想执行这段代码，你需要想到使用对应的监听器。 Servlet规范中提供了哪些监听器？ jakarta.servlet包下： ServletContextListener ServletContextAttributeListener ServletRequestListener ServletRequestAttributeListener jakarta.servlet.http包下： HttpSessionListener HttpSessionAttributeListener 该监听器需要使用@WebListener注解进行标注。 该监听器监听的是什么？是session域中数据的变化。只要数据变化，则执行相应的方法。主要监测点在session域对象上。 HttpSessionBindingListener 该监听器不需要使用@WebListener进行标注。 假设User类实现了该监听器，那么User对象在被放入session的时候触发bind事件，User对象从session中删除的时候，触发unbind事件。 假设Customer类没有实现该监听器，那么Customer对象放入session或者从session删除的时候，不会触发bind和unbind事件。 HttpSessionIdListener session的id发生改变的时候，监听器中的唯一一个方法就会被调用。 HttpSessionActivationListener 监听session对象的钝化和活化的。 钝化：session对象从内存存储到硬盘文件。 活化：从硬盘文件把session恢复到内存。 实现一个监听器的步骤：以ServletContextListener为例。 第一步：编写一个类实现ServletContextListener接口。并且实现里面的方法。 void contextInitialized(ServletContextEvent event) void contextDestroyed(ServletContextEvent event) xml1234567- 第二步：在web.xml文件中对ServletContextListener进行配置，如下： - ``` &lt;listener&gt; &lt;listener-class&gt;com.bjpowernode.javaweb.listener.MyServletContextListener&lt;/listener-class&gt; &lt;/listener&gt; 当然，第二步也可以不使用配置文件，也可以用注解，例如：@WebListener 注意：所有监听器中的方法都是不需要javaweb程序员调用的，由服务器来负责调用？什么时候被调用呢？ 当某个特殊的事件发生（特殊的事件发生其实就是某个时机到了。）之后，被web服务器自动调用。 思考一个业务场景： 请编写一个功能，记录该网站实时的在线用户的个数。 我们可以通过服务器端有没有分配session对象，因为一个session代表了一个用户。有一个session就代表有一个用户。如果你采用这种逻辑去实现的话，session有多少个，在线用户就有多少个。这种方式的话：HttpSessionListener够用了。session对象只要新建，则count++，然后将count存储到ServletContext域当中，在页面展示在线人数即可。 业务发生改变了，只统计登录的用户的在线数量，这个该怎么办？ session.setAttribute(“user”, userObj); 用户登录的标志是什么？session中曾经存储过User类型的对象。那么这个时候可以让User类型的对象实现HttpSessionBindingListener监听器，只要User类型对象存储到session域中，则count++，然后将count++存储到ServletContext对象中。页面展示在线人数即可。 实现oa项目中当前登录在线的人数。 什么代表着用户登录了？ session.setAttribute(“user”, userObj); User类型的对象只要往session中存储过，表示有新用户登录。 什么代表着用户退出了？ session.removeAttribute(“user”); User类型的对象从session域中移除了。 或者有可能是session销毁了。（session超时）","categories":[],"tags":[]},{"title":"web-Servlet","slug":"WEB后端-Servlet","date":"2022-09-29T01:47:43.000Z","updated":"2022-12-05T13:49:24.088Z","comments":true,"path":"2022/09/29/WEB后端-Servlet/","link":"","permalink":"http://tanquerayds.site/2022/09/29/WEB%E5%90%8E%E7%AB%AF-Servlet/","excerpt":"","text":"Servlet 意义：作为web和webapp开发的桥梁实现交互式浏览,生成动态web概念：Servlet 是在服务器上运行的小程序。Servlet是Tomcat为了响应用户的请求所创建的一个对象。 一、B&#x2F;S结构原理剖析 1.系统架构包括什么形式? C&#x2F;S架构 B&#x2F;S架构 2.C&#x2F;S架构 Client &#x2F; Server(客户端&#x2F;服务器) C&#x2F;S架构的特点:需要安装特定的客户端软件。 C&#x2F;S架构的系统优点和缺点分别是什么? 优点: 速度快（数据大部分集成到客户端软件当中,交互数据量小) 服务器压力小 界面酷炫（专门的语言去实现界面的，更加灵活。) 安全(大量的数据是集成在客户端软件当中的。) … 缺点: 升级维护比较差劲。(升级维护比较麻烦。成本比较高。每一个客户端软件都需要升级。有一些软件不是那么容易安装的。) 3.B&#x2F;S架构 B&#x2F;S (Browser &#x2F; Server，浏览器&#x2F;服务器) B&#x2F;S结构的系统是不是一个特殊的C&#x2F;S系统? 实际上B&#x2F;S结构的系统是一个特殊的C&#x2F;S结构，这个Client是一个固定不变浏览器软件 B&#x2F;S结构的系统优缺点是: 优点: 升级维护方便成本比较低。(只需要升级服务器端即可不需要安装特定的客户端软件，用户操作极其方便。只需要打开浏览器，输入网址即可。 缺点: 速度慢(所有的数据都是在服务器上，用户发送的每一个请求都是需要服务器全身心的响应数据，所以B&#x2F;S结构的系统在网络中传送的数据量比较大。) 体验差（界面不是那么酷炫，因为浏览器只支持三个语言HTML CSS JavaScript。在加上速度慢。)不安全(所有的数据都在服务器上，只要服务器发生火灾，地震等不可抗力，最终数据全部丢失。)… 一个WEB系统的通信原理？通信步骤： 用户输入网址（url） 域名解析器进行域名解析(ping的百度ip):http://180.101.49.12:80/index.html 浏览器软件在网络中搜索180.101.49.12这台主机 定位到主机的80端口对应的服务器软件 80端口对应的服务器软件得知浏览器请求的资源名是：index.html 80端口服务器软件找到文件后将数据响应到浏览器上 浏览器接收数据代码 浏览器渲染，执行html css js 代码，完成通信 关于WEB服务器软件 WEB服务器软件都有哪些呢?(这些软件都是提前开发好的。) Tomcat (WEB服务器) jetty (WEB服务器) IBOSS(应用服务器) WebLogi (应用服务器) WebSphere(应用服务器) 应用服务器和WEB服务器的关系? 应用服务器实现了lavaEE的所有规范。(JavaEE有13个不同的规范。) WEB服务器只实现了lavaEE中的Servlet + JSP两个核心的规范。 应用服务器是包含WEB服务器的。 例如JBOSS中内嵌了一个Tomcat服务器。 Tomcat下载 apache官网地址: https://www.apache.orglo tomcat 官网地址: https://tomcat.apache.orgo tomcat开源免费的轻量级WEB服务器。 tomcat的logo是一只公猫（寓意表示Tomcat服务器是轻巧的，小巧的，果然，体积小，运行速度快，只实现了Servlet+SP规范) tomcat是java语言写的。 tomcat服务器要想运行，必须先有jre (Java的运行时环境) Tomcat服务器要想运行，需要先有jre，所以要先安装IDK，配置java运行环境。| JAVA_HOME&#x3D;C:\\Program FilesyJavaVyjdk-17.0.1 PATH&#x3D;%JAVA_HOME%\\bin Tomcat服务器的安装配置:绿色版本的安装很简单，直接zip包解压即可。解压就是安装。启动Tomcat: bin目录下有一个文件: startup.bat,通过它可以启动Tomcat服务器。 xxx.bat文件是个什么文件? bat文件是windows操作系统专用的， bat文件是批处理文件，这种文件中可以编写大量的windows的dos命令，然后执行bat文件就相当于批量的执行dos命令。 startup.sh，这个文件在windows当中无法执行，在Linux环境当中可以使用。在Linux环境下能够执行的是shell命令，大量的shell命令编写在shell文件当中，然后执行这个shell文件可以批量的执行shell命令。 tomcat服务器提供了bat和sh文件，说明了这个tomcat服务器的通用性。 分析startup.bat文件得出，执行这个命令，实际上最后是执行: catalina.bat文件。catalina.bat文件中有这样一行配置: MAINCLASS&#x3D;org.apache.catalina.startup.Bootstrap(这个类就是main方法所在的类。) tomcat服务器就是Java语言写的，既然是java语言写的，那么启动Tomcat服务器就是执行main方法。我们尝试打开dos命令窗口，在dos命令窗口中输入startup.bat来启动tomcat服务器。显然直接启动行不通，还有两个环境变量需要配置: PATH&#x3D;%CATALINA_HOME%\\bin CATALINA_HOME&#x3D;Tomcat服务器的根 关于Tomcat服务器的目录 bin:这个目录是Tomcat服务器的命令文件存放的目录，比如:启动Tomcat，关闭Tomcat等。 conf:这个目录是Tomcat服务器的配置文件存放目录。(server.xml文件中可以配置端口号，默认Tomcat端口是8080) lib:这个目录是Tomcat服务器的核心程序目录，因为Tomcat服务器是Java语言编写的，这里的jar包里面都是class文件。 logs:Tomcat服务器的日志目录，Tomcat服务器启动等信息都会在这个目录下生成日志文件。 temp: Tomcat服务器的临时目录。存储临时文件。 webapps:这个目录当中就是用来存放大量的webapp (web application: web应用) work:这个目录是用来存放ISP文件翻译之后的java文件以及编译之后的class文件。 总结一下配置Tomcat服务器需要哪些环境变量? CATALINA_HOME&#x3D;Tomcat服务器的根 PATH&#x3D;%JAVA_HOME%lbin;%CATALINA_HOME%1bin JAVA_HOME&#x3D;JDK的根 启动Tomcat: startup 关闭ITomcat:top (shutdown.bat文件重命名为stop.bat，为什么?原因是shutdown命令和windows中的关机命令冲突。所以修改一下。) 怎么测试Toihcat服务器有没有启动成功呢? 打开浏览器，在浏览器的地址栏上输入URL即可:http://ip地址:端口(8080) ，这里ip用本地ip127.0.0.1或者localhost 实现一个最基本的web应用(这个web应用中没有java小程序) 第一步:找到CATALINA_HOMEwebapps目录 因为所有的webapp要放到webapps目录下。(没有为什么，这是Tomcat服务器的要求。如果不放到这里，Tomcat服务器找不到你的应用。) 第二步:在CATALINA_HOME&#x2F;webapps目录下新建一个子目录，起名:oa 这个目录名oa就是你这个webapp的名字。 第三步:在oa目录下新建资源文件，例如:index.html,并编写内容 第四步:启动Tomcat服务器 第五步:打开浏览器，在浏览器地址栏上输入这样的URL: http://127.0.0.1:8080/oa/index.html 思考一个问题: 我们在浏览器上直接输入一个URL，然后回车。这个动作和超链接一样吗?既然是一样的，我们完全可以使用超链接。 html123456&lt;!--注意以下的路径，以/开始，带项目名，是一个绝对路径。不需要添加http://127.0.0.1:8080--&gt;&lt;a href=&quot;/oa/test1.html&quot;&gt;跳转测试1&lt;/a&gt;&lt;!--多个层级也没有关系,正常访问即可--&gt;&lt;!--注意:目前前端上的路径都以“/&quot;根目录开始的，都是加项目名的--&gt; &lt;a href=&quot;/oa/1/2/test2.html&quot;&gt;跳转测试2&lt;/a&gt; http://127.0.0.1:8080/oa/userList.html 访问这个地址，可以展示一个用户列表页面。但是这个用户列表页面是写死在HTML文件当中的。这种资源我们称为静态资源。怎么能变成动态资源。显然需要连接数据库。 连接数据库需要JDBC程序，也就是说需要编写Java程序连接数据库，数据库中有多少条记录，页面上就显示多少条记录，这种技术被称为动态网页技术。(动态网页技术并不是说页面中有flash动画。动态网页技术是说页面中的数据是动态的，根据数据库中数据的变化而变化。) 有哪些角色(在整个BS结构的系统当中，有哪些人参与进去了) 浏览器软件的开发团队（(浏览器软件很多:谷歌浏览器、火狐浏览器、IE浏览器….) WEB Server的开发团队(WEB Server这个软件有很多:Tomcat、Jetty、WebLogic、JBQSS、WebSphere. DB Server的开发团队(DB Server这个软件也有很多:Oracle、MySQL…… webapp的开发团队(WEB应用是我们做为JavaWEB程序员开发的)角色和角色之间需要遵守哪些规范，哪些协议 webapp的开发团队和WEB Server的开发团队之间有一套规范: JavaEE规范之一Servlet规范。Servlet规范的作用是什么? WEB Server和webapp解耦合。 Browser和WebServer之间有一套传输协议:HTTP协议。(超文本传输协议。 webapp开发团队和DB Server的开发团队之间有—套规范:JDBC规范。 二、Servlet本质简单模拟Servlet 模拟Servlet本质 充当SUN公司的角色，制定Servlet规范javax.servlet.Servlet接口 充当Tomcat服务器的开发者 充当Webapp的开发者 BankServlet implements Servleto UserListServlet implements Servleto UserLoginServlet implements Servlet 通过我们的分析:对于我们javaweb程序员来说，我们只需要做两件事: 编写一个类实现Servlet接口。 将编写的类配置到配置文件中，在配置文件中:指定请求路径和类名的关系。 注意:配置文件名及路径是固定的文件名、文件路径都是SUN公司制定的Servlet规范中的明细。。严格意义上来Servlet其实并不是简单的一个接口: Servlet规范中规定了: 一个合格的webapp应该是一个怎样的目录结构。一个合格的webapp应该有一个怎样的配置文件。文件路径放在哪里。java程序放在哪里。这些都是Servlet规范中规定的。 Tomcat服务器要遵循Servlet规范。JavaWEB程序员也要遵循这个Servlet规范。这样Tomcat服务器和webapp才能解耦合。 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.apache.webserver.Tomcat;import az.Servlet.Servlet;import java.util.Scanner;import java.io.FileInputStream;import java.util.Properties;/* 充当sun公司制定 app开发者配置文件名及路径应放在 web.properties /*/public class Tomcat &#123;public static void main(String []args) throws Exception&#123;System.out.println(&quot;启动Tomcat服务器软件成功！&quot;);System.out.println(&quot;请输入要访问的java程序路径&quot;);//根据用户输入的路径获取配置文件中对应的java程序类名Scanner sca = new Scanner(System.in);String key = sca.nextLine();//加载propertiesString path = &quot;web.properties&quot;;FileInputStream fis = new FileInputStream(path);Properties pro = new Properties();pro.load(fis);//通过key获取valueString className = pro.getProperty(key);//用反射机制获取类(虽然不知道类具体内容,但知道一定实现了Servlet接口)//Object obj = Class.forName(className);没用idea错得离谱，io有点模糊了Class clazz = Class.forName(className);Object obj = clazz.newInstance();//向下转型可以调用方法Servlet servlet =(Servlet)obj;//动态绑定到获取类实现了Servlet接口的方法servlet.service(); &#125;&#125;package az.Servlet;/* 充当sun公司制定 app开发者配置文件名及路径应放在 web.properties /*/public interface Servlet&#123; void service();&#125;/* java开发团队*/package pers.az.UserListServlet;import az.Servlet.Servlet;public class UserListServlet implements Servlet&#123; public void service()&#123; System.out.println(&quot;UserListServlet程序启动成功！&quot;); &#125;&#125;.../* 配置文件*//aaa=pers.az.BankServlet.BankServlet/bbb=pers.az.UserListServlet.UserListServlet/ccc=pers.az.UserLoginServlet.UserLoginServlet 开发第一个Servlet Servlet规范意义所在? 开发所遵循的标准，webapp可以放在不同的WEB服务器中运行，web服务器也能运行实现了该规范的程序。 Servlet规范包括什么呢? 规范了一个web应用中应该有哪些配置文件 规范了一个web应用中配置文件的名字 规范了一个web应用中配置文件存放的路径 规范了一个web应用中配置文件的内容 规范了一个合法有效的web应用它的目录结构应该是怎样的。 .…. 开发一个带有Servlet (Java小程序)的webapp(重点) 开发步骤是怎样的? 第一步:在webapps目录下新建一个目录，起名crm (这个crm就是webapp的名字)。 当然，也可以是其它项目,比如银行项目，可以创建一个目录bank，办公系统可以创建一个oa。 注意:crm就是这个webapp的根 第二步:在webapp的根下新建一个目录:WEB-INF 注意:这个目录的名字是Servlet规范中规定的，必须全部大写，必须一模一样 第三步:在WEB-INF目录下新建一个目录:classes 注意:这个目录的名字必须是全部小写的classes。这也是Servlet规范中规的，另外这个目录下一定存放的是Java程序编译之后的class文件(这里存放的是字节码文件)。 第四步:在WEB-INF目录下新建—个目录:lib 注意:这个目录不是必须的。但如果一个webapp需要第三方的jar包的话，这个jar包要放到这个lib目录下，这个目录的名字也不能随意编写，必须是全部小写的lib。例如java语言连接数据库需要数据库的驱动jar包（jdbc）。那么这个jar包就一定要放到lib目录下。这Servlet规范中规定的。 第五步:在WEB-INF目录下新建—个文件:web.xml 注意:这个文件是必须的，这个文件名必须叫做web.xml。这个文件必须放在这里。一个合法的webapp，web.xml文件是必须的，这个web.xml文件就是一个配置文件，在这个配置文件中描述了请求路径和Servlet类之间的对照关系。且这个文件最好从其他的webapp中拷贝，最好别手写。没必要。复制粘贴 在最后一步的时候发现pes.az.helloServlet.HelloServlet路径写错了，忘记加最后的类名.HelloServlet xml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot; version=&quot;5.0&quot; metadata-complete=&quot;true&quot;&gt; &lt;/web-app&gt; 第六步:编写一个ava程序，这个小Java程序也不能随意开发，这个小java程序必须实现Servlet接口。这个Servlet接口不在IDK当中。(因为Servlet不JavaSE了。Servlet属于JavaEE，是另外的一套类库。)Servlet接口(Servlet.class文件)是Oracle提供的。(最原始的是sun公司提供的。)Servlet接口是JavaEE的规范中的一员。Tomcat服务器实现了Servlet规范，所以Tomcat服务器也需要使用Serlet接口。Tomcat服务器中应该有这个接口，Tomcat服务器的CATALINA_HOMElib目录下有一个servlet-api.jar，解压这个servlet-api.jar之后，你会看到里面有一个Servlet.class文件。 重点:从akartaEE9开始，Servlet接口的全名变了: jakarta.servlet.Servlet 注意:编写这个lava小程序的时候，java源代码你愿意在哪里就在哪里，位置无所谓，你只需要将java源代码编译之后的class文件放到classes目录下即可。 第七步:编译编写的HelloServlet 重点:你怎么能让HelloSerxlet编译通过呢? 配置环境变量CLASSBAIHCLASSPATH&#x3D;.;C:\\devlapache-tomcat-10.0.12lliblservlet-api.jar思考问题:以上配置的CLASSPATH和Tomcat服务器运行有没有关系?没有任何关系，以上配置这个环境变量只是为了让你的HelloServlet能够正常编译生成class文件。 第八步:将以上编译之后的HelloServlet.class文件拷贝到WEB-INFIclasses目录下。 第九步:在web.xml文件中编写配置信息，让”请求路径”和””Servlet类名”关联在一起。这一步用专业术语描述:在web.xml文件中注册Servlet类。xml1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot; version=&quot;5.0&quot; metadata-complete=&quot;true&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;suiyi&lt;/servlet-name&gt; &lt;servlet-class&gt;pes.az.helloServlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;suiyi&lt;/servlet-name&gt; &lt;url-pattern&gt;/dou/ke/yi&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; * 第十步:启动Tomcat服务器 第十一步:打开浏览器，在浏览器地址栏上输入一个url，这个URL必须是:http://127.0.0.1:8080/crm//dou/ke/yi非常重要的一件事:浏览器上的请求路径不能随便写，这个请求路径必须和web.xml文件中的url-pattern一致。注意:浏览器上的请求路径和web.xml文件中的url-pattern的唯一区别就是:浏览器上的请求路径带项目名:&#x2F;crm 浏览器上编写的路径太复杂，可以使用超链接。(非常重要: html页面只能放到WEB-INF目录外面。)xml1&lt;a href=&quot;/crm/dou/ke/yi&quot;&gt;跳转java程序页&lt;/a&gt; 开发第一个Servlet总结配置jdk和tomcat环境，在webapps目录按规范创建文件夹，编写java程序实现servlet编译后的字节文件放规定目录，配置xml路径。其实重点就做两件事： 编写java程序 配置文件 关于JavaEE的版本 JavaEE目前最高版本是JavaEE8 JavaEE被Oracle捐献了，Oracle将lavaEE规范捐献给Apache了。 Apache把lavaE换名了，以后不叫avaEE了，以后叫做jakartaE。 以后没有JavaEE了。以后都叫做JakartaEE。 JavaEE8版本升级之后的”LavaEE 9”，不再是”LavaEE9”这个名字了，叫做JakartaEE9lavaEE8的时候对应的Serxlet类名是:javax.servlet.Servlet. JakartaEE9的时候对应的Servlet类名是: jakarta.servlet.Servlet(包名都换了)如果之前的项目还是在使用javaX.servlet.Servlet，那么项目无法直接部署到Tomcat10+版本上。只能部署到Tomcat9-版本上。在Tomcat9以及Tomcat9之前的版本中还是能够识别javax.servlet这个包。 解决Tomcat服务器在DOS命令窗口中的乱码问题(控制台乱码)将CATALINA_HOME&#x2F;conf&#x2F;logging.properties文件中的内容修改如下:java.util.logging.ConsoleHandler.encoding &#x3D; GBK 向浏览器响应一段HTML代码java123456789101112131415161718public class HelloServlet implements Servlet&#123; //5个方法 public void init(ServletConfig config)throws ServletException&#123; &#125; public void service(ServletRequest req,ServletResponse response) throws ServletException , IOException&#123; //向控制台打印输出 System.out.println(&quot;My First Servlet ,Hello Servlet&quot;); //设置响应内容的类型 response.setContentType(&quot;text/html&quot;); //获取输出流，自动关流 PrintWriter out = response.getWriter(); //网页上输入/localhost:8080/crm/dou/ke/yi 会打印出hello servlet out.print(&quot;&lt;h1&gt;hello servlet&lt;h1&gt;&quot;); &#125; ... 在Servlet中连接数据库java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class JDBCHello implements Servlet&#123;//5个方法public void init(ServletConfig config)throws ServletException&#123;&#125;public void service(ServletRequest req,ServletResponse response)throws ServletException , IOException&#123;//编写原始的JDBC程序，提前导包mysql驱动到了lib文件夹下//连接数据库，查询student表内容Connection conn = null;PreparedStatement ps = null;ResultSet rs = null;//设置响应内容的类型response.setContentType(&quot;text/html&quot;);//获取输出流，自动关流PrintWriter out = response.getWriter();try&#123; //1.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.通过DriverManager获取连接 String url = &quot;jdbc:mysql://localhost:3306/test_data_type&quot;; String user = &quot;root&quot;; String password = &quot;123456&quot;; conn = DriverManager.getConnection(url,user,password); //3.编写sql语句 String sql = &quot;select * from student&quot;; //4.把sql传给prepareStatement执行sql语句 ps = conn.prepareStatement(sql); rs = ps.executeQuery(); //5.用结果集ResultSet处理查询结果 while(rs.next())&#123; int anInt = rs.getInt(1); String name = rs.getString(2); System.out.println(anInt + &quot;\\t&quot; + name); //网页上打印出内容 out.print(anInt + &quot;\\t&quot; + name); &#125;&#125;catch(Exception e)&#123; e.printStackTrace();&#125;finally&#123; //6.关流，然后抓一下异常 if(rs != null)&#123; try&#123; rs.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; if(ps != null)&#123; try&#123; ps.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try&#123; conn.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; &#125; 思路总结 配置环境（win10，mysql，jdk（环境配置），Tomcat（环境配置）） 把编译好的java字节码文件放到Servlet规范目录下 在规范位置编写web.xml文件 用户在浏览器输入对应url发起请求，根据xml文件对应路径找到字节码文件，然后运行程序会通过JDBC连接数据库，并将查询结果响应到浏览器上。 成开发环境中开发Servlet程序集成开发工具很多，使用较多的IntelliJ IDEA，Eclipse（日食）使用IDEA开发Servlet： 第一步：New Project 第二步：新建模块（File –&gt;new–&gt;Module…） 第三步：让Module变成JavaEE的模块。（符合webapp，Servlet的规范） 在Module上右键单击：Add Framework Support.(添加框架支持) 然后窗口会有Web Application(选择webapp支持) idea会自动生成符合Servlet规范的webapp目录结构 重点，idea根据Web Application模板生成的目录中有一个web目录，代表webqpp的根 第四步：配置环境，首先是Sevlet和JSP的jar包放到classpath中 File –&gt; Project Structure–&gt;Modules–&gt; + –&gt;Add JARS 顺便实现jakarta.servlet.Servlet接口的5个方法 第五步：在service方法里编写业务代码，这里是连接数据库 第六步：按规范新建目录lib，将JDBCjar包放进去 第七步：在web.xml文件中完成java类的注册（请求路径和Servlet之间对应起来），这里无法动态获取，先写死 第八步：编写一个html页面，页面中超链接指向java程序，用户点击即可获取数据库中的表单内容 第九步：idea关联Tomcat服务器，关联过程中将webapp部署到Tomcat服务器中 idea右上角小锤Add Configuration,左上角+，点击Tomcat Server –&gt;local,设置参数，然后右边有个Deployment，修改Application context为项目名 我这里是 &#x2F;projectName 第十步： 启动Tomcat服务器 第十一步：浏览器地址栏输入http://127.0.0.1:8080/projectName.index.html 三、Servlet对象生命周期Servlet的生命周期全由WEB server（web容器）负责容器创建的Servlet都放到map集合进行管理 用户第一次发送请求：无参构造器实例化Servlet（只执行一次），init方法初始化（只执行一次），service方法–&gt;destroy方法销毁（关闭服务器遗言） 用户第n次请求会直接调用service方法n次 四、适配器设计模式用抽象类GenericServlet实现Servlet，然后可以把目标方法暴露给下一个继承类 java1public abstract GenericServlet implements Servlet&#123; public abstract void service(...)&#125; 改造GennericServlet java12345678910111213public class GenericServlet implements Servlet &#123; ServletConfig servletConfig;//把局部变量设置为全局变量 @Override public final void init(ServletConfig servletConfig) throws ServletException &#123; //ServletConfig对象由Tomcat创建并传进来 this.servletConfig = servletConfig; this.init(); &#125; //实现了 init(ServletConfig servletConfig)方法不会被子类重写导致servletConfig失效，且可以修改代码 public void init()&#123; &#125; Tomcat服务器有GennericServlet这个类 五、GenericServlet源码分析这个包括了上面和下面的内容，结合起来看可学到的内容： 四、适配器设计模式 通过方法传参把局部变量设置为全局变量（init） 面对子类想重写父类的final方法时，可在final方法内部调用其它抽象方法交给子类增加功能（init） 六、ServletConfig接口详解ServletConfig作为Servlet规范中的一员，webServer实现了其四个方法（与配置信息有关）getInitParameter(String name);getInitParameterNames();getServletContext();getServletName(); java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * GenericServlet封装了Config初始化Servlet配置信息的四个方法 * 继承了GenericServlet的类可直接调用 **/public class ConfigTestServlet extends GenericServlet &#123; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //设置响应类型 servletResponse.setContentType(&quot;text/html&quot;); //获取响应输出流，自动关闭 PrintWriter out = servletResponse.getWriter(); //调用父类方法返回初始化参数name用枚举类接收 Enumeration&lt;String&gt; initParameterNames = this.getInitParameterNames(); //通过遍历参数名获取参数值 while (initParameterNames.hasMoreElements())&#123; String name = initParameterNames.nextElement();//name String initParameter = this.getInitParameter(name);//name //打印到前台 out.println(name + &quot;=&quot; + initParameter + &quot;&lt;br&gt;&quot;); /* 页面显示内容： password=123456 driver=com.mysql.jdbc.Driver user=root url=jdbc:mysql//127.0.0.1:3306/test_data_type */ &#125; &#125;&#125;对应的配置文件 &lt;servlet&gt; &lt;servlet-name&gt;suiyi5&lt;/servlet-name&gt; &lt;servlet-class&gt;com.az.test02.ConfigTestServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;driver&lt;/param-name&gt; &lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql//127.0.0.1:3306/test_data_type&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;user&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;suiyi5&lt;/servlet-name&gt; &lt;url-pattern&gt;/dou/ke/yi5&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 七、ServletContext接口详解ServletContext是对象的环境对象（Servler对象的上下文对象）由webServer实现，一个webapp对应一个ServletContext，多个Servlet共享一个ServletContext，一个ServletContext对应一个web.xml文件 ServletContext接口中有哪些常用的方法？ 获取初始化参数，获取路径，对servletcontext应用域增删改查，查看日志等 java12public String getInitParameter(String name); // 通过初始化参数的name获取valuepublic Enumeration&lt;String&gt; getInitParameterNames(); // 获取所有的初始化参数的name xml1234567891011&lt;!--以上两个方法是ServletContext对象的方法，这个方法获取的是什么信息？是以下的配置信息--&gt;&lt;context-param&gt; &lt;param-name&gt;pageSize&lt;/param-name&gt; &lt;param-value&gt;10&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt; &lt;param-name&gt;startIndex&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--注意：以上的配置信息属于应用级的配置信息，一般一个项目中共享的配置信息会放到以上的标签当中。--&gt;&lt;!--如果你的配置信息只是想给某一个servlet作为参考，那么你配置到servlet标签当中即可，使用ServletConfig对象来获取。--&gt; java1234// 获取应用的根路径（非常重要），因为在java源代码当中有一些地方可能会需要应用的根路径，这个方法可以动态获取应用的根路径// 在java源码当中，不要将应用的根路径写死，因为你永远都不知道这个应用在最终部署的时候，起一个什么名字。public String getContextPath();//String contextPath = application.getContextPath(); java12// 获取文件的绝对路径（真实路径）public String getRealPath(String path); java12345678// 通过ServletContext对象也是可以记录日志的public void log(String message);public void log(String message, Throwable t); // Tomcat服务器的logs目录下都有哪些日志文件？//catalina.20xx-11-05.log 服务器端的java程序运行的控制台信息。//localhost.20xx-11-05.log ServletContext对象的log方法记录的日志信息存储到这个文件中。//localhost_access_log.20xx-11-05.txt 访问日志 java1234567891011// ServletContext对象还有另一个名字：应用域（后面还有其他域，例如：请求域、会话域）// 如果所有的用户共享一份数据，并且这个数据很少的被修改，并且这个数据量很少，可以将这些数据放到ServletContext这个应用域中 // 存（怎么向ServletContext应用域中存数据）public void setAttribute(String name, Object value); // map.put(k, v)// 取（怎么从ServletContext应用域中取数据）public Object getAttribute(String name); // Object v = map.get(k)// 删（怎么删除ServletContext应用域中的数据）public void removeAttribute(String name); // map.remove(k) 注意：编写Servlet类的时候，实际上是不会去直接继承GenericServlet类的，B&#x2F;S结构的系统是基于HTTP超文本传输协议的，在Servlet规范当中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类。我们编写的Servlet类要继承HttpServlet。（HttpServlet是HTTP协议专用的。）使用HttpServlet处理HTTP协议更便捷。但是你需要知道它的继承结构： java12345jakarta.servlet.Servlet（接口）【爷爷】jakarta.servlet.GenericServlet implements Servlet（抽象类）【儿子】jakarta.servlet.http.HttpServlet extends GenericServlet（抽象类）【孙子】以后编写的Servlet要继承HttpServlet类。 大家到目前为止都接触过哪些缓存机制了？ 堆内存当中的字符串常量池。 “abc” 先在字符串常量池中查找，如果有，直接拿来用。如果没有则新建，然后再放入字符串常量池。 堆内存当中的整数型常量池。 [-128 ~ 127] 一共256个Integer类型的引用，放在整数型常量池中。没有超出这个范围的话，直接从常量池中取。 连接池(Connection Cache) 这里所说的连接池中的连接是java语言连接数据库的连接对象：java.sql.Connection对象。 JVM是一个进程。MySQL数据库是一个进程。进程和进程之间建立连接，打开通道是很费劲的。是很耗费资源的。怎么办？可以提前先创建好N个Connection连接对象，将连接对象放到一个集合当中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要再新建连接对象，省去了新建的环节，直接从连接池中获取连接对象，大大提升访问效率。 连接池 最小连接数 最大连接数 连接池可以提高用户的访问效率。当然也可以保证数据库的安全性。 线程池 Tomcat服务器本身就是支持多线程的。 Tomcat服务器是在用户发送一次请求，就新建一个Thread线程对象吗？ 当然不是，实际上是在Tomcat服务器启动的时候，会先创建好N多个线程Thread对象，然后将线程对象放到集合当中，称为线程池。用户发送请求过来之后，需要有一个对应的线程来处理这个请求，这个时候线程对象就会直接从线程池中拿，效率比较高。 所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制。 redis NoSQL数据库。非关系型数据库。缓存数据库。 向ServletContext应用域中存储数据，也等于是将数据存放到缓存cache当中了。 八、HTTP协议剖析request:请求行：请求方法（get、post…） url 协议版本号请求头：配置信息空白行：分割行头和体请求体：键值对 response：状态行： 例：404、405、200、等响应行：协议版本号 状态码 状态响应头：响应内容状态空白行：分割响应体：具体内容被浏览器编译执行 九、GET和POST本质区别及选择get发送请求信息，安全post提交数据，相对不安全 十、HttpServlet源码分析十一、模板方法设计模式父类定义算法骨架具体实现留抽象方法给子类去做 十二、WEB欢迎页只带项目名默认走你设置的欢迎页例：127.0.0.1:8080&#x2F;ServletHttpTest —&gt; 127.0.0.1:8080&#x2F;ServletHttpTest&#x2F;index.htmlxml文件可以配置多个欢迎页，优先级依次下降 xml12345&lt;welcome-file-list&gt;&lt;!-- 默认从webapp根开始找--&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;loginTest.html&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 十三、HttpServletRequest源码分析十四、乱码解决方案十五、转发和重定向深度剖析十六、Servlet注解式开发十七、session原理剖析十八、cookie 原理剖析","categories":[],"tags":[]},{"title":"AJAX和JQuery","slug":"AJAX和JQuery","date":"2022-09-29T00:54:43.000Z","updated":"2022-09-29T08:46:14.032Z","comments":true,"path":"2022/09/29/AJAX和JQuery/","link":"","permalink":"http://tanquerayds.site/2022/09/29/AJAX%E5%92%8CJQuery/","excerpt":"","text":"AJAX 意义 可以实现网页的局部刷新，让程序更快响应用户操作 概念 是一种综合的技术，内容包括JavaScript : 创建XMLHttpRequest对象,调用属性或方法dom ：处理dom，更新select的数据css：处理视图，更新美化Servlet：服务器端技术数据格式：json，它之前是xml以上技术的综合使用叫做AJAX（Asynchronous JavaScript and XML） ajax 核心是javascript和xml（json）：使用js操作XMLHttpRequest，和服务器交互使用json数据格式 全局刷新和局部刷新 1）全局刷新:使用form,href等发起的请求是全局刷新。用户发起请求，视图改变了，跳转视图，使用新的数据添加到页面。缺点: 传递数据量比较大。占用网络的带宽 浏览器需要重新的渲染整个页面。 用户的体验不是那么好 2)局部刷新︰在当前页面中，发起请求，获取数据，更新当前页面的dom对象。对视图部分刷新特点: 数量比较小，在网络中传输速度快。 更新页面内容，是部分更新页面，浏览器不用全部渲染视图。 在一个页面中，可以做多个局部刷新 从服务器获取的是数据，拿到更新视图 异步请求对象 通过创建异步对象XMLHttpRequest操作属性方法完成局部刷新 在局部刷新，需要创建一个对象，代替浏览器发起请求的行为，这个对象存在内存中。代替浏览器发起请求并接收响应数据。这个对象叫做异步请求对象。全局刷新是同步行为，局部刷新是异步行为[浏览器数据没有全部更新]这个异步对象用于在后台与服务器交换数据。XMLHttpRequest 就是异步对象异步对象是在浏览器内部的一种javascript对象。各大浏览器都能支持异步对象使用。 AJAX实例练习JQuery基础选择器过滤器函数事件AJAX","categories":[],"tags":[]},{"title":"JavaScript","slug":"JavaScript笔记","date":"2022-09-22T02:16:43.000Z","updated":"2022-09-29T08:50:45.837Z","comments":true,"path":"2022/09/22/JavaScript笔记/","link":"","permalink":"http://tanquerayds.site/2022/09/22/JavaScript%E7%AC%94%E8%AE%B0/","excerpt":"","text":"JavaScript概述： 脚本语言（解释型语言）程序可被笔记本直接打开,其前身是网景的liveScript，sun公司为其命名javaScript，微软为了抢蛋糕做了个JScriptECMA（欧洲计算机制造协会）统一制定了262标准ECMAScript，同时JScript和JavaScript都遵守这个标准 JavaSrcipt三大块： 核心语法：ECMAScript DOM : 对节点进行规范操作，dom规范由W3C指定 BOM：对浏览器本身操作，例后退，地址栏，弹窗等DOM： Document Object Model：文档对象模型BOM： Browser Object Modeel:浏览器对象模型 ECMAScript嵌入JS的三种方式第一种 行间事件 1、需求:用户点击以下这个按钮，弹出一个对话框，对话框上显示: hello world2、JavaScript是一种事件驱动型的编程语言，通常都是在发生某个事件的时候，去执行某段代码。其中事件包括很多，例如:鼠标单击事件click，另外还有其它事件，例如:mouseover是鼠标经过事件等。并且在JavaScript当中任何一个事件都有对应的事件句柄。例如: click对应的事件句柄是onclick, mouseover对应的事件句柄是onmouseover。3、所有的事件句柄都是以标签的属性形式存在。例如以下input button就有一个onclick这样属性。只要有用户点击了以下的这个按钮对象，此时按钮对象上发生了鼠标单击事件，那么注册在onclick事件句柄当中的s代码会被执行! onclick后面代码实际上是浏览器负责执行的。4、onclick&#x3D;”后面的代码”并不是在浏览器打开的时候执行，浏览器打开的时候，只是将这个代码注册给onclick事件句柄了。等待该按钮的click事件发生，只要发生，后面代码会被事件监听器调用。5、怎么使用Js代码弹窗?在s当中有一个内置的BOM对象，可以直接拿来使用，全部小写: window其中window对象有一个方法&#x2F;函数叫做alert，这个函数专门用来弹出对话框!6、 window .alert( ‘ hello world! ‘);弹窗的s代码。通过这个代码可以知道:Js中的字符串可以使用单引号括起来，也可以使用双引号。s中的一条语句可以“;”结尾，也可以不以“;”结尾。 html123456&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;点我1&quot; onclick=&quot;window.alert(&#x27;hello word&#x27;)&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;点我2&quot; onclick=&quot;window.alert(&#x27;hello world&#x27;)window.alert(&#x27;哼&#x27;)window.alert(&#x27;啊啊啊啊啊啊啊&#x27;)&quot;/&gt;&lt;/body&gt; 第二种 脚本块html1234567891011121314151617181920212223&lt;script&gt;//可任意位置alert(&#x27;hello start&#x27;);&lt;/script&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;嵌入JS第二种方式，脚本块&lt;/title&gt;&lt;script&gt;/*可任意位置*///从上往下依次执行alert(&#x27;hello world&#x27;); alert(&#x27;hello zhangsan&#x27;); alert(&#x27;hello lisi&#x27;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt;alert(&#x27;hello end&#x27;);&lt;/script&gt;&lt;/html&gt; 第三种 引入外部独立文件html12src的=后面不能有空格&lt;script type=&quot;text/javascript&quot; src =&quot;路径&quot;&gt;&lt;/script&gt; 函数初步语法格式：html12345678910111213JavaScript语法格式function 函数名(形式参数列表)&#123; 函数体;&#125;例如:function sum(a, b)&#123; return a + b;&#125;函数名:sum形式参数列表是:a和bJs中的函数返回值类型是不需要指定的,因为可以返回任何类型的数据,没有限制 函数调用html12345678910111213141516//函数必须手动调用才会执行//且函数声明优先级高，打开网页时先声明函数，因此调用顺序可写在函数前面//调用sum函数sum(true,1); //语法松散//编写函数function sum(x, y)&#123; alert(x + &quot;,&quot; + y);&#125;//调用sum函数sum();//调用sum函数sum(1);//调用sum函数sum(1,2);//调用sum函数sum(1,2,3); 声明html123456789101112131415//第一种声明方式function mysum1(a, b)&#123; return a + b;&#125;//调用函数mysum1(10,20)//第二种声明方式mysum2 = function(a, b)&#123; return a + b;&#125;//调用函数var result = mysum2(10,20);alert(result) 重载 后浪推前浪，前浪死在沙滩上 调试 关于JS的的调试?首选方案是: alert(),在程序的某个位置先使用alert弹出某个变量的值,看看是否是你需要的,通过alert可以调试Js代码.另外一种方案是:采用浏览器自带的调试插件:F12F12这个插件中比较重要的面板:控制台查看器网络掌握以上三个面板!!! 变量 js的变量怎么声明? var 变量名; var i; 怎么赋值? 变量名 &#x3D; 值; 一行上能声明多个变量吗? var &#x3D; a,b,c&#x3D;300;声明3个变量, a,b,c,并且c赋值300，其中a和b变量没有赋值，系统默认赋值undefinedundefined在JS中是一个具体的值,这个值就是undefined 重点:Js语言是一种弱类型语言，没有编译阶段，直接浏览器打开解释执行， 在js中声明变量时不需要指定变量的数据类型， 程序在运行过程当中，赋什么类型的值,变量就是什么数据类型, 并且变量的数据类型是可变的。var i;i &#x3D; 100; 到这里i是整数型i &#x3D; false;到这里i就是布尔类型了i &#x3D; 3.14;i &#x3D; new 0bject();遵循就近原则，注意： 函数体中声明的变量称为局部变量，当函数体中的局部变量没有声明且赋值了 则作为全局变量，没有赋值则报错 数据类型 关于JS的数据类型1、JS中声明变量不需要指定变量数据类型呀，为什么还要学习数据类型呢?例如: var i &#x3D; 100; var d &#x3D; 3.14;在Js中学习数据类型也不是为了声明变量，是为了理解s程序的底层原理。我们起码要知道100是什么类型，3.14是什么类型，怎么存储的…. 2、ES6之前JS的数据类型包括6种: Undefined Null Number Boolean String Object 其中:Undefined、Number、String、Boolean、Null都属于原始类型（或者叫做基本数据类型)其中:object属于引用数据类型(或者叫做对象类型) 3、在ES6之后引入了其它新的类型，知道就行: Symbol BigInt注意:Es6之后是8种类型。Es6之前是6种类型。 4、 typeof运算符返回值（非常重要) “undefined” “number” “string” “boolean” “object” “function”并且以上6个字符串都是全部小写的! 5、在Js中判断两个字符串是否相等，应该使用“&#x3D;&#x3D;”,JS中没有equals函数! ! ! 练习 html1234567891011&lt;script type=&quot;text/javascript&quot;&gt;function m(x , y)&#123; var z = x+y; o = 1; alert(z)&#125;//记得关闭百度药丸var d = null;console.log(typeof o);//没有声明的o返回的类型undefinedconsole.log(typeof d)//null返回的类型object&lt;/script&gt; Undefined类型 只有一个值，值就是：undefined 当一个变量没有手动赋值，系统默认赋值undefined Null类型html12345678910/*Null类型1.null类型也属于原始类型3.Null类型只有一个值：null3.typeof null 运算结果是&quot;object&quot;*/var i = null;var j ;console.log(typeof i);//objectconsole.log(typeof j);//undefined Number类型 1、Number类型属于原始类型。2、Number类型特殊的值: NaN Infinity 3、 NaN?&amp;nbsp;&amp;nbsp; Not a Number，表示不是一个数字。但NaN是一个值。它属于Number类型。4、什么情况下结果是一个NaN?&amp;nbsp;&amp;nbsp; 当一个数学表达式的运算结果本应该返回一个数字，但是最终无法返回一个数字的时候，结果是NaN。例如100&#x2F;string5、Infinity是无穷大，当除数是e的时候，最终计算结果是无穷大。例如100&#x2F;06、强调:&amp;nbsp;&amp;nbsp; JavaScript当中的Number类型代表了java中的基本数据类型:&amp;nbsp;&amp;nbsp; byte、short 、int 、 long、float 、double、 html1234567891011121314151617&lt;script&gt;/*Number类型1.NaN和Infinity2.相当于java中基本数据类型*/var k =NaN;console.log(typeof k);//&quot;number&quot;var result = 100/&quot;中&quot;;console.log(result);//&quot;NaN&quot;var v = Infinity;console.log(typeof v);//&quot;number&quot;var retVale = 100/0;console.log(retVale);//Infinity&lt;/script&gt; 7、在Number类型这一块，有一个函数叫做:isNaN()函数，这个函数最终返回布尔类型，返回true表示不是一个数字，返回false表示是一个数字。(双重否定) isNaN : is Not a Numbertrue:表示不是一个数字,返回false表示是一个数字,这个函数有一个特点，它会首先尝试将“数据”转换成数字，如果转换失败了，则结果就是true。转换为数字成功了，那么结果就是false。 8、在Number类型这一块还有一个函数叫做:Number()函数，这个函数的作用是可以将不是数字类型的数据转换成数字类型的数据。 html1234567891011function sum(x,y)&#123; if(isNaN(x)||isNaN(y))&#123;//只要存在一个ture就表示参数里有非数字 alert(&quot;参与求和数据必须都是数字&quot;)&#125;else&#123; alert(Number(x)+Number(y)) &#125;&#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;sum&quot; onclick=&quot;sum(true,100)&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;sum&quot; onclick=&quot;sum(&#x27;中国&#x27;,100)&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;sum&quot; onclick=&quot;sum(&#x27;123&#x27;,100)&quot;&gt; 9、parseInt()函数，将字符串数字转换成数字，并且取整。向下取整。10、Math.ceil()，这是一个Math工具类中的一个函数，向上取整。 null undefined NaN 的区别？html1234567891011121314151617181920212223242526272829303132/* 1. == 和 === 有什么区别？ == 等同运算符，只比较值是否相等。 === 全等运算符，既比较值也比较数据类型是否相等 2. null undefined NaN 的区别？ 类型都是不一样的，null和undefined是值等同关系*///== 和 === 区别var v1 = true;var v2 = 1;console.log(v1 == v2);//trueconsole.log(v1 === v2);//falsevar v3 = 1;condole.log(v2 === v3);//true//null undefined NaN 的区别//类型比较console.log(typeof null)// &quot;object&quot;console.log(typeof NaN)//&quot;number&quot;console.log(typeof undefined)//&quot;undefined&quot;//==比较console.log(null == NaN)//falseconsole.log(undefined == NaN)//falseconsole.log(null == undefined)//true//===比较console.log(null === NaN)//falseconsole.log(null === undefined)//falseconsole.log(undefined === NaN)//false Boolean类型 1、Boolean类型属于原始类型。2、Boolean类型只有两个值:true,false，没有其他值。3、Boolean类型中有一个函数:Boolean()函数，这个函数的作用是?&amp;nbsp;&amp;nbsp;&amp;emsp;将不是布尔类型的转换成布尔类型。&amp;nbsp;&amp;nbsp;&amp;emsp;转换规律是什么?&amp;nbsp;&amp;nbsp;&amp;emsp;“只要有东西” 结果就是true。同时这个函数会被js隐式调用 html1234567891011121314151617181920212223/*Boolean类型*/console.log(Boolean(1));//trueconsole.log(Boolean(0));//falseconsole.log(Boolean(&quot;字符串&quot;));//trueconsole.log(Boolean(&quot;&quot;));//falseconsole.log(Boolean(Infinity));//trueconsole.log(Boolean(NaN));//falseconsole.log(Boolean(new Object()));//trueconsole.log(Boolean(null));//falseconsole.log(Boolean(undefined));//false//Boolean()函数隐式调用var i = 10;while(i)&#123;//这里相当于Boolean(i) alert(i); i--;&#125; String类型 1、string类型属于原始类型（基本数据类型)2、在JS中怎么定义字符串，包括两种方式: var s &#x3D;”字符串”;var s &#x3D;’字符串’; var s &#x3D; new String(“字符串”); 3、在JS当中提供了创建字符串的两种方式:如果采用这种方式创建的字符串就属于原始类型!var s &#x3D; “hello” ;如果采用这种方式创建的字符串就属于object类型，这里使用了object类的子类String,String类是JS内置的，可以直接使用:var s&#x3D;new String( “hello”);4、在JS中不管是原始类型的字符串，还是object类型的字符串，他们的方法和属性都是通用的。5、String当中的常用属性和方法:常用属性: length 属性 获取字符串长度常用方法: charAt() 获取指定下标位置的字符concat() 连接字符串indexOf() 获取某个字符串在当前字符串中第一次出现处的索引lastIndex0f() 获取某个字符串在当前字符串中最后一次出现处的索引replace方法替换split() 拆分字符串substr(startIndex,length) 截取字符串substring(startIndex,endIndex) 截取字符串,不包括endIndextoLowerCase() 转小写toUpperCase() 转大写 html1234567891011121314151617181920212223242526272829303132/*String类型*///两种方式var s1 = &quot;hello&quot;;console.log(typeof s1);//Stringvar s2 = new String(&quot;hello&quot;);console.log(typeof s2);//Object//常用方法练习console.log(&quot;abcdef.length&quot;);//6console.log(&quot;http://www.baidu.com&quot;.charAt(3))//pconsole.log(&quot;abc&quot;.concat(&quot;def&quot;));//abcdefconsole.log(&quot;username=zhangsan&amp;password=123&quot;.indexOf(&quot;=&quot;));//8console.log(&quot;username=zhangsan&amp;password=123&quot;.lastIndexOf(&quot;=&quot;));//26console.log(&quot;1980-10-11&quot;.replace(&quot;-&quot;,&quot;,&quot;));//1980,10,11(替换所有需要正则表达式)//拆分字符返回一个数组var arr = &quot;1980-11-12&quot;.split(&quot;-&quot;);//js没有arr[]这种写法for(var i = 0;i &lt; arr.length; i++)&#123; console.log(arr[i])&#125;//对于substr和substring来说，只传一个参数没有区别console.log(&quot;abcdef&quot;.substr(2));//cdefconsole.log(&quot;abcdef&quot;.substring(2));//cdef//传两个参数//substr(startIndex,length)console.log(&quot;abcdef&quot;.substr(2,3));//cde//substring(startIndex,endIndex),不包括endIndexconsole.log(&quot;abcdef&quot;.substring(2,3));//c object类型: 1、在js当中内置了一个类型object，可以将object类型看做是所有对象的超类&#x2F;基类。2、在Js当中默认定义的类型，没有特殊说明的话，默认继承object。3、Object类型中有哪些通用属性和方法呢?属性:prototype 属性| constructor 属性方法:toLocalestring 方法| toString 方法│ valueof 方法重点掌握:prototype属性。(prototype翻译为原型）这个属性可以给对象动态扩展属性和方法。 html123456789101112131415161718192021222324/* Object类型*/var obj = new Object();console.log(typeof obj);//prototype属性//给Object类型的对象扩展一个doSome()方法Object.prototype.doSome = function()&#123;console.log(&quot;测试prototype属性&quot;)&#125;//给Object类型的对象扩展一个userName属性Object.prototype.userName = &quot;zhangsan&quot;;//调用方法和属性obj.doSome();//测试prototype属性console.log(obj.userName);//zhangsan//给String扩展方法String.prototype.mysubstr = function(startIndex,length)&#123; return this.substr(startIndex,length);&#125;console.log(&quot;abcdef&quot;.mysubstr(2,3));//cdeconsole.log(&quot;kingsoft&quot;.mysubstr(3,3));//gso 类 1、在JS中怎么定义类?包括两种方式 html123456789101112131415161718192021222324252627282930313233343536373839404142第一种方式:function类名(形式参数列表&#123; this.属性名=参数; this.属性名=参数; this.方法名 = function()&#123; &#125;&#125;第二种方式:类名= function(形式参数列表)&#123; this.属性名=参数; this.属性名=参数; this.方法名 = function()&#123; &#125;&#125;//可以看出类和函数的定义方式相同，也就是说既是一个函数,同时又是一个类的定义,函数名是:sayHello,类名是:sayHello/*function sayHello()&#123;&#125; */sayHello = function()&#123;&#125;//关键看你怎么调用,如果没有使用new运算符调用,表示普通函数调用.不会在堆中new对象sayHello( );//使用new运算符去调用这个函数,显然是把它当做一个类来看待,这个会导致浏览器的堆当中开辟一个新对象!var obj = new sayHello(); //obj是一个引用,保存内存地址指向对象!var obj2 = new sayHello();&lt;script type=&quot;text/javascript&quot;&gt; //创建员工类 function Emp(id,name)&#123; this.id = id; this.name = name; this.working = function()&#123; console.log(this.name + &quot;正在工作&quot;) &#125; alert(&#x27;ddd&#x27;); &#125; var e1 = new Emp(1,&#x27;as&#x27;); e1.working();//调用方法 Emp(2,3);//也可直接当方法调用，就很怪 console.log(&quot;e1.id=&quot; + e1.id);//调用属性 //属性还可以这样调用，语法：引用名[&quot;属性名&quot;] console.log(&quot;e1.id=&quot; + e1[&quot;id&quot;]);&lt;/script&gt; 事件 常用事件： blur&amp;emsp;去焦点 focus&amp;emsp;获得焦点 click&amp;emsp;鼠标单击 dblclick&amp;emsp;鼠标双击 keydown&amp;emsp;键盘按下 keyup&amp;emsp;键盘弹起 mousedown&amp;emsp;鼠标按下 mouseover&amp;emsp;鼠标经过 mousemove&amp;emsp;鼠标移动 mouseout&amp;emsp;鼠标离开 mouseup&amp;emsp;鼠标弹起 submit&amp;emsp;表单提交 reset&amp;emsp;表单重置 select&amp;emsp;文本被选定 change&amp;emsp;下拉列表选中项改变,或文本框内容改变 load&amp;emsp;页面加载完毕工 事件测试 点击显/隐内容 html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;/script&gt;1.测试失去焦点事件:&lt;input type=&quot;text&quot; onblur=&quot;console.log(&#x27;失去焦点了&#x27;)&quot;&gt;&lt;br&gt;2.测试获得焦点事件:&lt;input type=&quot;text&quot; onfocus=&quot;console.log(&#x27;获取焦点了&#x27;)&quot;&gt;&lt;br&gt;3.测试鼠标单击事件:&lt;input type=&quot;text&quot; onclick=&quot;console.log(&#x27;鼠标单机了&#x27;)&quot;&gt;&lt;br&gt;4.测试鼠标双击事件:&lt;input type=&quot;text&quot; ondblclick=&quot;console.log(&#x27;鼠标双击了&#x27;)&quot; /&gt;&lt;br&gt;5.测试键盘按下事件:&lt;input type=&quot;text&quot; onkeydown=&quot;console.log(&#x27;键盘按下了&#x27;)&quot; /&gt;&lt;br&gt;6.测试键盘弹起事件:&lt;input type=&quot;text&quot; onkeyup=&quot;console.log(&#x27;键盘弹起了&#x27;)&quot; /&gt;&lt;br&gt;7.测试鼠标按下事件:&lt;span id=&quot;mouse&quot; onmousedown=&quot;console.log(&#x27;鼠标按下了&#x27;)&quot;&gt;鼠标测试区域&lt;/span&gt;&lt;br&gt;8.测试鼠标经过事件:&lt;span id=&quot;mouse&quot; onmouseover=&quot;console.log(&#x27;鼠标经过了&#x27;)&quot;&gt;鼠标测试区域&lt;/span&gt;&lt;br&gt;9.测试鼠标移动事件:&lt;span id=&quot;mouse&quot; onmousemove=&quot;console.log(&#x27;鼠标在移动&#x27;)&quot;&gt;鼠标测试区域&lt;/span&gt;&lt;br&gt;10.测试鼠标离开事件:&lt;span id=&quot;mouse&quot; onmouseout=&quot;console.log(&#x27;鼠标离开了&#x27;)&quot;&gt;鼠标测试区域&lt;/span&gt;&lt;br&gt;11.测试鼠标弹起事件:&lt;span id=&quot;mouse&quot; onmouseup=&quot;console.log(&#x27;鼠标弹起了&#x27;)&quot;&gt;鼠标测试区域&lt;/span&gt;&lt;br&gt;鼠标事件结合:&lt;div id=&quot;mouse&quot; onkeyup=&quot;console.log(&#x27;键盘弹起了&#x27;)&quot;onmousedown=&quot;console.log(&#x27;鼠标按下了&#x27;)&quot;onmouseover=&quot;console.log(&#x27;鼠标经过了&#x27;)&quot;onmousemove=&quot;console.log(&#x27;鼠标在移动&#x27;)&quot;onmouseout=&quot;console.log(&#x27;鼠标离开了&#x27;)&quot;onmouseup=&quot;console.log(&#x27;鼠标弹起了&#x27;)&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt; 12.测试表单提交和重置事件:&lt;form onsubmit=&quot;console.log(&#x27;表单提交了&#x27;)&quot; onreset= &quot;(console.log(&#x27;表单重置了&#x27;))&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;&lt;/form&gt;&lt;br&gt;14.测试文本被选定事件:&lt;br&gt;&lt;textarea rows=&quot;1&quot; cols=&quot;30&quot; onselect=&quot;console.log(&#x27;文本被选中了&#x27;)&quot;&gt;&lt;/textarea&gt;&lt;br&gt;&lt;input type=&quot;text&quot; onselect=&quot;console.log(&#x27;文本被选中了&#x27;)&quot;&gt;&lt;br&gt;15.测试下拉列表选中项改变,或文本框内容改变事件:&lt;select onchange=&quot;console.log(&#x27;选项被修改！&#x27;)&quot;&gt;&lt;option value=&quot;&quot;&gt;--请选择你的爱好&lt;/option&gt;&lt;option value=&quot;gz&quot;&gt;唱&lt;/option&gt;&lt;option value=&quot;gz&quot;&gt;跳&lt;/option&gt;&lt;option value=&quot;gz&quot;&gt;rap&lt;/option&gt;&lt;option value=&quot;gz&quot;&gt;篮球&lt;/option&gt;&lt;/select&gt;&lt;/body&gt; 事件测试截图 注册事件的第一种方式 在标签中使用”事件句柄”，在事件句柄后面编写JS代码当这个事件句柄对应的事件发生之后，注册在事件句柄当中的这个代码被监听器调用。即onclick鼠标单击的事件句柄，只有当鼠标单击事件click发生之后，注册在onclick后面的代码会被执行。下面的button标签中的sayHello()函数，在页面打开的时候并不会执行，只是在页面打开的过程中完成事件的绑定，完成事件的注册，以后只有当该事件发生之后sayHello()函数才会执行，像这种函数有一种特殊的称谓:回调函数。英语单词叫做: callback function这个回调函数的特点是: 监听器负责调用，程序员不负责调用。 当事件发生之后，监听器会负责调用该函数。 html1&lt;input type=&quot;button&quot; value=&quot;hello jack&quot; onclick=&quot;sayHello()&quot;/&gt; 获取节点 在学习第二种方式前得先知道如何根据id获取元素&#x2F;节点对象 在JS当中有一个内置的隐含的对象叫做:document document代表整个HTML文档document对象是DoM的顶级对象, DoM中的老大 在Js当中有一个内置的隐含的对象叫做:window window代表整个浏览器窗口window对象是Bon的顶级对象,BOM中的老大 严格意义上来说, window是包含document的其中document有一个函数可以通过id获取节点：getElementById（）var mybtnElt &#x3D; document.getElementById(“mybtn”);获取节点后可以对其属性进行操作，这自然也包括了回调函数 JS注册事件的第二种方式html1234567891011121314151617181920&lt;input type=&quot;button&quot; value=&quot;hello&quot; id=&quot;hellobtn&quot;/&gt;&lt;script type=&quot;text/javascript&quot;&gt;//定义一个函数 function sum()&#123; console.log( &quot;sum function invoke! &quot;)&#125;//根据id获取button对象var hellobtnElt = document.getElementById(&quot;hellobtn&quot;);//元素中有什么属性,就能&quot;点&quot;什么.//这行代码在页面打开的时候会执行，这行代码执行的意义是:将sum这个回调函数绑定到hellobtn的click事件上//这个回调函数sum在什么时候执行? click事件发生之后才会被监听器调用!hellobtnElt.onclick = sum//不要这样写:hellobtnElt.onclick = sum()//回调函数可以是一个匿名函数//这行代码的执行只是完成事件click的注册,给click事件注册一个回调函数//执行到这的时候，回调函数并不会被执行。//只有当这个按钮发生click事件之后,这个回调函数会自动被监听器来调用hellobtnElt.onclick = function( )&#123; console.log(&quot;我是一个回调函数，同时我没有名字，叫做匿名函数! &quot;)&#125;&lt;/script&gt; 代码执行顺序1.代码执行顺序问题引出html123456789&lt;script&gt; //报错Uncaught TypeError: Cannot set properties of null (setting &#x27;onclick&#x27;) //id为null，代码还没执行到下面 var btnElt = document.getElementById(&#x27;btn&#x27;); btnElt.onclick = function()&#123; console.log(&#x27;按钮被点击，匿名函数被执行&#x27;) &#125;;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;点击&quot; id=&quot;btn&quot;&gt; 2.代码执行顺序问题解决html123456789&lt;script type=&quot;text/javascript&quot;&gt; function s()&#123; var btnElt = document.getElementById(&#x27;btn&#x27;); btnElt.onclick = function()&#123; console.log(&quot;按钮被点击，匿名函数被执行&quot;) &#125; &#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;点击&quot; id=&quot;btn&quot;&gt; 3.代码执行顺序问题优化html1234567891011&lt;script&gt; function test()&#123; console.log(&#x27;hello world&#x27;); &#125;; //可以用body的id来获取body节点，然后给它注册load事件，但代码还是冗余 /* var bd = document.getElementById(&#x27;bodyid&#x27;); bd.onload = test; *///window可以代替body，因此可以把load事件注册（绑定）到window上，等到事件发生之后监听器自动调用 window.onload = test();&lt;/script&gt; 4.代码执行顺序完整案例html123456789101112131415161718192021222324252627&lt;body&gt;&lt;script&gt; window.onload = function()&#123;//注册加载事件，事件触发后由监听器调用回调函数//正常写 /* var b1 = document.getElementById(&#x27;button1&#x27;); b1.onclick = function()&#123;//注册单击事件，事件触发后由监听器调用回调函数 console.log(&#x27;按钮1被单击了&#x27;) &#125; var b1 = document.getElementById(&#x27;button1&#x27;); b2.onclick = function()&#123;//注册单击事件，事件触发后由监听器调用回调函数 console.log(&#x27;按钮2被单击了&#x27;) &#125; *///简写 document.getElementById(&#x27;button1&#x27;).onclick = function()&#123; console.log(&#x27;按钮1被单击了&#x27;) &#125; document.getElementById(&#x27;button2&#x27;).onclick = function()&#123; console.log(&#x27;按钮2被单击了&#x27;) &#125; &#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;按钮1&quot; id=&quot;button1&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;按钮2&quot; id=&quot;button2&quot;&gt;&lt;/body&gt; 捕捉键值html123456789101112&lt;script&gt; window.onload = function()&#123; document.getElementById(&#x27;username&#x27;).onkeydown = function(x)&#123; //事件发生后监听器会调用此函数并传入一个键盘事件对象，这个对象有keyCode属性 //其中值为13代表回车，27代表ESC if(x.keyCode == 13)&#123; console.log(&quot;捕捉到回车键，可以进行相关操作&quot;) &#125; &#125; &#125;&lt;/script&gt;&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; 运算符void 1、和java一样Js当中也有很多运算符算术运算符逻辑运算符关系运算符位运算符三目运算符赋值运算符…2、这里主要学习一下JavaScript当中的void和typeof运算符。 typeof 运算符:可以在程序运行阶段动态获取变量的数据类型，结果有6个字符串:“ number” “undefined” “boolean” “string” “object” “function” void 运算符：语法格式： void(表达式)执行表达式但不返回任何结果 使用场景的话像是设置超链接执行js代码但不跳转，超链接默认空字符串也就是本地地址，需要把地址去掉： html1&lt;a href=&quot;javascript:void(0)&quot; onclick = alert(&#x27;执行js代码&#x27;)&gt;&lt;/a&gt; 控制语句 1、JS中的控制语句，基本和java相同选择结构: if语句 switch 语句循环结构: for while do . .while 转向语句: break continue return 2.除此之外还有两个语句需要了解for…in 和 with JavaScript1234567891011121314151617181920212223242526272829&lt;script&gt; //for..in语句 //在js中数组元素随意 var arr = [true,&quot;abc&quot;,5,false,76,3.14] //用for..in语句遍历数组 for(var ddddd in arr)&#123; console.log(arr[ddddd]); &#125;; //用for..in遍历对象 Emp = function(id,name)&#123; this.id = id; this.name = name; &#125; var e = new Emp(1,&#x27;张三&#x27;); for(var suiyi in e)&#123; console.log(typeof suiyi);//String //这里不能用e.suiyi方式调用了，因为随意是字符串，所以用第二种方式对象名[&quot;属性名&quot;] console.log(e[suiyi])//第一次输出1，第二次张三 &#125; //whit语句 var x = new Emp(2,&quot;jack&quot;) with(x)&#123;//可直接调用了，有点鸡肋 console.log(id +&quot;,&quot; + name); console.log(id +&quot;,&quot; + name); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS内置对象ArrayJavaScript123456789101112131415161718192021222324252627//创建数组的第一种方式var arr = [true,&quot;abc&quot;,5,false,76,3.14];//创建数组的第二种方式var arr1 = new Array();//创建长度为0的数组var arr2 = new Array();//创建长度为3的数组var arr3 = new Array(1,53,532,2);//Array常用函数//1.push 添加元素到末尾//2.pop 取出末尾元素//push和pop联合起来，实际是模拟了栈数据结构a = [1,2,3];a.push(false);for(var i in a)&#123; console.log(a[i])&#125;console.log(a.length);//4console.log(a.pop());//falseconsole.log(a.length);//3//3.reverse翻转数组//4.join将每个元素以指定内容连接成一个字符串var array = [1,3,65,345,5467];array.reverse();//翻转for(var i in array)&#123; console.log(array[i])&#125;var str = array.join(&quot;-&quot;);console.log(str);//5467-345-65-3-1 Datehtml1234567891011121314151617181920212223242526&lt;script type=&quot;text/javascript&quot;&gt;/*JS的内置对象:Date*/var time = new Date();//获取系统当前时间console.log(time)//(中国标准时间)//进行格式转换将所有时间信息都拿出来var year = time.getFullYear();//年var month = time.getMonth(); //月var day = time.getDate(); //日var week = time.getDay();//星期几var hour = time.getHours()//时var minutes = time.getMinutes()//分var seconds = time.getSeconds()//秒var millis = time.getMilliseconds()//毫秒console.log(year + &quot;年&quot; +(month + 1) +&quot;月&quot; + day + &quot;日&quot;)//获取时间戳var now = new Date();var timeMillis = now.getTime();console.log(timeMillis);//Object中有一个函数toLocaleString()，可以将时间转换成具有本体语言环境的日期格式var strTime = time.toLocaleString();console.log(strTime);&lt;/script&gt; jsonhtml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;/*json存在的意义？实现不同语言的数据交互概念：json是一种数据格式，本质是字符串eval函数：可以将json字符串解释转成json对象json对象：语法格式为(键:值,键:值...),其中值为任意内容(json对象,集合,字符串...)java和javascript两个语言怎么交换数据?获取：java的JDBC连接数据库查询数据，然后将数据拼接成json格式的字符串传给javascript，转换：然后在javascript当中把json格式的字符串转换成json对象，操作：可以从json对象中取数据了，这样就完成了数据的交换。练习json+eval+innerHTML完成对节点的操作想到的问题：1.用console.log(typeof jsObj.total)这个语句查看了jsObj对象的total属性是number类型，那么我设置记录数那块用的是innerText，后面是字符串拼接没啥问题，但我测试font.innerText = jsObj.total ;这样也能通过，后面可以跟number类型吗？好吧，查了一下 innerText后面的字符串即使是一个HTML代码,也不会当做HTML执行,只是看做普通文本.2.json字符串的真实获取方式？1)使用 Ajax 方式获取2)使用 getJSON 方式获取*///三步走： 获取数据--&gt;数据转成json对象--&gt;操作对象//1.接收json字符串var jsonStr = &quot;&#123;\\&quot;total\\&quot;:3,\\&quot;student\\&quot;:[&#123;\\&quot;number\\&quot;:1,\\&quot;name\\&quot;:\\&quot;张三\\&quot;,\\&quot;hobby\\&quot;:\\&quot;唱\\&quot;&#125;,&#123;\\&quot;number\\&quot;:2,\\&quot;name\\&quot;:\\&quot;李五\\&quot;,\\&quot;hobby\\&quot;:\\&quot;跳\\&quot;&#125;,&#123;\\&quot;number\\&quot;:3,\\&quot;name\\&quot;:\\&quot;王四\\&quot;,\\&quot;hobby\\&quot;:\\&quot;rap\\&quot;&#125;]&#125;&quot;;//2.转换成json对象eval(&#x27;jsObj =&#x27; + jsonStr);//第一次写的时候把jsonStr拼接到=后面了//3.后面就是对数据的操作了window.onload = function()&#123;//显示学生总记录数//1.获取要交互数据的节点对象fontvar font = document.getElementById(&quot;record&quot;)//2.从获取的jsObj对象取出数据设置给font节点对象font.innerText = &quot;总记录:&quot;+jsObj.total +&quot;条&quot; ;//点击按钮让表格所有记录显示出来//1.获取要交互数据的节点对象tbodyvar tbody = document.getElementById(&#x27;stuBody&#x27;)//2.注册按钮单击事件document.getElementById(&#x27;but&#x27;).onclick = function()&#123;//3.从获取的jsObj对象取出数据设置给tbody节点对象var htmlStr = &#x27;&#x27;;//设置一个拼接字符串for(var i = 0;i &lt; jsObj.student.length;i++)&#123; htmlStr += &quot;&lt;tr&gt;&quot;; htmlStr += &quot;&lt;td&gt;&quot; + jsObj.student[i].number + &quot;&lt;td&gt;&quot; htmlStr += &quot;&lt;td&gt;&quot; + jsObj.student[i].name + &quot;&lt;td&gt;&quot; htmlStr += &quot;&lt;td&gt;&quot; + jsObj.student[i].hobby + &quot;&lt;td&gt;&quot; htmlStr += &quot;&lt;/tr&gt;&quot;;&#125;//4.将拼接好的字符串htmlStr设置给tbody(innerHTML)tbody.innerHTML = htmlStr;&#125;&#125;&lt;/script&gt;&lt;font id=&quot;record&quot;&gt;总记录&lt;/font&gt;&lt;input type=&quot;button&quot; value=&quot;显示所有学生记录&quot; id=&quot;but&quot;&gt;&lt;table ali&gt;&lt;tr&gt;&lt;th&gt;编号&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;爱好&lt;/th&gt;&lt;/tr&gt;&lt;tbody id=&quot;stuBody&quot;&gt;&lt;!-- &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;唱&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;李五&lt;/td&gt;&lt;td&gt;跳&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;王四&lt;/td&gt;&lt;td&gt;rap&lt;/td&gt;&lt;/tr&gt; --&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt; 正则表达式 在js中怎么创建正则表达式对象？之前学过正则,这里主要掌握语法,包括两种方式，重点使用第一种 var regExp &#x3D; &#x2F;正则表达式&#x2F;标记 内置RegExp类：var regExp &#x3D; new RegExp(“正则表达式”,”标记”)其中标记是可选项：g: 全局 globali: 忽略大小写 ignorecasegi:全局扫描且忽略大小写 js的正则表达式对象有一个很重要的函数： regExp.test(“用户输入的字符串”) 返回boolean值 BOM和DOM 区别和联系从功能区分：BOM可以通过对象方法完成对窗口的操作，DOM是对网页中元素的增删改浏览器包含网页，BOM是包含DOM的BOM顶级对象 windowDOM顶级对象 document日常使用中window.document.getElementById()可以省略为document.getElementById() DOMjs获取元素的三种方式html123456789101112131415161718192021&lt;script&gt; window.onload = function()&#123; //1.根据id获取元素 var div1 = document.getElementById(&#x27;div1&#x27;); console.log(div1) //2.根据name属性获取元素 var checkBox = document.getElementsByName(&#x27;hobby&#x27;); console.log(checkBox) //3.根据标签名获取元素 var divs = document.getElementsByTagName(&#x27;div&#x27;) console.log(divs) &#125;&lt;/script&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;3&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;4&quot;&gt;&lt;/body&gt; InnerHTML和InnerText InnerHTML用来设置或获取HTML中元素的内容。InnerText用来设置或获取HTML中元素的文本。 点击显/隐内容 html1234567891011121314151617181920212223242526&lt;style&gt; #div1&#123; background-color: aqua; border : 1px solid red; width: 100px; height: 25px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; window.onload = function()&#123; //给按钮注册鼠标单击事件，监听器检测到后调用该函数并传参（单击事件对象） document.getElementById(&#x27;but&#x27;).onclick = function()&#123; var tx = document.getElementById(&#x27;div1&#x27;) if(tx.innerText == &#x27;&#x27;)&#123; tx.innerHTML = &quot;&lt;font color = &#x27;red&#x27;&gt;不能为空&lt;/font&gt;&quot;; &#125; &#125; &#125;&lt;/script&gt; &lt;div id = &quot;div1&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;tx&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;登录&quot; id=&quot;but&quot;&gt; 复选框的全选和取消 点击显/隐内容 html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function()&#123;//1.全选框对复选框的影响//根据id获取全选框元素var selAll = document.getElementById(&quot;all&quot;);//通过name属性拿到所有复选框对象集合var hobbies = document.getElementsByName(&quot;hobby&quot;);//给全选框注册单击事件，监听器，回调函数selAll.onclick = function()&#123; for(var i = 0; i &lt; hobbies.length; i++)&#123;//遍历复选框对象集合 //即点击全选后所有复选框状态和全选框保持一致 hobbies[i].checked = selAll.checked; &#125; console.log(hobbies.length)&#125;//2.复选框对全选框的影响 for(var i = 0;i&lt;hobbies.length;i++)&#123;//遍历复选框对象集合 ////给每一个复选框注册单击事件 hobbies[i].onclick = function()&#123; //即每个复选框被单击后都要检查其它复选框是否勾选上了并用一个变量记录下来 var checkedCount = 0;/*之前有关checkedCount变量的疑问//1.这个值是共享的吗？2.之后怎么重置为0的？有这个疑问根本在于没理解事件的机制。首先肯定不是共享的，每个复选框的点击事件发生后就指定值为0，这个值用来做记录的，即开始遍历复选框对象集合，通过查看其它复选框的状态并记录，来决定是否要勾上全选框也就是说，三个复选框各自都注册了自己的单击事件，触发事件后由监听器调用各自对应的回调函数也就是说各个复选框的checkedCount值压根没啥关系，且重新调用后自然是给定的值0*///再次遍复选框对象集合？用来在此复选框被点击同时确认其它复选框的状态且记录下来 for(var i = 0; i&lt;hobbies.length;i++)&#123; if(hobbies[i].checked)&#123; checkedCount++;&#125; &#125;//检查完其它复选框状态后，决定全选框的状态 if(checkedCount == hobbies.length)&#123; selAll.checked = true; &#125;else&#123; selAll.checked = false; &#125; &#125;&#125;&#125;&lt;/script&gt;&lt;input type=&quot;checkbox&quot; id=&quot;all&quot; &gt;全选&lt;br&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; /&gt;唱&lt;br&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;/&gt;跳&lt;br&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;/&gt;rap&lt;/body&gt; 获取文本框和下拉列表的值html1234567891011121314151617181920212223242526272829303132文本框的值&lt;body&gt; &lt;script&gt; window.onload = function()&#123; document.getElementById(&#x27;but&#x27;).onclick = function()&#123; var t = document.getElementById(&#x27;text1&#x27;); alert(t.value); &#125; &#125; &lt;/script&gt; &lt;input type=&quot;text&quot; id=&quot;text1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;获取文本框信息&quot; id=&quot;but&quot;&gt;&lt;/body&gt;下拉列表的值&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; document.getElementById(&#x27;pr&#x27;).onchange = function()&#123; //this代表change事件发生的节点对象 console.log(this.value) &#125; &#125; &lt;/script&gt; &lt;select name=&quot;province&quot; id=&quot;pr&quot;&gt; &lt;option value=&quot;&quot;&gt;--选择下拉列表--&lt;/option&gt; &lt;option value=&quot;001&quot;&gt;山东&lt;/option&gt; &lt;option value=&quot;002&quot;&gt;山西&lt;/option&gt; &lt;option value=&quot;003&quot;&gt;湖南&lt;/option&gt; &lt;option value=&quot;004&quot;&gt;湖北&lt;/option&gt; &lt;/select&gt;&lt;/body&gt; 拼接html的方式，设置table的tbody 详情查看 点击跳转 表单验证 点击显/隐内容 html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;body&gt;&lt;script&gt;/* 表单验证 (1)用户名不能为空 (2)用户名必须在6-14位之间 (3)用户名只能有数字和字母组成，不能含有其它符号（正则表达式) (4)密码和确认密码一致 (5)统一失去焦点验证 (6)错误提示信息统一在span标签中提示，并且要求字体12号，红色。 (7)文本框再次获得焦点后，清空错误提示信息 (8)最终表单中所有项均合法方可提交 根据要求可知： 1.blur失去焦点验证 2.focus获得焦点清除提示信息 3.表单提交验证 注意这里没考虑全空的情况,那样得封装验证方法 会用到的函数 userNameVal.trim() 去除字符串前后空格 form节点.submit(); 提交表单*/window.onload = function()&#123; var userName = document.getElementById(&#x27;userName&#x27;) //1.失去焦点开始验证 //用户名验证 userName.onblur = function()&#123; //获取用户名值 var userNameVal = userName.value; //去除前后空串 var userNameStr = userNameVal.trim() //验证格式，过关斩将 regExp = /^[a-z0-9]&#123;4,16&#125;$/;//这个同时判断了长度和字母数字,但还是按需求吧 if(userNameStr.length == 0)&#123;//为空判断 document.getElementById(&#x27;userNameClassify&#x27;).innerText = &quot;不能为空&quot; &#125;else if(!(userNameStr.length &gt;= 6 &amp;&amp; userNameStr.length &lt;= 16))&#123;//长度判断 document.getElementById(&#x27;userNameClassify&#x27;).innerText = &quot;用户名长度为6~16&quot; &#125;else if(!(regExp.test(userNameStr)))&#123;//符号判断，正则 document.getElementById(&#x27;userNameClassify&#x27;).innerText = &quot;用户名只能是字母和数字&quot; &#125; &#125; //密码验证 var password = document.getElementById(&#x27;passWord&#x27;); password.onblur = function()&#123; var passStr = password.value; if(passStr.length == 0)&#123; document.getElementById(&#x27;userPasswordClassify&#x27;).innerText = &quot;不能为空&quot; &#125; &#125; //重复密码验证 var password1 = document.getElementById(&#x27;passWord1&#x27;); password1.onblur = function()&#123; var passStr1 = password1.value; if(passStr1 != password.value)&#123; document.getElementById(&#x27;userPasswordClassify1&#x27;).innerText = &quot;和原密码不一致&quot; &#125; &#125; //2.获取焦点清空之前的错误信息 userName.onfocus = function()&#123;//清空用户名提示 document.getElementById(&#x27;userNameClassify&#x27;).innerText = &quot; &quot;; &#125; password.onfocus = function()&#123;//清空密码提示 document.getElementById(&#x27;userPasswordClassify&#x27;).innerText = &quot; &quot;; &#125; password1.onfocus = function()&#123;//清空重复密码提示 document.getElementById(&#x27;userPasswordClassify1&#x27;).innerText = &quot; &quot;; &#125; //3.表单提交验证 var button = document.getElementById(&#x27;button&#x27;); button.onclick = function()&#123; //这里的验证没有重写一遍，那样的话最好把验证封装成一个方法,这里换种思路 //户鼠标离开焦点的时候会进行验证， //那么只需要自动触发blur事件,且span提示信息为空即可。 //用户名验证 document.getElementById(&#x27;userName&#x27;).focus;//先获取焦点才能失去焦点 document.getElementById(&#x27;userName&#x27;).blur; //密码验证 document.getElementById(&#x27;passWord&#x27;).focus; document.getElementById(&#x27;passWord&#x27;).blur; //重复密码验证 document.getElementById(&#x27;passWord1&#x27;).focus; document.getElementById(&#x27;passWord1&#x27;).blur; if(document.getElementById(&#x27;userNameClassify&#x27;).value != null)&#123; alert(&#x27;用户名有误&#x27;); &#125;else if(document.getElementById(&#x27;userPasswordClassify&#x27;).value != null)&#123; alert(&#x27;密码有误&#x27;); &#125;else if(document.getElementById(&#x27;userPasswordClassify1&#x27;).value != null)&#123; alert(&#x27;重复密码有误&#x27;); &#125;else&#123; var formObj = document.getElementById(&quot;userForm&quot;); formObj.submit(); alert(&#x27;提交成功&#x27;) &#125; &#125; &#125; &lt;/script&gt;&lt;form action=&quot;&quot; id=&quot;userForm&quot;&gt;&lt;!--用户名--&gt;用户名&lt;input type=&quot;text&quot; id=&quot;userName&quot; name=&quot;userName&quot;&gt;&lt;span id=&quot;userNameClassify&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;!--密码--&gt;密码&lt;input type=&quot;password&quot; id=&quot;passWord&quot; name=&quot;passWord&quot;&gt;&lt;span id=&quot;userPasswordClassify&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;!--确认密码--&gt;确认密码&lt;input type=&quot;text&quot; id = &quot;passWord1&quot;&gt;&lt;span id=&quot;userPasswordClassify1&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;!--提交按钮--&gt;&lt;input type=&quot;button&quot; id=&quot;button&quot; value=&quot;注册&quot;&gt;&lt;/form&gt;&lt;/body&gt; BOM开启和关闭窗口html1234567891011121314151617181920212223&lt;body&gt; &lt;!-- window.open(url,target) --&gt; &lt;!--默认新窗口打开--&gt; &lt;input type=&quot;button&quot; value=&quot;默认新窗口打开百度&quot; onclick=&quot;window.open(&#x27;http://www.baidu.com&#x27;)&quot;&gt; &lt;!--_block新窗口打开--&gt; &lt;input type=&quot;button&quot; value=&quot;新窗口打开百度&quot; onclick=&quot;window.open(&#x27;http://www.baidu.com&#x27;,&#x27;_block&#x27;)&quot;&gt; &lt;!--_self本页窗口打开--&gt; &lt;input type=&quot;button&quot; value=&quot;本页窗口打开百度&quot; onclick=&quot;window.open(&#x27;http://www.baidu.com&#x27;,&#x27;_self&#x27;)&quot;&gt; &lt;!--_parent父窗口打开--&gt; &lt;input type=&quot;button&quot; value=&quot;父窗口打开百度&quot; onclick=&quot;window.open(&#x27;http://www.baidu.com&#x27;,&#x27;_parent&#x27;)&quot;&gt; &lt;!--_top顶级窗口窗口打开--&gt; &lt;input type=&quot;button&quot; value=&quot;顶级窗口打开百度&quot; onclick=&quot;window.open(&#x27;http://www.baidu.com&#x27;,&#x27;_top&#x27;)&quot;&gt; &lt;!--在新窗口打开本地文件窗口--&gt; &lt;input type=&quot;button&quot; value=&quot;localFile&quot; onclick=&quot;window.open(&#x27;2-关闭窗口.html&#x27;)&quot;&gt;&lt;/body&gt;&lt;body&gt;点击关闭窗口&lt;input type=&quot;button&quot; value=&quot;close&quot; onclick=&quot;window.close()&quot;&gt;&lt;/body&gt; alert和confirmhtml12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function del()&#123;alert if(window.confirm(&quot;确认删除？&quot;))&#123; alert(&#x27;正在删除中&#x27;) &#125; &#125; &lt;/script&gt; &lt;input type=&quot;button&quot; value=&quot;delete&quot; onclick=&quot;del()&quot;&gt; &lt;/body&gt;&lt;/html 子级窗口设置为顶级窗口html12345678910111213141516171819&lt;body&gt; 这是顶级窗口&lt;br /&gt; &lt;iframe src=&quot;2.2子级窗口.html&quot; width=&quot;500px&quot; height=&quot;500px&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;body&gt; 这是子级窗口 &lt;script&gt; function setTop()&#123; if (window.top != window.self)&#123; window.top.location = window.self.location; &#125; &#125; &lt;/script&gt; &lt;input type=&quot;button&quot; value=&quot;如果当前窗口不是顶级窗口的话，将当前窗口设置为顶级窗口&quot; onclick=&quot;setTop()&quot; /&gt;&lt;/body&gt; 历史记录 第一页 html123456&lt;body&gt; &lt;a href=&quot;4.2-历史记录.html&quot;&gt;测试链接&lt;/a&gt; &lt;input type=&quot;button&quot; value=&quot;刷新&quot; onclick=&quot;window.location.reload()&quot;/&gt; &lt;input type=&quot;button&quot; value=&#x27;前进&#x27; onclick=&quot;window.history.go(1)&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;前进&quot; onclick=&quot;window.history.forward()&quot;/&gt; &lt;/body&gt; 第二页 html123456&lt;body&gt; &lt;input type=&quot;button&quot;value=&quot;刷新&quot; onclick=&quot;window.location.reload()&quot;/&gt; &lt;input type=&quot;button&quot;value=&quot;后退&quot; onclick=&quot;window.history.go(-1)&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;后退&quot; onclick=&quot;window.history.back()&quot;/&gt; &lt;input type=&quot;button&quot;value=&quot;后退刷新&quot; onclick=&quot;window.history.go(-1);window.location.reload()&quot;/&gt; &lt;/body&gt; 客户端发送请求的常见五种方式html123456789101112131415161718192021222324252627&lt;body&gt;&lt;Script&gt; function go()&#123; window.location = &quot;http://www.baidu.com&quot;; &#125; /* &lt;! -- 跳转页面可以通过多种方式:(这些都是发送请求!!! ! ) 第一种方式:直接在浏览器地址栏上写 URL(重点)(get请求) 第二种方式:可以点击超链接(重点)(get请求) 第三种方式:提交form表单(重点)(get或post请求) 第四种方式:window.open(url,target) (了解) 第五种方式:js代码（重点）: window .location.href window.location document.location.hre fdocument.location */&lt;/Script&gt;&lt;input type=&quot;button&quot; value=&quot;跳转&quot; onclick=&quot;go()&quot;&gt;&lt;/body&gt;","categories":[],"tags":[]},{"title":"多用户即时通信系统","slug":"多用户通信系统","date":"2022-09-03T11:16:26.000Z","updated":"2022-09-10T09:24:12.788Z","comments":true,"path":"2022/09/03/多用户通信系统/","link":"","permalink":"http://tanquerayds.site/2022/09/03/%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"为什么选择这个项目 有意思且涉及到各个方面的技术，还可以巩固基础学习新知识知识点包括： 项目框架设计 java面向对象编程 网络编程 多线程 IO流 Mysql&#x2F;（先用集合充当内存数据库） 多用户通信系统思路（第一版）和代码实现 通信结构分为客户端和服务端 服务端验证客户端账号信息和数据传输客户端作为用户可以通过服务器给其它用户发送消息和各类文件数据的传输主要采用对象流的方式，包括用户对象和消息数据包 一、 实现第一个功能，用户登录 客户端，根据用户界面提前创建用户对象和消息数据包，都作为对象数据流来传输。 1）用户这个类包括用户名&#x2F;id,用户密码 点击显/隐内容 java1234567891011121314151617181920212223242526public class User implements Serializable &#123; public static final long serialVersionUID = 1L; private String name;//用户名/id String passWord;//密码 public User(String name, String passWord) &#123; this.name = name; this.passWord = passWord; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassWord() &#123; return passWord; &#125; public void setPassWord(String passWord) &#123; this.passWord = passWord; &#125;&#125; 2）数据包这个类会包含数据类型，数据内容，发送者和接收者，最后还有发送时间 点击显/隐内容 JAVA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Message implements Serializable &#123; public static final long serialVersionUID = 1L; private String content;//发送内容 private String dataType;//数据类型 private String sender;//发送者 private String receiver;//接收者 private String data;//日期，感觉可以用第三代日期类，后面再改 public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public String getDataType() &#123; return dataType; &#125; public void setDataType(String dataType) &#123; this.dataType = dataType; &#125; public String getSender() &#123; return sender; &#125; public void setSender(String sender) &#123; this.sender = sender; &#125; public String getReceiver() &#123; return receiver; &#125; public void setReceiver(String receiver) &#123; this.receiver = receiver; &#125; public String getData() &#123; return data; &#125; public void setData(String data) &#123; this.data = data; &#125;&#125; 3）为了管理数据包的数据类型，再创建个接口来管理 JAVA123456package az.qqServer;public interface MessageType &#123; //在接口中定义常量，表示不同的消息类型 String MESSAGE_LOGIN_SUCCEED = &quot;1&quot;; String MESSAGE_LOGIN_FAIL = &quot;2&quot;;&#125; 4)用户登录界面制作，先把逻辑打通再细写代码 点击显/隐内容 进入二级菜单 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 客户端登入界面 **/public class qqView &#123; public static void main(String[] args) &#123; new qqView().mainView();//测试mainView方法 &#125; private static boolean loop = true;//菜单控制循环 private String key;//用户输入 public void mainView() &#123; while (loop) &#123; System.out.println(&quot;==========欢迎登录网络通信系统=========&quot;); System.out.println(&quot;\\t\\t1 登录系统&quot;); System.out.println(&quot;\\t\\t9 退出系统&quot;); System.out.println(&quot;请输入你的选择:&quot;); key = Utility.readString(1); //根据用户输入来执行操作 switch (key) &#123; case &quot;1&quot;: System.out.println(&quot;请输入你的用户名:&quot;); String userId = Utility.readString(50); System.out.println(&quot;请输入你的密码:&quot;); String passWord = Utility.readString(50); //这里需要到服务端验证是否合法，代码后续补，先通逻辑 if (true) &#123;//假如验证合法，则进入二级菜单 System.out.println(&quot;========欢迎用户&quot; + userId + &quot;===========&quot;); while (loop) &#123; System.out.println(&quot;==========网络通信系统二级菜单（&quot; + userId + &quot;）========&quot;); System.out.println(&quot;\\t\\t1 显示在线用户列表&quot;); System.out.println(&quot;\\t\\t2 群发消息&quot;); System.out.println(&quot;\\t\\t3 私发消息&quot;); System.out.println(&quot;\\t\\t4 发送文件&quot;); System.out.println(&quot;\\t\\t9 退出系统&quot;); System.out.println(&quot;请输入你的选择:&quot;); key = Utility.readString(1); switch (key) &#123; case &quot;1&quot;: System.out.println(&quot;显示在线用户列表&quot;); break; case &quot;2&quot;: System.out.println(&quot;群发消息&quot;); break; case &quot;3&quot;: System.out.println(&quot;私发消息&quot;); break; case &quot;4&quot;: System.out.println(&quot;发送文件&quot;); break; case &quot;9&quot;: System.out.println(&quot;退出系统&quot;); loop = false; break; &#125; &#125; &#125; else &#123; //验证不通过 System.out.println(&quot;========登录失败=======&quot;); break; &#125; break; case &quot;9&quot;: System.out.println(&quot;退出系统&quot;); loop = false; break; &#125; &#125; &#125;&#125; 5）根据用户输入的账密进行验证，客户端创建一个用户服务类，用来验证账密并建立连接 点击显/隐内容 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package azqq.service;import azqq.qqcommon.Message;import azqq.qqcommon.MessageType;import azqq.qqcommon.User;import java.io.*;import java.net.InetAddress;import java.net.Socket;/** * 这个类用来检验用户账密是否正确，并开启一个线程（持有socket）。 * 根据用户输入的账号密码设置user对象，发给服务端进行验证，服务端会返回一个Message对象 * 根据Message对象返回的信息判断是否登录成功，登录成功则创建一个线程持有socket和服务端保持通信 **/public class UserClientService &#123; //其它地方有可能用到socket和u，所以做成属性 private Socket socket; private User u = new User(); //根据用户输入的id和密码确认是否合法 public boolean checkUser(String userId , String passWord)&#123; System.out.println(&quot;开始发送对象进行检验&quot;); boolean b = false; //向服务器发送user对象，因此需要创建设置一个 u.setName(userId); u.setPassWord(passWord); //1.通过socket向服务器发送user对象 OutputStream outputStream = null; try &#123; socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9999);// outputStream = socket.getOutputStream();下面简写 ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(u);// InputStream inputStream = socket.getInputStream(); ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); //2.接收服务器返回的信息 Message message = (Message) ois.readObject(); //3.根据返回数据判断是否登录成功 if(message.getDataType().equals(MessageType.MESSAGE_LOGIN_SUCCEED))&#123; //如果登录成功，需要有一个线程持socket来不停的验证和传输数据，因此新建一个线程类ClientConnectServerThread ClientConnectServerThread ccst = new ClientConnectServerThread(socket);//将socket传过去 //启动线程 ccst.start(); //为了后面线程方便管理，将这里的线程加入集合 ManageClientConnectServiceThread.addClientConnectServerThread(userId,ccst); b = true; System.out.println(&quot;登录成功&quot;); &#125;else &#123; System.out.println(&quot;登录失败&quot;); socket.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return b; &#125;&#125; 6）新建的线程类 点击显/隐内容 java1234567891011121314151617181920212223242526272829303132333435363738394041package azqq.service;import azqq.qqcommon.Message;import java.io.IOException;import java.io.InputStream;import java.io.ObjectInputStream;import java.net.Socket;/** * 这个线程类持有socket用来保持和服务端的通信 **/public class ClientConnectServerThread extends Thread&#123; Socket socket ; //通过构造器来获得socket，金典 public ClientConnectServerThread(Socket socket) &#123; this.socket = socket; &#125; //此线程监视用户信息和数据库是否保持一致 @Override public void run() &#123; while (true)&#123; try &#123; System.out.println(&quot;接收消息&quot;); InputStream inputStream = socket.getInputStream(); ObjectInputStream ois = new ObjectInputStream(inputStream); Message message =(Message) ois.readObject(); //后续对message进行处理 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //其它类会需要socket public Socket getSocket() &#123; return socket; &#125;&#125; 7)用hashMap管理线程 java1234567891011121314151617181920package azqq.service;import java.util.HashMap;/** * 线程池 **/public class ManageClientConnectServiceThread &#123; //先用集合hashMap来管理，k为用户名，v为线程 private static HashMap&lt;String,ClientConnectServerThread&gt; hashMap = new HashMap&lt;&gt;(); //添加某一个线程进来 public static void addClientConnectServerThread(String userId,ClientConnectServerThread ccst )&#123; hashMap.put(userId,ccst); &#125; //根据id返回线程 public static ClientConnectServerThread getClientConnectServerThread(String userId) &#123; return hashMap.get(userId); &#125;&#125; 服务端，同理需要有用户对象和消息类，客户端负责验证客户端账户信息和接收数据 点击显/隐内容 注意服务端对于序列化的对象路径要和客户端保存一致，不然无法识别 1.服务端得要接收客户端发送过来的user对象，并根据数据库来检验账密是否正确，正确就开启线程和客户端进行通信 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package azqq.qqService;import azqq.qqcommon.Message;import azqq.qqcommon.MessageType;import azqq.qqcommon.User;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.net.ServerSocket;import java.net.Socket;/** 该服务类持续监听9999端口，如果有客服端进行连接则根据客户端发送的user对象来跟数据库比对，如果正确就建立连接 创建线程进行数据交互，中途如果又有其它客户端加入连接，则同理user没问题就又增加一个线程进行通信 **/public class QQServer &#123; private ServerSocket serverSocket = null; public QQServer() &#123; try &#123; serverSocket = new ServerSocket(9999); System.out.println(&quot;客户端等待连接...&quot;); //当和某个客户端连接后会持续监听，且持续监听是否有其它连接，因此用while while (true) &#123; Socket socket = serverSocket.accept();//如果没有客户端连接就会阻塞在这里 //得到和socket关联的输入输出流 System.out.println(&quot;连接成功&quot;); ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); User user = (User) ois.readObject(); Message message = new Message(); System.out.println(&quot;开始验证&quot;); //验证，如果账号密码正确，则可以登录，这里先死后活，用100，123465作为一个合法用户，后续改 if (user.getName().equals(&quot;100&quot;) &amp;&amp; user.getPassWord().equals(&quot;123456&quot;)) &#123;//根据user的账号密码是否登录成功，先通逻辑 //登录成功返回Massege信息 message.setDataType(MessageType.MESSAGE_LOGIN_SUCCEED);// ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());//考虑作用域放if外面去 //发送message对象 oos.writeObject(message); //同理确认可以登录后创建一个线程和客户端保持通信 ServerConnectClientThread serverConnectClientThread = new ServerConnectClientThread(socket, user.getName()); //启动通信的线程，并放入集合管理 serverConnectClientThread.start(); System.out.println(&quot;踩踩踩踩踩踩&quot;); &#125; else &#123;//登录失败返回Message信息 System.out.println(&quot;测试语句，&quot;+ user.getName() +&quot;登录失败&quot; + user.getPassWord()); message.setDataType(MessageType.MESSAGE_LOGIN_FAIL); oos.writeObject(message); //关闭socket socket.close(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123;//如果服务器退出了while则表示断开了连接，关闭serverSocket try &#123; serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2.线程持有socket 点击显/隐内容 java123456789101112131415161718192021222324252627282930313233343536373839package azqq.qqService;import azqq.qqcommon.Message;import java.io.IOException;import java.io.ObjectInputStream;import java.net.Socket;/** * 该线程类用来和客户端保持通信 **/public class ServerConnectClientThread extends Thread&#123; private Socket socket; private String userId;//用来确认是哪个用户连接的客户端 public ServerConnectClientThread(Socket socket, String userId) &#123; this.socket = socket; this.userId = userId; &#125; @Override public void run() &#123; while (true)&#123; try &#123; ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); //这里由于外层判断用户确认连接后调用此线程来接收用户发送的消息，所以转Message Message message = (Message) ois.readObject(); //后续对message进行处理 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.线程太多加入管理 点击显/隐内容 java12345678910111213141516171819package azqq.qqService;import java.util.HashMap;/** * 线程池 **/public class ManageClientConnectServiceThread &#123; //先用集合hashMap来管理，k为用户名，v为线程 private static HashMap&lt;String,ServerConnectClientThread&gt; hashMap = new HashMap&lt;&gt;(); //添加某一个线程进来 public static void addServerConnectClientThread(String userId,ServerConnectClientThread scct )&#123; hashMap.put(userId,scct); &#125; //根据id返回线程 public static ServerConnectClientThread getServerConnectClientThread(String userId) &#123; return hashMap.get(userId); &#125;&#125; 以上双方的通信基本打通，验证一下没问题 完善一下客户端用户数据，先用集合保存在服务里 java123456789 //考虑多线程用ConcurrentHashMap，线程同步static ConcurrentHashMap&lt;String,User&gt; validUsers = new ConcurrentHashMap&lt;&gt;();static &#123;//静态代码块，先代替数据库存放用户数据 validUsers.put(&quot;100&quot;,new User(&quot;100&quot;,&quot;123456&quot;)); validUsers.put(&quot;200&quot;,new User(&quot;200&quot;,&quot;123456&quot;)); validUsers.put(&quot;123&quot;,new User(&quot;123&quot;,&quot;123456&quot;)); validUsers.put(&quot;我是账户名&quot;,new User(&quot;我是账户名&quot;,&quot;我是对应密码&quot;)); validUsers.put(&quot;老亚萨西了&quot;,new User(&quot;老亚萨西了&quot;,&quot;123456&quot;));&#125; 二、实现拉取在线用户功能1.增加数据类型（两端都要） java123456789public interface MessageType &#123; //在接口中定义常量，表示不同的消息类型 String MESSAGE_LOGIN_SUCCEED = &quot;1&quot;;//表示登录成功 String MESSAGE_LOGIN_FAIL = &quot;2&quot;;//登录失败 String MESSAGE_COMM_MES =&quot;3&quot;;//普通信息包 String MESSAGE_GET_ONLINE_FRIEND =&quot;4&quot;;//要求返回在线用户列表 String MESSAGE_RET_ONLINE_FRIEND =&quot;5&quot;;//返回在线用户列表 String MESSAGE_CLIENT_EXIT =&quot;6&quot;;//客户端请求退出&#125; 客户端发送拉取在线用户请求并接收 点击显/隐内容 java123456789101112131415161718192021222324252627282930313233根据用户输入1拉取在线列表，创建一个方法在客户端的服务里//请求服务端获取在线好友列表 public void olineFriendList()&#123; //发送请求 Message message = new Message(); //设置数据类型 message.setDataType(MessageType.MESSAGE_GET_ONLINE_FRIEND); //设置发送者 message.setSender(u.getName()); try &#123; //获取相关用户线程对应的socket，可以通过线程集合来获取 Socket userSocket = ManageClientConnectServiceThread. getClientConnectServerThread(u.getName()).getSocket(); //根据socket得到输出流 ObjectOutputStream oos = new ObjectOutputStream(userSocket.getOutputStream()); //发送请求给服务端 oos.writeObject(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;这段代码在用户线程的run方法里，一直读取服务端数据 //判断message数据类型，进行相应处理 if (message.getDataType().equals(MessageType.MESSAGE_RET_ONLINE_FRIEND)) &#123; //默认好友在线列表以字符串形式且以“”隔开 String[] onlineUsers = message.getContent().split(&quot; &quot;); System.out.println(&quot;\\n=========当前在线用户列表============&quot;); for (int i = 0; i &lt; onlineUsers.length; i++) &#123; System.out.println(&quot;用户:&quot; + onlineUsers[i]); &#125; &#125; 客户端接收请求并返回在线用户列表数据 点击显/隐内容 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950服务端接收并返回数据@Override public void run() &#123; while (true) &#123; try &#123; System.out.println(&quot;服务端和客户端&quot; + userId +&quot;保持通信，读取数据&quot;); ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); //这里由于外层判断用户确认连接后调用此线程来接收用户发送的消息，所以转Message Message message = (Message) ois.readObject(); //根据接收的数据类型进行相应业务处理 //如果数据类型为获取在线好友列表请求 if (message.getDataType().equals(MessageType.MESSAGE_GET_ONLINE_FRIEND)) &#123; /* 好友列表格式为 100 200 老亚萨西了 考虑到线程池有所有在运行的用户，所以在那里编写方法获取userId */ System.out.println(message.getSender() + &quot;要在线用户列表&quot;); //获取要发送的在线用户列表 String onlineUserList = ManageClientConnectServiceThread.getUserId(); Message message2 = new Message(); message2.setDataType(MessageType.MESSAGE_RET_ONLINE_FRIEND); message2.setContent(onlineUserList); //message发送者getSender是谁，接收者就设置成谁 message2.setReceiver(message.getSender()); ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(message2); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 服务端接收数据后的还未返回时对数据的处理过程 //返回在线用户id public static String getUserId()&#123; String onlineUserList = &quot;&quot;; //从hashmap中取，遍历 //1.取迭代器 Iterator&lt;String&gt; iterator = hashMap.keySet().iterator(); while (iterator.hasNext())&#123; onlineUserList += iterator.next() + &quot; &quot;; &#125; System.out.println(onlineUserList); return onlineUserList; &#125; 功能实现截图 无异常退出 点击显/隐内容 java123456789101112131415161718192021222324252627用户选择9退出时调用此方法 //编写方法给服务端发送message通知关闭线程 public void closeThread()&#123; Message message = new Message(); message.setSender(u.getName()); //消息数据类型为客户端申请退出 message.setDataType(MessageType.MESSAGE_CLIENT_EXIT); try &#123; OutputStream outputStream = socket.getOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(outputStream); oos.writeObject(message);//发送数据给服务端 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; 服务端对应线程处 //如果数据类型为请求关闭类型 if(message.getDataType().equals(MessageType.MESSAGE_CLIENT_EXIT))&#123; //从线程池里移除数据包里面对应的发送者 ManageClientConnectServiceThread.removeServerConnectClientThread(message.getSender()); socket.close();//关闭连接 System.out.println(message.getSender() + &quot;下线了&quot;); loop = false; &#125; 私聊功能 打包——转发——拆包 点击显/隐内容 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455打包/** * 用于客户端私聊/群聊 **/public class MessageClientService &#123; //私发消息的功能 /** * * @param sendId 发送者 * @param receiver 接收者 * @param content 发送内容 */ public void privateChat(String sendId, String receiver, String content)&#123; //设置数据基本属性，发送者接收者，数据类型，发送内容 Message message = new Message(); message.setSender(sendId); message.setDataType(MessageType.MESSAGE_COMM_MES); message.setContent(content); message.setReceiver(receiver); //日期设置 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd E hh:mm:ss a&quot;); String strDate = sdf.format(new Date()); message.setData(strDate); //给客户端自己提示一句话 System.out.println(&quot;\\n&quot; + sendId + &quot;对&quot; + receiver + &quot;说:&quot; + content); //将数据发送到服务端 try &#123; ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServiceThread.getClientConnectServerThread(sendId).getSocket().getOutputStream()); oos.writeObject(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;转发if(message.getDataType().equals(MessageType.MESSAGE_COMM_MES))&#123; //从数据包里面提取发送者想要私聊的对象 String receiver = message.getReceiver(); //根据接收者的userId来获取对应的线程socket Socket socket = ManageClientConnectServiceThread.getServerConnectClientThread(receiver).socket; ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(message); //后面考虑加入离线的情况 &#125;拆包//如果数据类型为普通信息包 if(message.getDataType().equals(MessageType.MESSAGE_COMM_MES))&#123; String sender = message.getSender(); String content = message.getContent(); System.out.println(&quot;\\n&quot; + sender+ &quot;对&quot; + message.getReceiver() + &quot;说：&quot; + content + &quot;\\t&quot; + message.getData()); &#125; 群聊功能 点击显/隐内容 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465用户选择 case &quot;2&quot;: System.out.println(&quot;请输入群发消息内容&quot;); String groupContent = Utility.readString(50); mcs.groupChat(userId, groupContent); break;客户端发送数据包/** * @param sendId 发送者 * @param content 发送内容 */ public void groupChat(String sendId, String content)&#123; //设置数据基本属性，发送者接收者，数据类型，发送内容 Message message = new Message(); message.setSender(sendId); message.setDataType(MessageType.MESSAGE_GROUP_MES); message.setContent(content); //日期设置 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd E hh:mm:ss a&quot;); String strDate = sdf.format(new Date()); message.setData(strDate); //给客户端自己提示一句话 System.out.println(&quot;\\n&quot; + sendId + &quot;对所有人说:&quot; + content); //将数据发送到服务端 try &#123; ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServiceThread.getClientConnectServerThread(sendId).getSocket().getOutputStream()); oos.writeObject(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 服务端处理//如果数据类型为群聊 else if(message.getDataType().equals(MessageType.MESSAGE_GROUP_MES))&#123; ManageClientConnectServiceThread.groupChat(userId,message); System.out.println(userId + &quot;给所有人发了消息&quot;); &#125; //群聊消息 public static void groupChat(String userId , Message message)&#123; Iterator&lt;ServerConnectClientThread&gt; iterator = hashMap.values().iterator(); while (iterator.hasNext())&#123; ServerConnectClientThread next = iterator.next(); if( next != hashMap.get(userId))&#123; Socket socket = next.getSocket(); try &#123; ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;客户端再接收//如果数据类型为群聊包 if(message.getDataType().equals(MessageType.MESSAGE_GROUP_MES))&#123; String content = message.getContent(); String sender = message.getSender(); System.out.println(&quot;\\n&quot; + sender+ &quot;对所有人说：&quot; + content + &quot;\\t&quot; + content); &#125; 发文件功能 点击显/隐内容 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677客户端发送文件case &quot;4&quot;:System.out.println(&quot;请输入发送文件给哪个用户:&quot;);String fileReceiver = Utility.readString(50);System.out.println(&quot;请输入发送文件的路径:&quot;);String sourcePath = Utility.readString(50);System.out.println(&quot;请输入发送文件至对方的的路径:&quot;);String targetPath = Utility.readString(50);fileClientService.sendFile(userId,sourcePath,fileReceiver,targetPath);break;public class FileClientService &#123;//给其它客户端传送文件/*** @param sender 发送者* @param sourcePath 发送路径* @param receiver 接收者* @param targetPath 接收路径*/public void sendFile(String sender,String sourcePath,String receiver,String targetPath)&#123;//数据包初始化发送者接收者，发送路径，接收路径，数据包类型Message message = new Message();message.setSender(sender);message.setReceiver(receiver);message.setSourcePath(sourcePath);message.setTargetPath(targetPath);message.setDataType(MessageType.MESSAGE_FILE_MES);//根据指定路径，将输入流转成字节数组，打包进messageInputStream inputStream = null;try &#123;inputStream = new FileInputStream(sourcePath);byte[] bytes = StreamUtils.streamToByteArray(inputStream);message.setBytes(bytes);//根据发送者id--&gt;线程池--&gt;socket--&gt;getOutputStream()OutputStream outputStream = ManageClientConnectServiceThread.getClientConnectServerThread(sender).getSocket().getOutputStream();ObjectOutputStream oos = new ObjectOutputStream(outputStream);//发送数据包oos.writeObject(message);System.out.println(&quot;\\n&quot; + sender + &quot;把来自&quot; + targetPath + &quot;的文件发送给了&quot;+ receiver);&#125; catch (Exception ex) &#123;ex.printStackTrace();&#125;&#125;&#125;服务端转发//判断数据类型为文件else if(message.getDataType().equals(MessageType.MESSAGE_FILE_MES))&#123;//获取接收者String receiver = message.getReceiver();//根据接收者获取对应线程ServerConnectClientThread scct = ManageClientConnectServiceThread.getServerConnectClientThread(receiver);//根据线程获取socketSocket socket = scct.getSocket();//把读取到的数据发送到对应线程OutputStream outputStream = socket.getOutputStream();ObjectOutputStream oos = new ObjectOutputStream(outputStream);oos.writeObject(message);//提示信息System.out.println(&quot;\\n&quot; +message.getSender() + &quot;发送文件给&quot; + receiver);&#125;客户端接收 //如果数据类型为文件if(message.getDataType().equals(MessageType.MESSAGE_FILE_MES))&#123;//拆包获取数据String sender = message.getSender();String receiver = message.getReceiver();String targetPath = message.getTargetPath();byte[] bytes = message.getBytes();FileOutputStream fileOutputStream = new FileOutputStream(targetPath);fileOutputStream.write(bytes);if(fileOutputStream != null)&#123; fileOutputStream.close();&#125;System.out.println(&quot;\\n&quot; +receiver + &quot;接收了&quot; + sender + &quot;发送的文件并存入了&quot; + targetPath);&#125; 推送消息功能 点击显/隐内容 java123456789101112131415161718192021222324252627282930313233343536** * 一个独立线程负责推送消息 **/public class SendNewsToAllService extends Thread &#123; @Override public void run() &#123; //可反复推送消息 while (true) &#123; System.out.println(&quot;请输入你想推送的消息(输入exit表示退出推送服务线程):&quot;); String news = Utility.readString(100); if(news.equals(&quot;exit&quot;))&#123; break; &#125; //设置要发送的数据包 Message message = new Message(); message.setSender(&quot;服务器&quot;); message.setDataType(MessageType.MESSAGE_GROUP_MES); message.setContent(news); //发送给所有线程 HashMap&lt;String, ServerConnectClientThread&gt; hashMap = ManageClientConnectServiceThread.getHashMap(); Iterator&lt;ServerConnectClientThread&gt; iterator = hashMap.values().iterator(); while (iterator.hasNext()) &#123; ServerConnectClientThread next = iterator.next(); Socket socket = next.getSocket(); try &#123; ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(message);//发送数据包 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 扩展部分：离线消息和离线文件离线消息 java12345678910111213141516171819202122232425262728293031323334/** * 监视线程，保证离线用户上线后第一时间收到消息 **/public class OfflineUserPackage extends Thread&#123; Message message; public Message getMessage() &#123; return message; &#125; public void setMessage(Message message) &#123; this.message = message; &#125; @Override public void run() &#123; boolean loop = true; while (loop)&#123; //从数据包里获取接收者 String receiver = message.getReceiver(); //获取线程集合hashMap HashMap&lt;String, ServerConnectClientThread&gt; hashMap = ManageClientConnectServiceThread.getHashMap(); if(hashMap.get(receiver) != null) &#123; ServerConnectClientThread serverConnectClientThread = hashMap.get(receiver); Socket socket = serverConnectClientThread.getSocket(); try &#123; ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(message); loop = false; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 离线文件 java123456789101112131415161718给离线文件和消息都加了个筛选if(hashMap.get(receiver) != null &amp;&amp; message.getDataType().equals(MessageType.MESSAGE_FILE_MES)) &#123; //根据接收者获取对应线程 ServerConnectClientThread serverConnectClientThread = hashMap.get(receiver); //根据线程获取socket Socket socket = serverConnectClientThread.getSocket(); //把读取到的数据发送到对应线程 try &#123; OutputStream outputStream = socket.getOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(outputStream); oos.writeObject(message); loop = false; //提示信息 System.out.println(&quot;\\n&quot; + message.getSender() + &quot;发送文件给&quot; + receiver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}