{"meta":{"title":"老亚萨西了","subtitle":"","description":"oyoy","author":"John Doe","url":"http://tanquerayds.site","root":"/"},"pages":[{"title":"","date":"2022-08-18T10:03:58.584Z","updated":"2022-08-18T10:03:58.584Z","comments":false,"path":"about/index.html","permalink":"http://tanquerayds.site/about/index.html","excerpt":"","text":""},{"title":"","date":"2022-08-18T10:03:38.090Z","updated":"2022-08-18T10:03:38.090Z","comments":false,"path":"categories/index.html","permalink":"http://tanquerayds.site/categories/index.html","excerpt":"","text":"layout: categoryindex: truetitle: 所有分类"},{"title":"","date":"2022-08-18T10:03:19.548Z","updated":"2022-08-18T10:03:19.548Z","comments":false,"path":"tags/index.html","permalink":"http://tanquerayds.site/tags/index.html","excerpt":"","text":"layout: tagindex: truetitle: 所有标签"},{"title":"","date":"2022-09-04T04:40:32.414Z","updated":"2022-09-04T04:40:32.413Z","comments":false,"path":"css/fold_code.css","permalink":"http://tanquerayds.site/css/fold_code.css","excerpt":"","text":".markdown-body .highlight table, .markdown-body .code-wrapper pre { border-radius: 0 0 0.5rem 0.5rem; } .markdown-body .highlight, .markdown-body .code-wrapper { background-color: #e6ebf1; border-radius: 0.625rem; } .markdown-body .highlight > i, .markdown-body .code-wrapper > i { color: #777; margin-left: 10px; line-height: 2rem; transform: none; transition: color 0.2s ease-in-out, transform 0.2s ease-in-out; } .markdown-body .highlight > i.collapsed, .markdown-body .code-wrapper > i.collapsed { transform: rotate(-90deg); } .markdown-body .highlight > span, .markdown-body .code-wrapper > span { color: #777; margin-left: 10px; font-weight: bold; } [data-user-color-scheme='dark'] .markdown-body .highlight, [data-user-color-scheme='dark'] .markdown-body .code-wrapper { background-color: #696969; transition: background-color 0.2s ease-in-out; } [data-user-color-scheme='dark'] .markdown-body .highlight > i, [data-user-color-scheme='dark'] .markdown-body .code-wrapper > i { color: #c4c6c9; } [data-user-color-scheme='dark'] .markdown-body .highlight > span, [data-user-color-scheme='dark'] .markdown-body .code-wrapper > span { color: #c4c6c9; transition: color 0.2s ease-in-out; }"}],"posts":[{"title":"多用户即时通信系统","slug":"多用户通信系统","date":"2022-09-03T11:16:26.000Z","updated":"2022-09-07T03:24:53.799Z","comments":true,"path":"2022/09/03/多用户通信系统/","link":"","permalink":"http://tanquerayds.site/2022/09/03/%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"为什么选择这个项目 有意思且涉及到各个方面的技术，还可以巩固基础学习新知识知识点包括： 项目框架设计 java面向对象编程 网络编程 多线程 IO流 Mysql&#x2F;（先用集合充当内存数据库） 多用户通信系统思路（第一版）和代码实现 通信结构分为客户端和服务端 服务端验证客户端账号信息和数据传输客户端作为用户可以通过服务器给其它用户发送消息和各类文件数据的传输主要采用对象流的方式，包括用户对象和消息数据包 一、 实现第一个功能，用户登录 客户端，根据用户界面提前创建用户对象和消息数据包，都作为对象数据流来传输。 1）用户这个类包括用户名&#x2F;id,用户密码 点击显/隐内容 java1234567891011121314151617181920212223242526public class User implements Serializable &#123; public static final long serialVersionUID = 1L; private String name;//用户名/id String passWord;//密码 public User(String name, String passWord) &#123; this.name = name; this.passWord = passWord; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassWord() &#123; return passWord; &#125; public void setPassWord(String passWord) &#123; this.passWord = passWord; &#125;&#125; 2）数据包这个类会包含数据类型，数据内容，发送者和接收者，最后还有发送时间 点击显/隐内容 JAVA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Message implements Serializable &#123; public static final long serialVersionUID = 1L; private String content;//发送内容 private String dataType;//数据类型 private String sender;//发送者 private String receiver;//接收者 private String data;//日期，感觉可以用第三代日期类，后面再改 public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public String getDataType() &#123; return dataType; &#125; public void setDataType(String dataType) &#123; this.dataType = dataType; &#125; public String getSender() &#123; return sender; &#125; public void setSender(String sender) &#123; this.sender = sender; &#125; public String getReceiver() &#123; return receiver; &#125; public void setReceiver(String receiver) &#123; this.receiver = receiver; &#125; public String getData() &#123; return data; &#125; public void setData(String data) &#123; this.data = data; &#125;&#125; 3）为了管理数据包的数据类型，再创建个接口来管理 JAVA123456package az.qqServer;public interface MessageType &#123; //在接口中定义常量，表示不同的消息类型 String MESSAGE_LOGIN_SUCCEED = &quot;1&quot;; String MESSAGE_LOGIN_FAIL = &quot;2&quot;;&#125; 4)用户登录界面制作，先把逻辑打通再细写代码进入二级菜单 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 客户端登入界面 **/public class qqView &#123; public static void main(String[] args) &#123; new qqView().mainView();//测试mainView方法 &#125; private static boolean loop = true;//菜单控制循环 private String key;//用户输入 public void mainView() &#123; while (loop) &#123; System.out.println(&quot;==========欢迎登录网络通信系统=========&quot;); System.out.println(&quot;\\t\\t1 登录系统&quot;); System.out.println(&quot;\\t\\t9 退出系统&quot;); System.out.println(&quot;请输入你的选择:&quot;); key = Utility.readString(1); //根据用户输入来执行操作 switch (key) &#123; case &quot;1&quot;: System.out.println(&quot;请输入你的用户名:&quot;); String userId = Utility.readString(50); System.out.println(&quot;请输入你的密码:&quot;); String passWord = Utility.readString(50); //这里需要到服务端验证是否合法，代码后续补，先通逻辑 if (true) &#123;//假如验证合法，则进入二级菜单 System.out.println(&quot;========欢迎用户&quot; + userId + &quot;===========&quot;); while (loop) &#123; System.out.println(&quot;==========网络通信系统二级菜单（&quot; + userId + &quot;）========&quot;); System.out.println(&quot;\\t\\t1 显示在线用户列表&quot;); System.out.println(&quot;\\t\\t2 群发消息&quot;); System.out.println(&quot;\\t\\t3 私发消息&quot;); System.out.println(&quot;\\t\\t4 发送文件&quot;); System.out.println(&quot;\\t\\t9 退出系统&quot;); System.out.println(&quot;请输入你的选择:&quot;); key = Utility.readString(1); switch (key) &#123; case &quot;1&quot;: System.out.println(&quot;显示在线用户列表&quot;); break; case &quot;2&quot;: System.out.println(&quot;群发消息&quot;); break; case &quot;3&quot;: System.out.println(&quot;私发消息&quot;); break; case &quot;4&quot;: System.out.println(&quot;发送文件&quot;); break; case &quot;9&quot;: System.out.println(&quot;退出系统&quot;); loop = false; break; &#125; &#125; &#125; else &#123; //验证不通过 System.out.println(&quot;========登录失败=======&quot;); break; &#125; break; case &quot;9&quot;: System.out.println(&quot;退出系统&quot;); loop = false; break; &#125; &#125; &#125;&#125; 5）根据用户输入的账密进行验证，客户端创建一个用户服务类，用来验证账密并建立连接 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package azqq.service;import azqq.qqcommon.Message;import azqq.qqcommon.MessageType;import azqq.qqcommon.User;import java.io.*;import java.net.InetAddress;import java.net.Socket;/** * 这个类用来检验用户账密是否正确，并开启一个线程（持有socket）。 * 根据用户输入的账号密码设置user对象，发给服务端进行验证，服务端会返回一个Message对象 * 根据Message对象返回的信息判断是否登录成功，登录成功则创建一个线程持有socket和服务端保持通信 **/public class UserClientService &#123; //其它地方有可能用到socket和u，所以做成属性 private Socket socket; private User u = new User(); //根据用户输入的id和密码确认是否合法 public boolean checkUser(String userId , String passWord)&#123; System.out.println(&quot;开始发送对象进行检验&quot;); boolean b = false; //向服务器发送user对象，因此需要创建设置一个 u.setName(userId); u.setPassWord(passWord); //1.通过socket向服务器发送user对象 OutputStream outputStream = null; try &#123; socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9999);// outputStream = socket.getOutputStream();下面简写 ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(u);// InputStream inputStream = socket.getInputStream(); ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); //2.接收服务器返回的信息 Message message = (Message) ois.readObject(); //3.根据返回数据判断是否登录成功 if(message.getDataType().equals(MessageType.MESSAGE_LOGIN_SUCCEED))&#123; //如果登录成功，需要有一个线程持socket来不停的验证和传输数据，因此新建一个线程类ClientConnectServerThread ClientConnectServerThread ccst = new ClientConnectServerThread(socket);//将socket传过去 //启动线程 ccst.start(); //为了后面线程方便管理，将这里的线程加入集合 ManageClientConnectServiceThread.addClientConnectServerThread(userId,ccst); b = true; System.out.println(&quot;登录成功&quot;); &#125;else &#123; System.out.println(&quot;登录失败&quot;); socket.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return b; &#125;&#125; 6）新建的线程类 java1234567891011121314151617181920212223242526272829303132333435363738394041package azqq.service;import azqq.qqcommon.Message;import java.io.IOException;import java.io.InputStream;import java.io.ObjectInputStream;import java.net.Socket;/** * 这个线程类持有socket用来保持和服务端的通信 **/public class ClientConnectServerThread extends Thread&#123; Socket socket ; //通过构造器来获得socket，金典 public ClientConnectServerThread(Socket socket) &#123; this.socket = socket; &#125; //此线程监视用户信息和数据库是否保持一致 @Override public void run() &#123; while (true)&#123; try &#123; System.out.println(&quot;接收消息&quot;); InputStream inputStream = socket.getInputStream(); ObjectInputStream ois = new ObjectInputStream(inputStream); Message message =(Message) ois.readObject(); //后续对message进行处理 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //其它类会需要socket public Socket getSocket() &#123; return socket; &#125;&#125; 7)用hashMap管理线程 java1234567891011121314151617181920package azqq.service;import java.util.HashMap;/** * 线程池 **/public class ManageClientConnectServiceThread &#123; //先用集合hashMap来管理，k为用户名，v为线程 private static HashMap&lt;String,ClientConnectServerThread&gt; hashMap = new HashMap&lt;&gt;(); //添加某一个线程进来 public static void addClientConnectServerThread(String userId,ClientConnectServerThread ccst )&#123; hashMap.put(userId,ccst); &#125; //根据id返回线程 public static ClientConnectServerThread getClientConnectServerThread(String userId) &#123; return hashMap.get(userId); &#125;&#125; 服务端，同理需要有用户对象和消息类，客户端负责验证客户端账户信息和接收数据 注意服务端对于序列化的对象路径要和客户端保存一致，不然无法识别 1.服务端得要接收客户端发送过来的user对象，并根据数据库来检验账密是否正确，正确就开启线程和客户端进行通信 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package azqq.qqService;import azqq.qqcommon.Message;import azqq.qqcommon.MessageType;import azqq.qqcommon.User;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.net.ServerSocket;import java.net.Socket;/** 该服务类持续监听9999端口，如果有客服端进行连接则根据客户端发送的user对象来跟数据库比对，如果正确就建立连接 创建线程进行数据交互，中途如果又有其它客户端加入连接，则同理user没问题就又增加一个线程进行通信 **/public class QQServer &#123; private ServerSocket serverSocket = null; public QQServer() &#123; try &#123; serverSocket = new ServerSocket(9999); System.out.println(&quot;客户端等待连接...&quot;); //当和某个客户端连接后会持续监听，且持续监听是否有其它连接，因此用while while (true) &#123; Socket socket = serverSocket.accept();//如果没有客户端连接就会阻塞在这里 //得到和socket关联的输入输出流 System.out.println(&quot;连接成功&quot;); ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); User user = (User) ois.readObject(); Message message = new Message(); System.out.println(&quot;开始验证&quot;); //验证，如果账号密码正确，则可以登录，这里先死后活，用100，123465作为一个合法用户，后续改 if (user.getName().equals(&quot;100&quot;) &amp;&amp; user.getPassWord().equals(&quot;123456&quot;)) &#123;//根据user的账号密码是否登录成功，先通逻辑 //登录成功返回Massege信息 message.setDataType(MessageType.MESSAGE_LOGIN_SUCCEED);// ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());//考虑作用域放if外面去 //发送message对象 oos.writeObject(message); //同理确认可以登录后创建一个线程和客户端保持通信 ServerConnectClientThread serverConnectClientThread = new ServerConnectClientThread(socket, user.getName()); //启动通信的线程，并放入集合管理 serverConnectClientThread.start(); System.out.println(&quot;踩踩踩踩踩踩&quot;); &#125; else &#123;//登录失败返回Message信息 System.out.println(&quot;测试语句，&quot;+ user.getName() +&quot;登录失败&quot; + user.getPassWord()); message.setDataType(MessageType.MESSAGE_LOGIN_FAIL); oos.writeObject(message); //关闭socket socket.close(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123;//如果服务器退出了while则表示断开了连接，关闭serverSocket try &#123; serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2.线程持有socket java123456789101112131415161718192021222324252627282930313233343536373839package azqq.qqService;import azqq.qqcommon.Message;import java.io.IOException;import java.io.ObjectInputStream;import java.net.Socket;/** * 该线程类用来和客户端保持通信 **/public class ServerConnectClientThread extends Thread&#123; private Socket socket; private String userId;//用来确认是哪个用户连接的客户端 public ServerConnectClientThread(Socket socket, String userId) &#123; this.socket = socket; this.userId = userId; &#125; @Override public void run() &#123; while (true)&#123; try &#123; ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); //这里由于外层判断用户确认连接后调用此线程来接收用户发送的消息，所以转Message Message message = (Message) ois.readObject(); //后续对message进行处理 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.线程太多加入管理 java12345678910111213141516171819package azqq.qqService;import java.util.HashMap;/** * 线程池 **/public class ManageClientConnectServiceThread &#123; //先用集合hashMap来管理，k为用户名，v为线程 private static HashMap&lt;String,ServerConnectClientThread&gt; hashMap = new HashMap&lt;&gt;(); //添加某一个线程进来 public static void addServerConnectClientThread(String userId,ServerConnectClientThread scct )&#123; hashMap.put(userId,scct); &#125; //根据id返回线程 public static ServerConnectClientThread getServerConnectClientThread(String userId) &#123; return hashMap.get(userId); &#125;&#125; 以上双方的通信基本打通，验证一下没问题 完善一下客户端用户数据，先用集合保存在服务里 java123456789 //考虑多线程用ConcurrentHashMap，线程同步static ConcurrentHashMap&lt;String,User&gt; validUsers = new ConcurrentHashMap&lt;&gt;();static &#123;//静态代码块，先代替数据库存放用户数据 validUsers.put(&quot;100&quot;,new User(&quot;100&quot;,&quot;123456&quot;)); validUsers.put(&quot;200&quot;,new User(&quot;200&quot;,&quot;123456&quot;)); validUsers.put(&quot;123&quot;,new User(&quot;123&quot;,&quot;123456&quot;)); validUsers.put(&quot;我是账户名&quot;,new User(&quot;我是账户名&quot;,&quot;我是对应密码&quot;)); validUsers.put(&quot;老亚萨西了&quot;,new User(&quot;老亚萨西了&quot;,&quot;123456&quot;));&#125; 二、实现拉取在线用户功能1.增加数据类型（两端都要） java123456789public interface MessageType &#123; //在接口中定义常量，表示不同的消息类型 String MESSAGE_LOGIN_SUCCEED = &quot;1&quot;;//表示登录成功 String MESSAGE_LOGIN_FAIL = &quot;2&quot;;//登录失败 String MESSAGE_COMM_MES =&quot;3&quot;;//普通信息包 String MESSAGE_GET_ONLINE_FRIEND =&quot;4&quot;;//要求返回在线用户列表 String MESSAGE_RET_ONLINE_FRIEND =&quot;5&quot;;//返回在线用户列表 String MESSAGE_CLIENT_EXIT =&quot;6&quot;;//客户端请求退出&#125; 客户端发送拉取在线用户请求并接收 java123456789101112131415161718192021222324252627282930313233根据用户输入1拉取在线列表，创建一个方法在客户端的服务里//请求服务端获取在线好友列表 public void olineFriendList()&#123; //发送请求 Message message = new Message(); //设置数据类型 message.setDataType(MessageType.MESSAGE_GET_ONLINE_FRIEND); //设置发送者 message.setSender(u.getName()); try &#123; //获取相关用户线程对应的socket，可以通过线程集合来获取 Socket userSocket = ManageClientConnectServiceThread. getClientConnectServerThread(u.getName()).getSocket(); //根据socket得到输出流 ObjectOutputStream oos = new ObjectOutputStream(userSocket.getOutputStream()); //发送请求给服务端 oos.writeObject(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;这段代码在用户线程的run方法里，一直读取服务端数据 //判断message数据类型，进行相应处理 if (message.getDataType().equals(MessageType.MESSAGE_RET_ONLINE_FRIEND)) &#123; //默认好友在线列表以字符串形式且以“”隔开 String[] onlineUsers = message.getContent().split(&quot; &quot;); System.out.println(&quot;\\n=========当前在线用户列表============&quot;); for (int i = 0; i &lt; onlineUsers.length; i++) &#123; System.out.println(&quot;用户:&quot; + onlineUsers[i]); &#125; &#125; 客户端接收请求并返回在线用户列表数据 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950服务端接收并返回数据@Override public void run() &#123; while (true) &#123; try &#123; System.out.println(&quot;服务端和客户端&quot; + userId +&quot;保持通信，读取数据&quot;); ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); //这里由于外层判断用户确认连接后调用此线程来接收用户发送的消息，所以转Message Message message = (Message) ois.readObject(); //根据接收的数据类型进行相应业务处理 //如果数据类型为获取在线好友列表请求 if (message.getDataType().equals(MessageType.MESSAGE_GET_ONLINE_FRIEND)) &#123; /* 好友列表格式为 100 200 老亚萨西了 考虑到线程池有所有在运行的用户，所以在那里编写方法获取userId */ System.out.println(message.getSender() + &quot;要在线用户列表&quot;); //获取要发送的在线用户列表 String onlineUserList = ManageClientConnectServiceThread.getUserId(); Message message2 = new Message(); message2.setDataType(MessageType.MESSAGE_RET_ONLINE_FRIEND); message2.setContent(onlineUserList); //message发送者getSender是谁，接收者就设置成谁 message2.setReceiver(message.getSender()); ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(message2); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 服务端接收数据后的还未返回时对数据的处理过程 //返回在线用户id public static String getUserId()&#123; String onlineUserList = &quot;&quot;; //从hashmap中取，遍历 //1.取迭代器 Iterator&lt;String&gt; iterator = hashMap.keySet().iterator(); while (iterator.hasNext())&#123; onlineUserList += iterator.next() + &quot; &quot;; &#125; System.out.println(onlineUserList); return onlineUserList; &#125; 功能实现截图","categories":[],"tags":[]}],"categories":[],"tags":[]}