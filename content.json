{"meta":{"title":"老亚萨西了","subtitle":"","description":"oyoy","author":"John Doe","url":"http://tanquerayds.site","root":"/"},"pages":[{"title":"","date":"2022-08-18T10:03:58.584Z","updated":"2022-08-18T10:03:58.584Z","comments":false,"path":"about/index.html","permalink":"http://tanquerayds.site/about/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-04T04:40:32.414Z","updated":"2022-09-04T04:40:32.413Z","comments":false,"path":"css/fold_code.css","permalink":"http://tanquerayds.site/css/fold_code.css","excerpt":"","text":".markdown-body .highlight table, .markdown-body .code-wrapper pre { border-radius: 0 0 0.5rem 0.5rem; } .markdown-body .highlight, .markdown-body .code-wrapper { background-color: #e6ebf1; border-radius: 0.625rem; } .markdown-body .highlight > i, .markdown-body .code-wrapper > i { color: #777; margin-left: 10px; line-height: 2rem; transform: none; transition: color 0.2s ease-in-out, transform 0.2s ease-in-out; } .markdown-body .highlight > i.collapsed, .markdown-body .code-wrapper > i.collapsed { transform: rotate(-90deg); } .markdown-body .highlight > span, .markdown-body .code-wrapper > span { color: #777; margin-left: 10px; font-weight: bold; } [data-user-color-scheme='dark'] .markdown-body .highlight, [data-user-color-scheme='dark'] .markdown-body .code-wrapper { background-color: #696969; transition: background-color 0.2s ease-in-out; } [data-user-color-scheme='dark'] .markdown-body .highlight > i, [data-user-color-scheme='dark'] .markdown-body .code-wrapper > i { color: #c4c6c9; } [data-user-color-scheme='dark'] .markdown-body .highlight > span, [data-user-color-scheme='dark'] .markdown-body .code-wrapper > span { color: #c4c6c9; transition: color 0.2s ease-in-out; }"},{"title":"","date":"2022-08-18T10:03:38.090Z","updated":"2022-08-18T10:03:38.090Z","comments":false,"path":"categories/index.html","permalink":"http://tanquerayds.site/categories/index.html","excerpt":"","text":"layout: categoryindex: truetitle: 所有分类"},{"title":"","date":"2022-08-18T10:03:19.548Z","updated":"2022-08-18T10:03:19.548Z","comments":false,"path":"tags/index.html","permalink":"http://tanquerayds.site/tags/index.html","excerpt":"","text":"layout: tagindex: truetitle: 所有标签"}],"posts":[{"title":"web后端-Servlet","slug":"WEB后端-Servlet","date":"2022-09-29T01:47:43.000Z","updated":"2022-09-29T10:02:30.219Z","comments":true,"path":"2022/09/29/WEB后端-Servlet/","link":"","permalink":"http://tanquerayds.site/2022/09/29/WEB%E5%90%8E%E7%AB%AF-Servlet/","excerpt":"","text":"Servlet一、B&#x2F;S结构原理剖析 1.系统架构包括什么形式? C&#x2F;S架构 B&#x2F;S架构 2.C&#x2F;S架构 Client &#x2F; Server(客户端&#x2F;服务器) C&#x2F;S架构的特点:需要安装特定的客户端软件。 C&#x2F;S架构的系统优点和缺点分别是什么? 优点: 速度快（数据大部分集成到客户端软件当中,交互数据量小) 服务器压力小 界面酷炫（专门的语言去实现界面的，更加灵活。) 安全(大量的数据是集成在客户端软件当中的。) … 缺点: 升级维护比较差劲。(升级维护比较麻烦。成本比较高。每一个客户端软件都需要升级。有一些软件不是那么容易安装的。) 3.B&#x2F;S架构 B&#x2F;S (Browser &#x2F; Server，浏览器&#x2F;服务器) B&#x2F;S结构的系统是不是一个特殊的C&#x2F;S系统? 实际上B&#x2F;S结构的系统是一个特殊的C&#x2F;S结构，这个Client是一个固定不变浏览器软件 oB&#x2F;S结构的系统优点和缺点是: 优点: 升级维护方便成本比较低。(只需要升级服务器端即可不需要安装特定的客户端软件，用户操作极其方便。只需要打开浏览器，输入网址即可。 缺点: 速度慢(所有的数据都是在服务器上，用户发送的每一个请求都是需要服务器全身心的响应数据，所以B&#x2F;S结构的系统在网络中传送的数据量比较大。) 体验差（界面不是那么酷炫，因为浏览器只支持三个语言HTML CSS JavaScript。在加上速度慢。)不安全(所有的数据都在服务器上，只要服务器发生火灾，地震等不可抗力，最终数据全部丢失。)… 一个WEB系统的通信原理？通信步骤： 用户输入网址（url） 域名解析器进行域名解析(ping的百度ip):http://180.101.49.12:80/index.html 浏览器软件在网络中搜索180.101.49.12这台主机 定位到主机的80端口对应的服务器软件 80端口对应的服务器软件得知浏览器请求的资源名是：index.html 80端口服务器软件找到文件后将数据响应到浏览器上 浏览器接收数据代码 浏览器渲染，执行html css js 代码，完成通信 关于WEB服务器软件 WEB服务器软件都有哪些呢?(这些软件都是提前开发好的。) Tomcat (WEB服务器) jetty (WEB服务器) IBOSS(应用服务器) WebLogi (应用服务器) WebSphere(应用服务器) 应用服务器和WEB服务器的关系? 应用服务器实现了lavaEE的所有规范。(JavaEE有13个不同的规范。) WEB服务器只实现了lavaEE中的Servlet + JSP两个核心的规范。 应用服务器是包含WEB服务器的。 例如JBOSS中内嵌了一个Tomcat服务器。 Tomcat下载 apache官网地址: https://www.apache.orglo tomcat 官网地址: https://tomcat.apache.orgo tomcat开源免费的轻量级WEB服务器。 tomcat的logo是一只公猫（寓意表示Tomcat服务器是轻巧的，小巧的，果然，体积小，运行速度快，只实现了Servlet+SP规范) tomcat是java语言写的。 tomcat服务器要想运行，必须先有jre (Java的运行时环境) Tomcat服务器要想运行，需要先有jre，所以要先安装IDK，配置java运行环境。| JAVA_HOME&#x3D;C:\\Program FilesyJavaVyjdk-17.0.1 PATH&#x3D;%JAVA_HOME%\\bin Tomcat服务器的安装配置:绿色版本的安装很简单，直接zip包解压即可。解压就是安装。启动Tomcat: bin目录下有一个文件: startup.bat,通过它可以启动Tomcat服务器。 xxx.bat文件是个什么文件? bat文件是windows操作系统专用的， bat文件是批处理文件，这种文件中可以编写大量的windows的dos命令，然后执行bat文件就相当于批量的执行dos命令。 startup.sh，这个文件在windows当中无法执行，在Linux环境当中可以使用。在Linux环境下能够执行的是shell命令，大量的shell命令编写在shell文件当中，然后执行这个shell文件可以批量的执行shell命令。 tomcat服务器提供了bat和sh文件，说明了这个tomcat服务器的通用性。 分析startup.bat文件得出，执行这个命令，实际上最后是执行: catalina.bat文件。catalina.bat文件中有这样一行配置: MAINCLASS&#x3D;org.apache.catalina.startup.Bootstrap(这个类就是main方法所在的类。) tomcat服务器就是Java语言写的，既然是java语言写的，那么启动Tomcat服务器就是执行main方法。我们尝试打开dos命令窗口，在dos命令窗口中输入startup.bat来启动tomcat服务器。显然直接启动行不通，还有两个环境变量需要配置: PATH&#x3D;%CATALINA_HOME%\\bin CATALINA_HOME&#x3D;Tomcat服务器的根 关于Tomcat服务器的目录 bin:这个目录是Tomcat服务器的命令文件存放的目录，比如:启动Tomcat，关闭Tomcat等。 conf:这个目录是Tomcat服务器的配置文件存放目录。(server.xml文件中可以配置端口号，默认Tomcat端口是8080) lib:这个目录是Tomcat服务器的核心程序目录，因为Tomcat服务器是Java语言编写的，这里的jar包里面都是class文件。 logs:Tomcat服务器的日志目录，Tomcat服务器启动等信息都会在这个目录下生成日志文件。 temp: Tomcat服务器的临时目录。存储临时文件。 webapps:这个目录当中就是用来存放大量的webapp (web application: web应用) work:这个目录是用来存放ISP文件翻译之后的java文件以及编译之后的class文件。 总结一下配置Tomcat服务器需要哪些环境变量? CATALINA_HOME&#x3D;Tomcat服务器的根 PATH&#x3D;%JAVA_HOME%lbin;%CATALINA_HOME%1bin JAVA_HOME&#x3D;JDK的根 启动Tomcat: startup 关闭ITomcat:top (shutdown.bat文件重命名为stop.bat，为什么?原因是shutdown命令和windows中的关机命令冲突。所以修改一下。) 怎么测试Toihcat服务器有没有启动成功呢? 打开浏览器，在浏览器的地址栏上输入URL即可:http://ip地址:端口(8080) ，这里ip用本地ip127.0.0.1或者localhost 实现一个最基本的web应用(这个web应用中没有java小程序) 第一步:找到CATALINA_HOMEwebapps目录 因为所有的webapp要放到webapps目录下。(没有为什么，这是Tomcat服务器的要求。如果不放到这里，Tomcat服务器找不到你的应用。) 第二步:在CATALINA_HOME&#x2F;webapps目录下新建一个子目录，起名:oa 这个目录名oa就是你这个webapp的名字。 第三步:在oa目录下新建资源文件，例如:index.html,并编写内容 第四步:启动Tomcat服务器 第五步:打开浏览器，在浏览器地址栏上输入这样的URL: http://127.0.0.1:8080/oa/index.html 思考一个问题: 我们在浏览器上直接输入一个URL，然后回车。这个动作和超链接一样吗?既然是一样的，我们完全可以使用超链接。 html123456&lt;!--注意以下的路径，以/开始，带项目名，是一个绝对路径。不需要添加http://127.0.0.1:8080--&gt;&lt;a href=&quot;/oa/test1.html&quot;&gt;跳转测试1&lt;/a&gt;&lt;!--多个层级也没有关系,正常访问即可--&gt;&lt;!--注意:目前前端上的路径都以“/&quot;根目录开始的，都是加项目名的--&gt; &lt;a href=&quot;/oa/1/2/test2.html&quot;&gt;跳转测试2&lt;/a&gt; http://127.0.0.1:8080/oa/userList.html 访问这个地址，可以展示一个用户列表页面。但是这个用户列表页面是写死在HTML文件当中的。这种资源我们称为静态资源。怎么能变成动态资源。显然需要连接数据库。 连接数据库需要JDBC程序，也就是说需要编写Java程序连接数据库，数据库中有多少条记录，页面上就显示多少条记录，这种技术被称为动态网页技术。(动态网页技术并不是说页面中有flash动画。动态网页技术是说页面中的数据是动态的，根据数据库中数据的变化而变化。) 有哪些角色(在整个BS结构的系统当中，有哪些人参与进去了) 浏览器软件的开发团队（(浏览器软件很多:谷歌浏览器、火狐浏览器、IE浏览器….) WEB Server的开发团队(WEB Server这个软件也是太多了:Tomcat、Jetty、WebLogic、JBQSS、WebSphere..o DB Server的开发团队(DB Server这个软件也是太多了:Oracle、MySQL…… webapp的开发团队(WEB应用是我们做为JavaWEB程序员开发的)角色和角色之间需要遵守哪些规范，哪些协议 webapp的开发团队和WEB Server的开发团队之间有一套规范: JavaEE规范之一Servlet规范。Servlet规范的作用是什么? WEB Server和webapp解耦合。 Browser和WebServer之间有一套传输协议:HTTP协议。(超文本传输协议。 webapp开发团队和DB Server的开发团队之间有—套规范:JDBC规范。 二、Servlet本质三、Servlet对象生命周期四、适配器设计模式五、GenericServlet源码分析六、ServletConfig接口详解七、ServletContext接口详解八、HTTP协议剖析九、GET和POST本质区别及选择十、HttpServlet源码分析十一、模板方法设计模式十二、WEB欢迎页十三、HttpServletRequest源码分析十四、乱码解决方案十五、转发和重定向深度剖析十六、Servlet注解式开发十七、session原理剖析十八、cookie 原理剖析","categories":[],"tags":[]},{"title":"AJAX和JQuery","slug":"AJAX和JQuery","date":"2022-09-29T00:54:43.000Z","updated":"2022-09-29T08:46:14.032Z","comments":true,"path":"2022/09/29/AJAX和JQuery/","link":"","permalink":"http://tanquerayds.site/2022/09/29/AJAX%E5%92%8CJQuery/","excerpt":"","text":"AJAX 意义 可以实现网页的局部刷新，让程序更快响应用户操作 概念 是一种综合的技术，内容包括JavaScript : 创建XMLHttpRequest对象,调用属性或方法dom ：处理dom，更新select的数据css：处理视图，更新美化Servlet：服务器端技术数据格式：json，它之前是xml以上技术的综合使用叫做AJAX（Asynchronous JavaScript and XML） ajax 核心是javascript和xml（json）：使用js操作XMLHttpRequest，和服务器交互使用json数据格式 全局刷新和局部刷新 1）全局刷新:使用form,href等发起的请求是全局刷新。用户发起请求，视图改变了，跳转视图，使用新的数据添加到页面。缺点: 传递数据量比较大。占用网络的带宽 浏览器需要重新的渲染整个页面。 用户的体验不是那么好 2)局部刷新︰在当前页面中，发起请求，获取数据，更新当前页面的dom对象。对视图部分刷新特点: 数量比较小，在网络中传输速度快。 更新页面内容，是部分更新页面，浏览器不用全部渲染视图。 在一个页面中，可以做多个局部刷新 从服务器获取的是数据，拿到更新视图 异步请求对象 通过创建异步对象XMLHttpRequest操作属性方法完成局部刷新 在局部刷新，需要创建一个对象，代替浏览器发起请求的行为，这个对象存在内存中。代替浏览器发起请求并接收响应数据。这个对象叫做异步请求对象。全局刷新是同步行为，局部刷新是异步行为[浏览器数据没有全部更新]这个异步对象用于在后台与服务器交换数据。XMLHttpRequest 就是异步对象异步对象是在浏览器内部的一种javascript对象。各大浏览器都能支持异步对象使用。 AJAX实例练习JQuery基础选择器过滤器函数事件AJAX","categories":[],"tags":[]},{"title":"JavaScript","slug":"JavaScript笔记","date":"2022-09-22T02:16:43.000Z","updated":"2022-09-29T08:50:45.837Z","comments":true,"path":"2022/09/22/JavaScript笔记/","link":"","permalink":"http://tanquerayds.site/2022/09/22/JavaScript%E7%AC%94%E8%AE%B0/","excerpt":"","text":"JavaScript概述： 脚本语言（解释型语言）程序可被笔记本直接打开,其前身是网景的liveScript，sun公司为其命名javaScript，微软为了抢蛋糕做了个JScriptECMA（欧洲计算机制造协会）统一制定了262标准ECMAScript，同时JScript和JavaScript都遵守这个标准 JavaSrcipt三大块： 核心语法：ECMAScript DOM : 对节点进行规范操作，dom规范由W3C指定 BOM：对浏览器本身操作，例后退，地址栏，弹窗等DOM： Document Object Model：文档对象模型BOM： Browser Object Modeel:浏览器对象模型 ECMAScript嵌入JS的三种方式第一种 行间事件 1、需求:用户点击以下这个按钮，弹出一个对话框，对话框上显示: hello world2、JavaScript是一种事件驱动型的编程语言，通常都是在发生某个事件的时候，去执行某段代码。其中事件包括很多，例如:鼠标单击事件click，另外还有其它事件，例如:mouseover是鼠标经过事件等。并且在JavaScript当中任何一个事件都有对应的事件句柄。例如: click对应的事件句柄是onclick, mouseover对应的事件句柄是onmouseover。3、所有的事件句柄都是以标签的属性形式存在。例如以下input button就有一个onclick这样属性。只要有用户点击了以下的这个按钮对象，此时按钮对象上发生了鼠标单击事件，那么注册在onclick事件句柄当中的s代码会被执行! onclick后面代码实际上是浏览器负责执行的。4、onclick&#x3D;”后面的代码”并不是在浏览器打开的时候执行，浏览器打开的时候，只是将这个代码注册给onclick事件句柄了。等待该按钮的click事件发生，只要发生，后面代码会被事件监听器调用。5、怎么使用Js代码弹窗?在s当中有一个内置的BOM对象，可以直接拿来使用，全部小写: window其中window对象有一个方法&#x2F;函数叫做alert，这个函数专门用来弹出对话框!6、 window .alert( ‘ hello world! ‘);弹窗的s代码。通过这个代码可以知道:Js中的字符串可以使用单引号括起来，也可以使用双引号。s中的一条语句可以“;”结尾，也可以不以“;”结尾。 html123456&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;点我1&quot; onclick=&quot;window.alert(&#x27;hello word&#x27;)&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;点我2&quot; onclick=&quot;window.alert(&#x27;hello world&#x27;)window.alert(&#x27;哼&#x27;)window.alert(&#x27;啊啊啊啊啊啊啊&#x27;)&quot;/&gt;&lt;/body&gt; 第二种 脚本块html1234567891011121314151617181920212223&lt;script&gt;//可任意位置alert(&#x27;hello start&#x27;);&lt;/script&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;嵌入JS第二种方式，脚本块&lt;/title&gt;&lt;script&gt;/*可任意位置*///从上往下依次执行alert(&#x27;hello world&#x27;); alert(&#x27;hello zhangsan&#x27;); alert(&#x27;hello lisi&#x27;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt;alert(&#x27;hello end&#x27;);&lt;/script&gt;&lt;/html&gt; 第三种 引入外部独立文件html12src的=后面不能有空格&lt;script type=&quot;text/javascript&quot; src =&quot;路径&quot;&gt;&lt;/script&gt; 函数初步语法格式：html12345678910111213JavaScript语法格式function 函数名(形式参数列表)&#123; 函数体;&#125;例如:function sum(a, b)&#123; return a + b;&#125;函数名:sum形式参数列表是:a和bJs中的函数返回值类型是不需要指定的,因为可以返回任何类型的数据,没有限制 函数调用html12345678910111213141516//函数必须手动调用才会执行//且函数声明优先级高，打开网页时先声明函数，因此调用顺序可写在函数前面//调用sum函数sum(true,1); //语法松散//编写函数function sum(x, y)&#123; alert(x + &quot;,&quot; + y);&#125;//调用sum函数sum();//调用sum函数sum(1);//调用sum函数sum(1,2);//调用sum函数sum(1,2,3); 声明html123456789101112131415//第一种声明方式function mysum1(a, b)&#123; return a + b;&#125;//调用函数mysum1(10,20)//第二种声明方式mysum2 = function(a, b)&#123; return a + b;&#125;//调用函数var result = mysum2(10,20);alert(result) 重载 后浪推前浪，前浪死在沙滩上 调试 关于JS的的调试?首选方案是: alert(),在程序的某个位置先使用alert弹出某个变量的值,看看是否是你需要的,通过alert可以调试Js代码.另外一种方案是:采用浏览器自带的调试插件:F12F12这个插件中比较重要的面板:控制台查看器网络掌握以上三个面板!!! 变量 js的变量怎么声明? var 变量名; var i; 怎么赋值? 变量名 &#x3D; 值; 一行上能声明多个变量吗? var &#x3D; a,b,c&#x3D;300;声明3个变量, a,b,c,并且c赋值300，其中a和b变量没有赋值，系统默认赋值undefinedundefined在JS中是一个具体的值,这个值就是undefined 重点:Js语言是一种弱类型语言，没有编译阶段，直接浏览器打开解释执行， 在js中声明变量时不需要指定变量的数据类型， 程序在运行过程当中，赋什么类型的值,变量就是什么数据类型, 并且变量的数据类型是可变的。var i;i &#x3D; 100; 到这里i是整数型i &#x3D; false;到这里i就是布尔类型了i &#x3D; 3.14;i &#x3D; new 0bject();遵循就近原则，注意： 函数体中声明的变量称为局部变量，当函数体中的局部变量没有声明且赋值了 则作为全局变量，没有赋值则报错 数据类型 关于JS的数据类型1、JS中声明变量不需要指定变量数据类型呀，为什么还要学习数据类型呢?例如: var i &#x3D; 100; var d &#x3D; 3.14;在Js中学习数据类型也不是为了声明变量，是为了理解s程序的底层原理。我们起码要知道100是什么类型，3.14是什么类型，怎么存储的…. 2、ES6之前JS的数据类型包括6种: Undefined Null Number Boolean String Object 其中:Undefined、Number、String、Boolean、Null都属于原始类型（或者叫做基本数据类型)其中:object属于引用数据类型(或者叫做对象类型) 3、在ES6之后引入了其它新的类型，知道就行: Symbol BigInt注意:Es6之后是8种类型。Es6之前是6种类型。 4、 typeof运算符返回值（非常重要) “undefined” “number” “string” “boolean” “object” “function”并且以上6个字符串都是全部小写的! 5、在Js中判断两个字符串是否相等，应该使用“&#x3D;&#x3D;”,JS中没有equals函数! ! ! 练习 html1234567891011&lt;script type=&quot;text/javascript&quot;&gt;function m(x , y)&#123; var z = x+y; o = 1; alert(z)&#125;//记得关闭百度药丸var d = null;console.log(typeof o);//没有声明的o返回的类型undefinedconsole.log(typeof d)//null返回的类型object&lt;/script&gt; Undefined类型 只有一个值，值就是：undefined 当一个变量没有手动赋值，系统默认赋值undefined Null类型html12345678910/*Null类型1.null类型也属于原始类型3.Null类型只有一个值：null3.typeof null 运算结果是&quot;object&quot;*/var i = null;var j ;console.log(typeof i);//objectconsole.log(typeof j);//undefined Number类型 1、Number类型属于原始类型。2、Number类型特殊的值: NaN Infinity 3、 NaN?&amp;nbsp;&amp;nbsp; Not a Number，表示不是一个数字。但NaN是一个值。它属于Number类型。4、什么情况下结果是一个NaN?&amp;nbsp;&amp;nbsp; 当一个数学表达式的运算结果本应该返回一个数字，但是最终无法返回一个数字的时候，结果是NaN。例如100&#x2F;string5、Infinity是无穷大，当除数是e的时候，最终计算结果是无穷大。例如100&#x2F;06、强调:&amp;nbsp;&amp;nbsp; JavaScript当中的Number类型代表了java中的基本数据类型:&amp;nbsp;&amp;nbsp; byte、short 、int 、 long、float 、double、 html1234567891011121314151617&lt;script&gt;/*Number类型1.NaN和Infinity2.相当于java中基本数据类型*/var k =NaN;console.log(typeof k);//&quot;number&quot;var result = 100/&quot;中&quot;;console.log(result);//&quot;NaN&quot;var v = Infinity;console.log(typeof v);//&quot;number&quot;var retVale = 100/0;console.log(retVale);//Infinity&lt;/script&gt; 7、在Number类型这一块，有一个函数叫做:isNaN()函数，这个函数最终返回布尔类型，返回true表示不是一个数字，返回false表示是一个数字。(双重否定) isNaN : is Not a Numbertrue:表示不是一个数字,返回false表示是一个数字,这个函数有一个特点，它会首先尝试将“数据”转换成数字，如果转换失败了，则结果就是true。转换为数字成功了，那么结果就是false。 8、在Number类型这一块还有一个函数叫做:Number()函数，这个函数的作用是可以将不是数字类型的数据转换成数字类型的数据。 html1234567891011function sum(x,y)&#123; if(isNaN(x)||isNaN(y))&#123;//只要存在一个ture就表示参数里有非数字 alert(&quot;参与求和数据必须都是数字&quot;)&#125;else&#123; alert(Number(x)+Number(y)) &#125;&#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;sum&quot; onclick=&quot;sum(true,100)&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;sum&quot; onclick=&quot;sum(&#x27;中国&#x27;,100)&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;sum&quot; onclick=&quot;sum(&#x27;123&#x27;,100)&quot;&gt; 9、parseInt()函数，将字符串数字转换成数字，并且取整。向下取整。10、Math.ceil()，这是一个Math工具类中的一个函数，向上取整。 null undefined NaN 的区别？html1234567891011121314151617181920212223242526272829303132/* 1. == 和 === 有什么区别？ == 等同运算符，只比较值是否相等。 === 全等运算符，既比较值也比较数据类型是否相等 2. null undefined NaN 的区别？ 类型都是不一样的，null和undefined是值等同关系*///== 和 === 区别var v1 = true;var v2 = 1;console.log(v1 == v2);//trueconsole.log(v1 === v2);//falsevar v3 = 1;condole.log(v2 === v3);//true//null undefined NaN 的区别//类型比较console.log(typeof null)// &quot;object&quot;console.log(typeof NaN)//&quot;number&quot;console.log(typeof undefined)//&quot;undefined&quot;//==比较console.log(null == NaN)//falseconsole.log(undefined == NaN)//falseconsole.log(null == undefined)//true//===比较console.log(null === NaN)//falseconsole.log(null === undefined)//falseconsole.log(undefined === NaN)//false Boolean类型 1、Boolean类型属于原始类型。2、Boolean类型只有两个值:true,false，没有其他值。3、Boolean类型中有一个函数:Boolean()函数，这个函数的作用是?&amp;nbsp;&amp;nbsp;&amp;emsp;将不是布尔类型的转换成布尔类型。&amp;nbsp;&amp;nbsp;&amp;emsp;转换规律是什么?&amp;nbsp;&amp;nbsp;&amp;emsp;“只要有东西” 结果就是true。同时这个函数会被js隐式调用 html1234567891011121314151617181920212223/*Boolean类型*/console.log(Boolean(1));//trueconsole.log(Boolean(0));//falseconsole.log(Boolean(&quot;字符串&quot;));//trueconsole.log(Boolean(&quot;&quot;));//falseconsole.log(Boolean(Infinity));//trueconsole.log(Boolean(NaN));//falseconsole.log(Boolean(new Object()));//trueconsole.log(Boolean(null));//falseconsole.log(Boolean(undefined));//false//Boolean()函数隐式调用var i = 10;while(i)&#123;//这里相当于Boolean(i) alert(i); i--;&#125; String类型 1、string类型属于原始类型（基本数据类型)2、在JS中怎么定义字符串，包括两种方式: var s &#x3D;”字符串”;var s &#x3D;’字符串’; var s &#x3D; new String(“字符串”); 3、在JS当中提供了创建字符串的两种方式:如果采用这种方式创建的字符串就属于原始类型!var s &#x3D; “hello” ;如果采用这种方式创建的字符串就属于object类型，这里使用了object类的子类String,String类是JS内置的，可以直接使用:var s&#x3D;new String( “hello”);4、在JS中不管是原始类型的字符串，还是object类型的字符串，他们的方法和属性都是通用的。5、String当中的常用属性和方法:常用属性: length 属性 获取字符串长度常用方法: charAt() 获取指定下标位置的字符concat() 连接字符串indexOf() 获取某个字符串在当前字符串中第一次出现处的索引lastIndex0f() 获取某个字符串在当前字符串中最后一次出现处的索引replace方法替换split() 拆分字符串substr(startIndex,length) 截取字符串substring(startIndex,endIndex) 截取字符串,不包括endIndextoLowerCase() 转小写toUpperCase() 转大写 html1234567891011121314151617181920212223242526272829303132/*String类型*///两种方式var s1 = &quot;hello&quot;;console.log(typeof s1);//Stringvar s2 = new String(&quot;hello&quot;);console.log(typeof s2);//Object//常用方法练习console.log(&quot;abcdef.length&quot;);//6console.log(&quot;http://www.baidu.com&quot;.charAt(3))//pconsole.log(&quot;abc&quot;.concat(&quot;def&quot;));//abcdefconsole.log(&quot;username=zhangsan&amp;password=123&quot;.indexOf(&quot;=&quot;));//8console.log(&quot;username=zhangsan&amp;password=123&quot;.lastIndexOf(&quot;=&quot;));//26console.log(&quot;1980-10-11&quot;.replace(&quot;-&quot;,&quot;,&quot;));//1980,10,11(替换所有需要正则表达式)//拆分字符返回一个数组var arr = &quot;1980-11-12&quot;.split(&quot;-&quot;);//js没有arr[]这种写法for(var i = 0;i &lt; arr.length; i++)&#123; console.log(arr[i])&#125;//对于substr和substring来说，只传一个参数没有区别console.log(&quot;abcdef&quot;.substr(2));//cdefconsole.log(&quot;abcdef&quot;.substring(2));//cdef//传两个参数//substr(startIndex,length)console.log(&quot;abcdef&quot;.substr(2,3));//cde//substring(startIndex,endIndex),不包括endIndexconsole.log(&quot;abcdef&quot;.substring(2,3));//c object类型: 1、在js当中内置了一个类型object，可以将object类型看做是所有对象的超类&#x2F;基类。2、在Js当中默认定义的类型，没有特殊说明的话，默认继承object。3、Object类型中有哪些通用属性和方法呢?属性:prototype 属性| constructor 属性方法:toLocalestring 方法| toString 方法│ valueof 方法重点掌握:prototype属性。(prototype翻译为原型）这个属性可以给对象动态扩展属性和方法。 html123456789101112131415161718192021222324/* Object类型*/var obj = new Object();console.log(typeof obj);//prototype属性//给Object类型的对象扩展一个doSome()方法Object.prototype.doSome = function()&#123;console.log(&quot;测试prototype属性&quot;)&#125;//给Object类型的对象扩展一个userName属性Object.prototype.userName = &quot;zhangsan&quot;;//调用方法和属性obj.doSome();//测试prototype属性console.log(obj.userName);//zhangsan//给String扩展方法String.prototype.mysubstr = function(startIndex,length)&#123; return this.substr(startIndex,length);&#125;console.log(&quot;abcdef&quot;.mysubstr(2,3));//cdeconsole.log(&quot;kingsoft&quot;.mysubstr(3,3));//gso 类 1、在JS中怎么定义类?包括两种方式 html123456789101112131415161718192021222324252627282930313233343536373839404142第一种方式:function类名(形式参数列表&#123; this.属性名=参数; this.属性名=参数; this.方法名 = function()&#123; &#125;&#125;第二种方式:类名= function(形式参数列表)&#123; this.属性名=参数; this.属性名=参数; this.方法名 = function()&#123; &#125;&#125;//可以看出类和函数的定义方式相同，也就是说既是一个函数,同时又是一个类的定义,函数名是:sayHello,类名是:sayHello/*function sayHello()&#123;&#125; */sayHello = function()&#123;&#125;//关键看你怎么调用,如果没有使用new运算符调用,表示普通函数调用.不会在堆中new对象sayHello( );//使用new运算符去调用这个函数,显然是把它当做一个类来看待,这个会导致浏览器的堆当中开辟一个新对象!var obj = new sayHello(); //obj是一个引用,保存内存地址指向对象!var obj2 = new sayHello();&lt;script type=&quot;text/javascript&quot;&gt; //创建员工类 function Emp(id,name)&#123; this.id = id; this.name = name; this.working = function()&#123; console.log(this.name + &quot;正在工作&quot;) &#125; alert(&#x27;ddd&#x27;); &#125; var e1 = new Emp(1,&#x27;as&#x27;); e1.working();//调用方法 Emp(2,3);//也可直接当方法调用，就很怪 console.log(&quot;e1.id=&quot; + e1.id);//调用属性 //属性还可以这样调用，语法：引用名[&quot;属性名&quot;] console.log(&quot;e1.id=&quot; + e1[&quot;id&quot;]);&lt;/script&gt; 事件 常用事件： blur&amp;emsp;去焦点 focus&amp;emsp;获得焦点 click&amp;emsp;鼠标单击 dblclick&amp;emsp;鼠标双击 keydown&amp;emsp;键盘按下 keyup&amp;emsp;键盘弹起 mousedown&amp;emsp;鼠标按下 mouseover&amp;emsp;鼠标经过 mousemove&amp;emsp;鼠标移动 mouseout&amp;emsp;鼠标离开 mouseup&amp;emsp;鼠标弹起 submit&amp;emsp;表单提交 reset&amp;emsp;表单重置 select&amp;emsp;文本被选定 change&amp;emsp;下拉列表选中项改变,或文本框内容改变 load&amp;emsp;页面加载完毕工 事件测试 点击显/隐内容 html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;/script&gt;1.测试失去焦点事件:&lt;input type=&quot;text&quot; onblur=&quot;console.log(&#x27;失去焦点了&#x27;)&quot;&gt;&lt;br&gt;2.测试获得焦点事件:&lt;input type=&quot;text&quot; onfocus=&quot;console.log(&#x27;获取焦点了&#x27;)&quot;&gt;&lt;br&gt;3.测试鼠标单击事件:&lt;input type=&quot;text&quot; onclick=&quot;console.log(&#x27;鼠标单机了&#x27;)&quot;&gt;&lt;br&gt;4.测试鼠标双击事件:&lt;input type=&quot;text&quot; ondblclick=&quot;console.log(&#x27;鼠标双击了&#x27;)&quot; /&gt;&lt;br&gt;5.测试键盘按下事件:&lt;input type=&quot;text&quot; onkeydown=&quot;console.log(&#x27;键盘按下了&#x27;)&quot; /&gt;&lt;br&gt;6.测试键盘弹起事件:&lt;input type=&quot;text&quot; onkeyup=&quot;console.log(&#x27;键盘弹起了&#x27;)&quot; /&gt;&lt;br&gt;7.测试鼠标按下事件:&lt;span id=&quot;mouse&quot; onmousedown=&quot;console.log(&#x27;鼠标按下了&#x27;)&quot;&gt;鼠标测试区域&lt;/span&gt;&lt;br&gt;8.测试鼠标经过事件:&lt;span id=&quot;mouse&quot; onmouseover=&quot;console.log(&#x27;鼠标经过了&#x27;)&quot;&gt;鼠标测试区域&lt;/span&gt;&lt;br&gt;9.测试鼠标移动事件:&lt;span id=&quot;mouse&quot; onmousemove=&quot;console.log(&#x27;鼠标在移动&#x27;)&quot;&gt;鼠标测试区域&lt;/span&gt;&lt;br&gt;10.测试鼠标离开事件:&lt;span id=&quot;mouse&quot; onmouseout=&quot;console.log(&#x27;鼠标离开了&#x27;)&quot;&gt;鼠标测试区域&lt;/span&gt;&lt;br&gt;11.测试鼠标弹起事件:&lt;span id=&quot;mouse&quot; onmouseup=&quot;console.log(&#x27;鼠标弹起了&#x27;)&quot;&gt;鼠标测试区域&lt;/span&gt;&lt;br&gt;鼠标事件结合:&lt;div id=&quot;mouse&quot; onkeyup=&quot;console.log(&#x27;键盘弹起了&#x27;)&quot;onmousedown=&quot;console.log(&#x27;鼠标按下了&#x27;)&quot;onmouseover=&quot;console.log(&#x27;鼠标经过了&#x27;)&quot;onmousemove=&quot;console.log(&#x27;鼠标在移动&#x27;)&quot;onmouseout=&quot;console.log(&#x27;鼠标离开了&#x27;)&quot;onmouseup=&quot;console.log(&#x27;鼠标弹起了&#x27;)&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt; 12.测试表单提交和重置事件:&lt;form onsubmit=&quot;console.log(&#x27;表单提交了&#x27;)&quot; onreset= &quot;(console.log(&#x27;表单重置了&#x27;))&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;&lt;/form&gt;&lt;br&gt;14.测试文本被选定事件:&lt;br&gt;&lt;textarea rows=&quot;1&quot; cols=&quot;30&quot; onselect=&quot;console.log(&#x27;文本被选中了&#x27;)&quot;&gt;&lt;/textarea&gt;&lt;br&gt;&lt;input type=&quot;text&quot; onselect=&quot;console.log(&#x27;文本被选中了&#x27;)&quot;&gt;&lt;br&gt;15.测试下拉列表选中项改变,或文本框内容改变事件:&lt;select onchange=&quot;console.log(&#x27;选项被修改！&#x27;)&quot;&gt;&lt;option value=&quot;&quot;&gt;--请选择你的爱好&lt;/option&gt;&lt;option value=&quot;gz&quot;&gt;唱&lt;/option&gt;&lt;option value=&quot;gz&quot;&gt;跳&lt;/option&gt;&lt;option value=&quot;gz&quot;&gt;rap&lt;/option&gt;&lt;option value=&quot;gz&quot;&gt;篮球&lt;/option&gt;&lt;/select&gt;&lt;/body&gt; 事件测试截图 注册事件的第一种方式 在标签中使用”事件句柄”，在事件句柄后面编写JS代码当这个事件句柄对应的事件发生之后，注册在事件句柄当中的这个代码被监听器调用。即onclick鼠标单击的事件句柄，只有当鼠标单击事件click发生之后，注册在onclick后面的代码会被执行。下面的button标签中的sayHello()函数，在页面打开的时候并不会执行，只是在页面打开的过程中完成事件的绑定，完成事件的注册，以后只有当该事件发生之后sayHello()函数才会执行，像这种函数有一种特殊的称谓:回调函数。英语单词叫做: callback function这个回调函数的特点是: 监听器负责调用，程序员不负责调用。 当事件发生之后，监听器会负责调用该函数。 html1&lt;input type=&quot;button&quot; value=&quot;hello jack&quot; onclick=&quot;sayHello()&quot;/&gt; 获取节点 在学习第二种方式前得先知道如何根据id获取元素&#x2F;节点对象 在JS当中有一个内置的隐含的对象叫做:document document代表整个HTML文档document对象是DoM的顶级对象, DoM中的老大 在Js当中有一个内置的隐含的对象叫做:window window代表整个浏览器窗口window对象是Bon的顶级对象,BOM中的老大 严格意义上来说, window是包含document的其中document有一个函数可以通过id获取节点：getElementById（）var mybtnElt &#x3D; document.getElementById(“mybtn”);获取节点后可以对其属性进行操作，这自然也包括了回调函数 JS注册事件的第二种方式html1234567891011121314151617181920&lt;input type=&quot;button&quot; value=&quot;hello&quot; id=&quot;hellobtn&quot;/&gt;&lt;script type=&quot;text/javascript&quot;&gt;//定义一个函数 function sum()&#123; console.log( &quot;sum function invoke! &quot;)&#125;//根据id获取button对象var hellobtnElt = document.getElementById(&quot;hellobtn&quot;);//元素中有什么属性,就能&quot;点&quot;什么.//这行代码在页面打开的时候会执行，这行代码执行的意义是:将sum这个回调函数绑定到hellobtn的click事件上//这个回调函数sum在什么时候执行? click事件发生之后才会被监听器调用!hellobtnElt.onclick = sum//不要这样写:hellobtnElt.onclick = sum()//回调函数可以是一个匿名函数//这行代码的执行只是完成事件click的注册,给click事件注册一个回调函数//执行到这的时候，回调函数并不会被执行。//只有当这个按钮发生click事件之后,这个回调函数会自动被监听器来调用hellobtnElt.onclick = function( )&#123; console.log(&quot;我是一个回调函数，同时我没有名字，叫做匿名函数! &quot;)&#125;&lt;/script&gt; 代码执行顺序1.代码执行顺序问题引出html123456789&lt;script&gt; //报错Uncaught TypeError: Cannot set properties of null (setting &#x27;onclick&#x27;) //id为null，代码还没执行到下面 var btnElt = document.getElementById(&#x27;btn&#x27;); btnElt.onclick = function()&#123; console.log(&#x27;按钮被点击，匿名函数被执行&#x27;) &#125;;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;点击&quot; id=&quot;btn&quot;&gt; 2.代码执行顺序问题解决html123456789&lt;script type=&quot;text/javascript&quot;&gt; function s()&#123; var btnElt = document.getElementById(&#x27;btn&#x27;); btnElt.onclick = function()&#123; console.log(&quot;按钮被点击，匿名函数被执行&quot;) &#125; &#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;点击&quot; id=&quot;btn&quot;&gt; 3.代码执行顺序问题优化html1234567891011&lt;script&gt; function test()&#123; console.log(&#x27;hello world&#x27;); &#125;; //可以用body的id来获取body节点，然后给它注册load事件，但代码还是冗余 /* var bd = document.getElementById(&#x27;bodyid&#x27;); bd.onload = test; *///window可以代替body，因此可以把load事件注册（绑定）到window上，等到事件发生之后监听器自动调用 window.onload = test();&lt;/script&gt; 4.代码执行顺序完整案例html123456789101112131415161718192021222324252627&lt;body&gt;&lt;script&gt; window.onload = function()&#123;//注册加载事件，事件触发后由监听器调用回调函数//正常写 /* var b1 = document.getElementById(&#x27;button1&#x27;); b1.onclick = function()&#123;//注册单击事件，事件触发后由监听器调用回调函数 console.log(&#x27;按钮1被单击了&#x27;) &#125; var b1 = document.getElementById(&#x27;button1&#x27;); b2.onclick = function()&#123;//注册单击事件，事件触发后由监听器调用回调函数 console.log(&#x27;按钮2被单击了&#x27;) &#125; *///简写 document.getElementById(&#x27;button1&#x27;).onclick = function()&#123; console.log(&#x27;按钮1被单击了&#x27;) &#125; document.getElementById(&#x27;button2&#x27;).onclick = function()&#123; console.log(&#x27;按钮2被单击了&#x27;) &#125; &#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;按钮1&quot; id=&quot;button1&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;按钮2&quot; id=&quot;button2&quot;&gt;&lt;/body&gt; 捕捉键值html123456789101112&lt;script&gt; window.onload = function()&#123; document.getElementById(&#x27;username&#x27;).onkeydown = function(x)&#123; //事件发生后监听器会调用此函数并传入一个键盘事件对象，这个对象有keyCode属性 //其中值为13代表回车，27代表ESC if(x.keyCode == 13)&#123; console.log(&quot;捕捉到回车键，可以进行相关操作&quot;) &#125; &#125; &#125;&lt;/script&gt;&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; 运算符void 1、和java一样Js当中也有很多运算符算术运算符逻辑运算符关系运算符位运算符三目运算符赋值运算符…2、这里主要学习一下JavaScript当中的void和typeof运算符。 typeof 运算符:可以在程序运行阶段动态获取变量的数据类型，结果有6个字符串:“ number” “undefined” “boolean” “string” “object” “function” void 运算符：语法格式： void(表达式)执行表达式但不返回任何结果 使用场景的话像是设置超链接执行js代码但不跳转，超链接默认空字符串也就是本地地址，需要把地址去掉： html1&lt;a href=&quot;javascript:void(0)&quot; onclick = alert(&#x27;执行js代码&#x27;)&gt;&lt;/a&gt; 控制语句 1、JS中的控制语句，基本和java相同选择结构: if语句 switch 语句循环结构: for while do . .while 转向语句: break continue return 2.除此之外还有两个语句需要了解for…in 和 with JavaScript1234567891011121314151617181920212223242526272829&lt;script&gt; //for..in语句 //在js中数组元素随意 var arr = [true,&quot;abc&quot;,5,false,76,3.14] //用for..in语句遍历数组 for(var ddddd in arr)&#123; console.log(arr[ddddd]); &#125;; //用for..in遍历对象 Emp = function(id,name)&#123; this.id = id; this.name = name; &#125; var e = new Emp(1,&#x27;张三&#x27;); for(var suiyi in e)&#123; console.log(typeof suiyi);//String //这里不能用e.suiyi方式调用了，因为随意是字符串，所以用第二种方式对象名[&quot;属性名&quot;] console.log(e[suiyi])//第一次输出1，第二次张三 &#125; //whit语句 var x = new Emp(2,&quot;jack&quot;) with(x)&#123;//可直接调用了，有点鸡肋 console.log(id +&quot;,&quot; + name); console.log(id +&quot;,&quot; + name); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS内置对象ArrayJavaScript123456789101112131415161718192021222324252627//创建数组的第一种方式var arr = [true,&quot;abc&quot;,5,false,76,3.14];//创建数组的第二种方式var arr1 = new Array();//创建长度为0的数组var arr2 = new Array();//创建长度为3的数组var arr3 = new Array(1,53,532,2);//Array常用函数//1.push 添加元素到末尾//2.pop 取出末尾元素//push和pop联合起来，实际是模拟了栈数据结构a = [1,2,3];a.push(false);for(var i in a)&#123; console.log(a[i])&#125;console.log(a.length);//4console.log(a.pop());//falseconsole.log(a.length);//3//3.reverse翻转数组//4.join将每个元素以指定内容连接成一个字符串var array = [1,3,65,345,5467];array.reverse();//翻转for(var i in array)&#123; console.log(array[i])&#125;var str = array.join(&quot;-&quot;);console.log(str);//5467-345-65-3-1 Datehtml1234567891011121314151617181920212223242526&lt;script type=&quot;text/javascript&quot;&gt;/*JS的内置对象:Date*/var time = new Date();//获取系统当前时间console.log(time)//(中国标准时间)//进行格式转换将所有时间信息都拿出来var year = time.getFullYear();//年var month = time.getMonth(); //月var day = time.getDate(); //日var week = time.getDay();//星期几var hour = time.getHours()//时var minutes = time.getMinutes()//分var seconds = time.getSeconds()//秒var millis = time.getMilliseconds()//毫秒console.log(year + &quot;年&quot; +(month + 1) +&quot;月&quot; + day + &quot;日&quot;)//获取时间戳var now = new Date();var timeMillis = now.getTime();console.log(timeMillis);//Object中有一个函数toLocaleString()，可以将时间转换成具有本体语言环境的日期格式var strTime = time.toLocaleString();console.log(strTime);&lt;/script&gt; jsonhtml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;/*json存在的意义？实现不同语言的数据交互概念：json是一种数据格式，本质是字符串eval函数：可以将json字符串解释转成json对象json对象：语法格式为(键:值,键:值...),其中值为任意内容(json对象,集合,字符串...)java和javascript两个语言怎么交换数据?获取：java的JDBC连接数据库查询数据，然后将数据拼接成json格式的字符串传给javascript，转换：然后在javascript当中把json格式的字符串转换成json对象，操作：可以从json对象中取数据了，这样就完成了数据的交换。练习json+eval+innerHTML完成对节点的操作想到的问题：1.用console.log(typeof jsObj.total)这个语句查看了jsObj对象的total属性是number类型，那么我设置记录数那块用的是innerText，后面是字符串拼接没啥问题，但我测试font.innerText = jsObj.total ;这样也能通过，后面可以跟number类型吗？好吧，查了一下 innerText后面的字符串即使是一个HTML代码,也不会当做HTML执行,只是看做普通文本.2.json字符串的真实获取方式？1)使用 Ajax 方式获取2)使用 getJSON 方式获取*///三步走： 获取数据--&gt;数据转成json对象--&gt;操作对象//1.接收json字符串var jsonStr = &quot;&#123;\\&quot;total\\&quot;:3,\\&quot;student\\&quot;:[&#123;\\&quot;number\\&quot;:1,\\&quot;name\\&quot;:\\&quot;张三\\&quot;,\\&quot;hobby\\&quot;:\\&quot;唱\\&quot;&#125;,&#123;\\&quot;number\\&quot;:2,\\&quot;name\\&quot;:\\&quot;李五\\&quot;,\\&quot;hobby\\&quot;:\\&quot;跳\\&quot;&#125;,&#123;\\&quot;number\\&quot;:3,\\&quot;name\\&quot;:\\&quot;王四\\&quot;,\\&quot;hobby\\&quot;:\\&quot;rap\\&quot;&#125;]&#125;&quot;;//2.转换成json对象eval(&#x27;jsObj =&#x27; + jsonStr);//第一次写的时候把jsonStr拼接到=后面了//3.后面就是对数据的操作了window.onload = function()&#123;//显示学生总记录数//1.获取要交互数据的节点对象fontvar font = document.getElementById(&quot;record&quot;)//2.从获取的jsObj对象取出数据设置给font节点对象font.innerText = &quot;总记录:&quot;+jsObj.total +&quot;条&quot; ;//点击按钮让表格所有记录显示出来//1.获取要交互数据的节点对象tbodyvar tbody = document.getElementById(&#x27;stuBody&#x27;)//2.注册按钮单击事件document.getElementById(&#x27;but&#x27;).onclick = function()&#123;//3.从获取的jsObj对象取出数据设置给tbody节点对象var htmlStr = &#x27;&#x27;;//设置一个拼接字符串for(var i = 0;i &lt; jsObj.student.length;i++)&#123; htmlStr += &quot;&lt;tr&gt;&quot;; htmlStr += &quot;&lt;td&gt;&quot; + jsObj.student[i].number + &quot;&lt;td&gt;&quot; htmlStr += &quot;&lt;td&gt;&quot; + jsObj.student[i].name + &quot;&lt;td&gt;&quot; htmlStr += &quot;&lt;td&gt;&quot; + jsObj.student[i].hobby + &quot;&lt;td&gt;&quot; htmlStr += &quot;&lt;/tr&gt;&quot;;&#125;//4.将拼接好的字符串htmlStr设置给tbody(innerHTML)tbody.innerHTML = htmlStr;&#125;&#125;&lt;/script&gt;&lt;font id=&quot;record&quot;&gt;总记录&lt;/font&gt;&lt;input type=&quot;button&quot; value=&quot;显示所有学生记录&quot; id=&quot;but&quot;&gt;&lt;table ali&gt;&lt;tr&gt;&lt;th&gt;编号&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;爱好&lt;/th&gt;&lt;/tr&gt;&lt;tbody id=&quot;stuBody&quot;&gt;&lt;!-- &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;唱&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;李五&lt;/td&gt;&lt;td&gt;跳&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;王四&lt;/td&gt;&lt;td&gt;rap&lt;/td&gt;&lt;/tr&gt; --&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt; 正则表达式 在js中怎么创建正则表达式对象？之前学过正则,这里主要掌握语法,包括两种方式，重点使用第一种 var regExp &#x3D; &#x2F;正则表达式&#x2F;标记 内置RegExp类：var regExp &#x3D; new RegExp(“正则表达式”,”标记”)其中标记是可选项：g: 全局 globali: 忽略大小写 ignorecasegi:全局扫描且忽略大小写 js的正则表达式对象有一个很重要的函数： regExp.test(“用户输入的字符串”) 返回boolean值 BOM和DOM 区别和联系从功能区分：BOM可以通过对象方法完成对窗口的操作，DOM是对网页中元素的增删改浏览器包含网页，BOM是包含DOM的BOM顶级对象 windowDOM顶级对象 document日常使用中window.document.getElementById()可以省略为document.getElementById() DOMjs获取元素的三种方式html123456789101112131415161718192021&lt;script&gt; window.onload = function()&#123; //1.根据id获取元素 var div1 = document.getElementById(&#x27;div1&#x27;); console.log(div1) //2.根据name属性获取元素 var checkBox = document.getElementsByName(&#x27;hobby&#x27;); console.log(checkBox) //3.根据标签名获取元素 var divs = document.getElementsByTagName(&#x27;div&#x27;) console.log(divs) &#125;&lt;/script&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;3&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;4&quot;&gt;&lt;/body&gt; InnerHTML和InnerText InnerHTML用来设置或获取HTML中元素的内容。InnerText用来设置或获取HTML中元素的文本。 点击显/隐内容 html1234567891011121314151617181920212223242526&lt;style&gt; #div1&#123; background-color: aqua; border : 1px solid red; width: 100px; height: 25px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; window.onload = function()&#123; //给按钮注册鼠标单击事件，监听器检测到后调用该函数并传参（单击事件对象） document.getElementById(&#x27;but&#x27;).onclick = function()&#123; var tx = document.getElementById(&#x27;div1&#x27;) if(tx.innerText == &#x27;&#x27;)&#123; tx.innerHTML = &quot;&lt;font color = &#x27;red&#x27;&gt;不能为空&lt;/font&gt;&quot;; &#125; &#125; &#125;&lt;/script&gt; &lt;div id = &quot;div1&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;tx&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;登录&quot; id=&quot;but&quot;&gt; 复选框的全选和取消 点击显/隐内容 html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function()&#123;//1.全选框对复选框的影响//根据id获取全选框元素var selAll = document.getElementById(&quot;all&quot;);//通过name属性拿到所有复选框对象集合var hobbies = document.getElementsByName(&quot;hobby&quot;);//给全选框注册单击事件，监听器，回调函数selAll.onclick = function()&#123; for(var i = 0; i &lt; hobbies.length; i++)&#123;//遍历复选框对象集合 //即点击全选后所有复选框状态和全选框保持一致 hobbies[i].checked = selAll.checked; &#125; console.log(hobbies.length)&#125;//2.复选框对全选框的影响 for(var i = 0;i&lt;hobbies.length;i++)&#123;//遍历复选框对象集合 ////给每一个复选框注册单击事件 hobbies[i].onclick = function()&#123; //即每个复选框被单击后都要检查其它复选框是否勾选上了并用一个变量记录下来 var checkedCount = 0;/*之前有关checkedCount变量的疑问//1.这个值是共享的吗？2.之后怎么重置为0的？有这个疑问根本在于没理解事件的机制。首先肯定不是共享的，每个复选框的点击事件发生后就指定值为0，这个值用来做记录的，即开始遍历复选框对象集合，通过查看其它复选框的状态并记录，来决定是否要勾上全选框也就是说，三个复选框各自都注册了自己的单击事件，触发事件后由监听器调用各自对应的回调函数也就是说各个复选框的checkedCount值压根没啥关系，且重新调用后自然是给定的值0*///再次遍复选框对象集合？用来在此复选框被点击同时确认其它复选框的状态且记录下来 for(var i = 0; i&lt;hobbies.length;i++)&#123; if(hobbies[i].checked)&#123; checkedCount++;&#125; &#125;//检查完其它复选框状态后，决定全选框的状态 if(checkedCount == hobbies.length)&#123; selAll.checked = true; &#125;else&#123; selAll.checked = false; &#125; &#125;&#125;&#125;&lt;/script&gt;&lt;input type=&quot;checkbox&quot; id=&quot;all&quot; &gt;全选&lt;br&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; /&gt;唱&lt;br&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;/&gt;跳&lt;br&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;/&gt;rap&lt;/body&gt; 获取文本框和下拉列表的值html1234567891011121314151617181920212223242526272829303132文本框的值&lt;body&gt; &lt;script&gt; window.onload = function()&#123; document.getElementById(&#x27;but&#x27;).onclick = function()&#123; var t = document.getElementById(&#x27;text1&#x27;); alert(t.value); &#125; &#125; &lt;/script&gt; &lt;input type=&quot;text&quot; id=&quot;text1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;获取文本框信息&quot; id=&quot;but&quot;&gt;&lt;/body&gt;下拉列表的值&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; document.getElementById(&#x27;pr&#x27;).onchange = function()&#123; //this代表change事件发生的节点对象 console.log(this.value) &#125; &#125; &lt;/script&gt; &lt;select name=&quot;province&quot; id=&quot;pr&quot;&gt; &lt;option value=&quot;&quot;&gt;--选择下拉列表--&lt;/option&gt; &lt;option value=&quot;001&quot;&gt;山东&lt;/option&gt; &lt;option value=&quot;002&quot;&gt;山西&lt;/option&gt; &lt;option value=&quot;003&quot;&gt;湖南&lt;/option&gt; &lt;option value=&quot;004&quot;&gt;湖北&lt;/option&gt; &lt;/select&gt;&lt;/body&gt; 拼接html的方式，设置table的tbody 详情查看 点击跳转 表单验证 点击显/隐内容 html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;body&gt;&lt;script&gt;/* 表单验证 (1)用户名不能为空 (2)用户名必须在6-14位之间 (3)用户名只能有数字和字母组成，不能含有其它符号（正则表达式) (4)密码和确认密码一致 (5)统一失去焦点验证 (6)错误提示信息统一在span标签中提示，并且要求字体12号，红色。 (7)文本框再次获得焦点后，清空错误提示信息 (8)最终表单中所有项均合法方可提交 根据要求可知： 1.blur失去焦点验证 2.focus获得焦点清除提示信息 3.表单提交验证 注意这里没考虑全空的情况,那样得封装验证方法 会用到的函数 userNameVal.trim() 去除字符串前后空格 form节点.submit(); 提交表单*/window.onload = function()&#123; var userName = document.getElementById(&#x27;userName&#x27;) //1.失去焦点开始验证 //用户名验证 userName.onblur = function()&#123; //获取用户名值 var userNameVal = userName.value; //去除前后空串 var userNameStr = userNameVal.trim() //验证格式，过关斩将 regExp = /^[a-z0-9]&#123;4,16&#125;$/;//这个同时判断了长度和字母数字,但还是按需求吧 if(userNameStr.length == 0)&#123;//为空判断 document.getElementById(&#x27;userNameClassify&#x27;).innerText = &quot;不能为空&quot; &#125;else if(!(userNameStr.length &gt;= 6 &amp;&amp; userNameStr.length &lt;= 16))&#123;//长度判断 document.getElementById(&#x27;userNameClassify&#x27;).innerText = &quot;用户名长度为6~16&quot; &#125;else if(!(regExp.test(userNameStr)))&#123;//符号判断，正则 document.getElementById(&#x27;userNameClassify&#x27;).innerText = &quot;用户名只能是字母和数字&quot; &#125; &#125; //密码验证 var password = document.getElementById(&#x27;passWord&#x27;); password.onblur = function()&#123; var passStr = password.value; if(passStr.length == 0)&#123; document.getElementById(&#x27;userPasswordClassify&#x27;).innerText = &quot;不能为空&quot; &#125; &#125; //重复密码验证 var password1 = document.getElementById(&#x27;passWord1&#x27;); password1.onblur = function()&#123; var passStr1 = password1.value; if(passStr1 != password.value)&#123; document.getElementById(&#x27;userPasswordClassify1&#x27;).innerText = &quot;和原密码不一致&quot; &#125; &#125; //2.获取焦点清空之前的错误信息 userName.onfocus = function()&#123;//清空用户名提示 document.getElementById(&#x27;userNameClassify&#x27;).innerText = &quot; &quot;; &#125; password.onfocus = function()&#123;//清空密码提示 document.getElementById(&#x27;userPasswordClassify&#x27;).innerText = &quot; &quot;; &#125; password1.onfocus = function()&#123;//清空重复密码提示 document.getElementById(&#x27;userPasswordClassify1&#x27;).innerText = &quot; &quot;; &#125; //3.表单提交验证 var button = document.getElementById(&#x27;button&#x27;); button.onclick = function()&#123; //这里的验证没有重写一遍，那样的话最好把验证封装成一个方法,这里换种思路 //户鼠标离开焦点的时候会进行验证， //那么只需要自动触发blur事件,且span提示信息为空即可。 //用户名验证 document.getElementById(&#x27;userName&#x27;).focus;//先获取焦点才能失去焦点 document.getElementById(&#x27;userName&#x27;).blur; //密码验证 document.getElementById(&#x27;passWord&#x27;).focus; document.getElementById(&#x27;passWord&#x27;).blur; //重复密码验证 document.getElementById(&#x27;passWord1&#x27;).focus; document.getElementById(&#x27;passWord1&#x27;).blur; if(document.getElementById(&#x27;userNameClassify&#x27;).value != null)&#123; alert(&#x27;用户名有误&#x27;); &#125;else if(document.getElementById(&#x27;userPasswordClassify&#x27;).value != null)&#123; alert(&#x27;密码有误&#x27;); &#125;else if(document.getElementById(&#x27;userPasswordClassify1&#x27;).value != null)&#123; alert(&#x27;重复密码有误&#x27;); &#125;else&#123; var formObj = document.getElementById(&quot;userForm&quot;); formObj.submit(); alert(&#x27;提交成功&#x27;) &#125; &#125; &#125; &lt;/script&gt;&lt;form action=&quot;&quot; id=&quot;userForm&quot;&gt;&lt;!--用户名--&gt;用户名&lt;input type=&quot;text&quot; id=&quot;userName&quot; name=&quot;userName&quot;&gt;&lt;span id=&quot;userNameClassify&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;!--密码--&gt;密码&lt;input type=&quot;password&quot; id=&quot;passWord&quot; name=&quot;passWord&quot;&gt;&lt;span id=&quot;userPasswordClassify&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;!--确认密码--&gt;确认密码&lt;input type=&quot;text&quot; id = &quot;passWord1&quot;&gt;&lt;span id=&quot;userPasswordClassify1&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;!--提交按钮--&gt;&lt;input type=&quot;button&quot; id=&quot;button&quot; value=&quot;注册&quot;&gt;&lt;/form&gt;&lt;/body&gt; BOM开启和关闭窗口html1234567891011121314151617181920212223&lt;body&gt; &lt;!-- window.open(url,target) --&gt; &lt;!--默认新窗口打开--&gt; &lt;input type=&quot;button&quot; value=&quot;默认新窗口打开百度&quot; onclick=&quot;window.open(&#x27;http://www.baidu.com&#x27;)&quot;&gt; &lt;!--_block新窗口打开--&gt; &lt;input type=&quot;button&quot; value=&quot;新窗口打开百度&quot; onclick=&quot;window.open(&#x27;http://www.baidu.com&#x27;,&#x27;_block&#x27;)&quot;&gt; &lt;!--_self本页窗口打开--&gt; &lt;input type=&quot;button&quot; value=&quot;本页窗口打开百度&quot; onclick=&quot;window.open(&#x27;http://www.baidu.com&#x27;,&#x27;_self&#x27;)&quot;&gt; &lt;!--_parent父窗口打开--&gt; &lt;input type=&quot;button&quot; value=&quot;父窗口打开百度&quot; onclick=&quot;window.open(&#x27;http://www.baidu.com&#x27;,&#x27;_parent&#x27;)&quot;&gt; &lt;!--_top顶级窗口窗口打开--&gt; &lt;input type=&quot;button&quot; value=&quot;顶级窗口打开百度&quot; onclick=&quot;window.open(&#x27;http://www.baidu.com&#x27;,&#x27;_top&#x27;)&quot;&gt; &lt;!--在新窗口打开本地文件窗口--&gt; &lt;input type=&quot;button&quot; value=&quot;localFile&quot; onclick=&quot;window.open(&#x27;2-关闭窗口.html&#x27;)&quot;&gt;&lt;/body&gt;&lt;body&gt;点击关闭窗口&lt;input type=&quot;button&quot; value=&quot;close&quot; onclick=&quot;window.close()&quot;&gt;&lt;/body&gt; alert和confirmhtml12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function del()&#123;alert if(window.confirm(&quot;确认删除？&quot;))&#123; alert(&#x27;正在删除中&#x27;) &#125; &#125; &lt;/script&gt; &lt;input type=&quot;button&quot; value=&quot;delete&quot; onclick=&quot;del()&quot;&gt; &lt;/body&gt;&lt;/html 子级窗口设置为顶级窗口html12345678910111213141516171819&lt;body&gt; 这是顶级窗口&lt;br /&gt; &lt;iframe src=&quot;2.2子级窗口.html&quot; width=&quot;500px&quot; height=&quot;500px&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;body&gt; 这是子级窗口 &lt;script&gt; function setTop()&#123; if (window.top != window.self)&#123; window.top.location = window.self.location; &#125; &#125; &lt;/script&gt; &lt;input type=&quot;button&quot; value=&quot;如果当前窗口不是顶级窗口的话，将当前窗口设置为顶级窗口&quot; onclick=&quot;setTop()&quot; /&gt;&lt;/body&gt; 历史记录 第一页 html123456&lt;body&gt; &lt;a href=&quot;4.2-历史记录.html&quot;&gt;测试链接&lt;/a&gt; &lt;input type=&quot;button&quot; value=&quot;刷新&quot; onclick=&quot;window.location.reload()&quot;/&gt; &lt;input type=&quot;button&quot; value=&#x27;前进&#x27; onclick=&quot;window.history.go(1)&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;前进&quot; onclick=&quot;window.history.forward()&quot;/&gt; &lt;/body&gt; 第二页 html123456&lt;body&gt; &lt;input type=&quot;button&quot;value=&quot;刷新&quot; onclick=&quot;window.location.reload()&quot;/&gt; &lt;input type=&quot;button&quot;value=&quot;后退&quot; onclick=&quot;window.history.go(-1)&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;后退&quot; onclick=&quot;window.history.back()&quot;/&gt; &lt;input type=&quot;button&quot;value=&quot;后退刷新&quot; onclick=&quot;window.history.go(-1);window.location.reload()&quot;/&gt; &lt;/body&gt; 客户端发送请求的常见五种方式html123456789101112131415161718192021222324252627&lt;body&gt;&lt;Script&gt; function go()&#123; window.location = &quot;http://www.baidu.com&quot;; &#125; /* &lt;! -- 跳转页面可以通过多种方式:(这些都是发送请求!!! ! ) 第一种方式:直接在浏览器地址栏上写 URL(重点)(get请求) 第二种方式:可以点击超链接(重点)(get请求) 第三种方式:提交form表单(重点)(get或post请求) 第四种方式:window.open(url,target) (了解) 第五种方式:js代码（重点）: window .location.href window.location document.location.hre fdocument.location */&lt;/Script&gt;&lt;input type=&quot;button&quot; value=&quot;跳转&quot; onclick=&quot;go()&quot;&gt;&lt;/body&gt;","categories":[],"tags":[]},{"title":"多用户即时通信系统","slug":"多用户通信系统","date":"2022-09-03T11:16:26.000Z","updated":"2022-09-10T09:24:12.788Z","comments":true,"path":"2022/09/03/多用户通信系统/","link":"","permalink":"http://tanquerayds.site/2022/09/03/%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"为什么选择这个项目 有意思且涉及到各个方面的技术，还可以巩固基础学习新知识知识点包括： 项目框架设计 java面向对象编程 网络编程 多线程 IO流 Mysql&#x2F;（先用集合充当内存数据库） 多用户通信系统思路（第一版）和代码实现 通信结构分为客户端和服务端 服务端验证客户端账号信息和数据传输客户端作为用户可以通过服务器给其它用户发送消息和各类文件数据的传输主要采用对象流的方式，包括用户对象和消息数据包 一、 实现第一个功能，用户登录 客户端，根据用户界面提前创建用户对象和消息数据包，都作为对象数据流来传输。 1）用户这个类包括用户名&#x2F;id,用户密码 点击显/隐内容 java1234567891011121314151617181920212223242526public class User implements Serializable &#123; public static final long serialVersionUID = 1L; private String name;//用户名/id String passWord;//密码 public User(String name, String passWord) &#123; this.name = name; this.passWord = passWord; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassWord() &#123; return passWord; &#125; public void setPassWord(String passWord) &#123; this.passWord = passWord; &#125;&#125; 2）数据包这个类会包含数据类型，数据内容，发送者和接收者，最后还有发送时间 点击显/隐内容 JAVA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Message implements Serializable &#123; public static final long serialVersionUID = 1L; private String content;//发送内容 private String dataType;//数据类型 private String sender;//发送者 private String receiver;//接收者 private String data;//日期，感觉可以用第三代日期类，后面再改 public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public String getDataType() &#123; return dataType; &#125; public void setDataType(String dataType) &#123; this.dataType = dataType; &#125; public String getSender() &#123; return sender; &#125; public void setSender(String sender) &#123; this.sender = sender; &#125; public String getReceiver() &#123; return receiver; &#125; public void setReceiver(String receiver) &#123; this.receiver = receiver; &#125; public String getData() &#123; return data; &#125; public void setData(String data) &#123; this.data = data; &#125;&#125; 3）为了管理数据包的数据类型，再创建个接口来管理 JAVA123456package az.qqServer;public interface MessageType &#123; //在接口中定义常量，表示不同的消息类型 String MESSAGE_LOGIN_SUCCEED = &quot;1&quot;; String MESSAGE_LOGIN_FAIL = &quot;2&quot;;&#125; 4)用户登录界面制作，先把逻辑打通再细写代码 点击显/隐内容 进入二级菜单 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 客户端登入界面 **/public class qqView &#123; public static void main(String[] args) &#123; new qqView().mainView();//测试mainView方法 &#125; private static boolean loop = true;//菜单控制循环 private String key;//用户输入 public void mainView() &#123; while (loop) &#123; System.out.println(&quot;==========欢迎登录网络通信系统=========&quot;); System.out.println(&quot;\\t\\t1 登录系统&quot;); System.out.println(&quot;\\t\\t9 退出系统&quot;); System.out.println(&quot;请输入你的选择:&quot;); key = Utility.readString(1); //根据用户输入来执行操作 switch (key) &#123; case &quot;1&quot;: System.out.println(&quot;请输入你的用户名:&quot;); String userId = Utility.readString(50); System.out.println(&quot;请输入你的密码:&quot;); String passWord = Utility.readString(50); //这里需要到服务端验证是否合法，代码后续补，先通逻辑 if (true) &#123;//假如验证合法，则进入二级菜单 System.out.println(&quot;========欢迎用户&quot; + userId + &quot;===========&quot;); while (loop) &#123; System.out.println(&quot;==========网络通信系统二级菜单（&quot; + userId + &quot;）========&quot;); System.out.println(&quot;\\t\\t1 显示在线用户列表&quot;); System.out.println(&quot;\\t\\t2 群发消息&quot;); System.out.println(&quot;\\t\\t3 私发消息&quot;); System.out.println(&quot;\\t\\t4 发送文件&quot;); System.out.println(&quot;\\t\\t9 退出系统&quot;); System.out.println(&quot;请输入你的选择:&quot;); key = Utility.readString(1); switch (key) &#123; case &quot;1&quot;: System.out.println(&quot;显示在线用户列表&quot;); break; case &quot;2&quot;: System.out.println(&quot;群发消息&quot;); break; case &quot;3&quot;: System.out.println(&quot;私发消息&quot;); break; case &quot;4&quot;: System.out.println(&quot;发送文件&quot;); break; case &quot;9&quot;: System.out.println(&quot;退出系统&quot;); loop = false; break; &#125; &#125; &#125; else &#123; //验证不通过 System.out.println(&quot;========登录失败=======&quot;); break; &#125; break; case &quot;9&quot;: System.out.println(&quot;退出系统&quot;); loop = false; break; &#125; &#125; &#125;&#125; 5）根据用户输入的账密进行验证，客户端创建一个用户服务类，用来验证账密并建立连接 点击显/隐内容 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package azqq.service;import azqq.qqcommon.Message;import azqq.qqcommon.MessageType;import azqq.qqcommon.User;import java.io.*;import java.net.InetAddress;import java.net.Socket;/** * 这个类用来检验用户账密是否正确，并开启一个线程（持有socket）。 * 根据用户输入的账号密码设置user对象，发给服务端进行验证，服务端会返回一个Message对象 * 根据Message对象返回的信息判断是否登录成功，登录成功则创建一个线程持有socket和服务端保持通信 **/public class UserClientService &#123; //其它地方有可能用到socket和u，所以做成属性 private Socket socket; private User u = new User(); //根据用户输入的id和密码确认是否合法 public boolean checkUser(String userId , String passWord)&#123; System.out.println(&quot;开始发送对象进行检验&quot;); boolean b = false; //向服务器发送user对象，因此需要创建设置一个 u.setName(userId); u.setPassWord(passWord); //1.通过socket向服务器发送user对象 OutputStream outputStream = null; try &#123; socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9999);// outputStream = socket.getOutputStream();下面简写 ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(u);// InputStream inputStream = socket.getInputStream(); ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); //2.接收服务器返回的信息 Message message = (Message) ois.readObject(); //3.根据返回数据判断是否登录成功 if(message.getDataType().equals(MessageType.MESSAGE_LOGIN_SUCCEED))&#123; //如果登录成功，需要有一个线程持socket来不停的验证和传输数据，因此新建一个线程类ClientConnectServerThread ClientConnectServerThread ccst = new ClientConnectServerThread(socket);//将socket传过去 //启动线程 ccst.start(); //为了后面线程方便管理，将这里的线程加入集合 ManageClientConnectServiceThread.addClientConnectServerThread(userId,ccst); b = true; System.out.println(&quot;登录成功&quot;); &#125;else &#123; System.out.println(&quot;登录失败&quot;); socket.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return b; &#125;&#125; 6）新建的线程类 点击显/隐内容 java1234567891011121314151617181920212223242526272829303132333435363738394041package azqq.service;import azqq.qqcommon.Message;import java.io.IOException;import java.io.InputStream;import java.io.ObjectInputStream;import java.net.Socket;/** * 这个线程类持有socket用来保持和服务端的通信 **/public class ClientConnectServerThread extends Thread&#123; Socket socket ; //通过构造器来获得socket，金典 public ClientConnectServerThread(Socket socket) &#123; this.socket = socket; &#125; //此线程监视用户信息和数据库是否保持一致 @Override public void run() &#123; while (true)&#123; try &#123; System.out.println(&quot;接收消息&quot;); InputStream inputStream = socket.getInputStream(); ObjectInputStream ois = new ObjectInputStream(inputStream); Message message =(Message) ois.readObject(); //后续对message进行处理 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //其它类会需要socket public Socket getSocket() &#123; return socket; &#125;&#125; 7)用hashMap管理线程 java1234567891011121314151617181920package azqq.service;import java.util.HashMap;/** * 线程池 **/public class ManageClientConnectServiceThread &#123; //先用集合hashMap来管理，k为用户名，v为线程 private static HashMap&lt;String,ClientConnectServerThread&gt; hashMap = new HashMap&lt;&gt;(); //添加某一个线程进来 public static void addClientConnectServerThread(String userId,ClientConnectServerThread ccst )&#123; hashMap.put(userId,ccst); &#125; //根据id返回线程 public static ClientConnectServerThread getClientConnectServerThread(String userId) &#123; return hashMap.get(userId); &#125;&#125; 服务端，同理需要有用户对象和消息类，客户端负责验证客户端账户信息和接收数据 点击显/隐内容 注意服务端对于序列化的对象路径要和客户端保存一致，不然无法识别 1.服务端得要接收客户端发送过来的user对象，并根据数据库来检验账密是否正确，正确就开启线程和客户端进行通信 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package azqq.qqService;import azqq.qqcommon.Message;import azqq.qqcommon.MessageType;import azqq.qqcommon.User;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.net.ServerSocket;import java.net.Socket;/** 该服务类持续监听9999端口，如果有客服端进行连接则根据客户端发送的user对象来跟数据库比对，如果正确就建立连接 创建线程进行数据交互，中途如果又有其它客户端加入连接，则同理user没问题就又增加一个线程进行通信 **/public class QQServer &#123; private ServerSocket serverSocket = null; public QQServer() &#123; try &#123; serverSocket = new ServerSocket(9999); System.out.println(&quot;客户端等待连接...&quot;); //当和某个客户端连接后会持续监听，且持续监听是否有其它连接，因此用while while (true) &#123; Socket socket = serverSocket.accept();//如果没有客户端连接就会阻塞在这里 //得到和socket关联的输入输出流 System.out.println(&quot;连接成功&quot;); ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); User user = (User) ois.readObject(); Message message = new Message(); System.out.println(&quot;开始验证&quot;); //验证，如果账号密码正确，则可以登录，这里先死后活，用100，123465作为一个合法用户，后续改 if (user.getName().equals(&quot;100&quot;) &amp;&amp; user.getPassWord().equals(&quot;123456&quot;)) &#123;//根据user的账号密码是否登录成功，先通逻辑 //登录成功返回Massege信息 message.setDataType(MessageType.MESSAGE_LOGIN_SUCCEED);// ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());//考虑作用域放if外面去 //发送message对象 oos.writeObject(message); //同理确认可以登录后创建一个线程和客户端保持通信 ServerConnectClientThread serverConnectClientThread = new ServerConnectClientThread(socket, user.getName()); //启动通信的线程，并放入集合管理 serverConnectClientThread.start(); System.out.println(&quot;踩踩踩踩踩踩&quot;); &#125; else &#123;//登录失败返回Message信息 System.out.println(&quot;测试语句，&quot;+ user.getName() +&quot;登录失败&quot; + user.getPassWord()); message.setDataType(MessageType.MESSAGE_LOGIN_FAIL); oos.writeObject(message); //关闭socket socket.close(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123;//如果服务器退出了while则表示断开了连接，关闭serverSocket try &#123; serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2.线程持有socket 点击显/隐内容 java123456789101112131415161718192021222324252627282930313233343536373839package azqq.qqService;import azqq.qqcommon.Message;import java.io.IOException;import java.io.ObjectInputStream;import java.net.Socket;/** * 该线程类用来和客户端保持通信 **/public class ServerConnectClientThread extends Thread&#123; private Socket socket; private String userId;//用来确认是哪个用户连接的客户端 public ServerConnectClientThread(Socket socket, String userId) &#123; this.socket = socket; this.userId = userId; &#125; @Override public void run() &#123; while (true)&#123; try &#123; ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); //这里由于外层判断用户确认连接后调用此线程来接收用户发送的消息，所以转Message Message message = (Message) ois.readObject(); //后续对message进行处理 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.线程太多加入管理 点击显/隐内容 java12345678910111213141516171819package azqq.qqService;import java.util.HashMap;/** * 线程池 **/public class ManageClientConnectServiceThread &#123; //先用集合hashMap来管理，k为用户名，v为线程 private static HashMap&lt;String,ServerConnectClientThread&gt; hashMap = new HashMap&lt;&gt;(); //添加某一个线程进来 public static void addServerConnectClientThread(String userId,ServerConnectClientThread scct )&#123; hashMap.put(userId,scct); &#125; //根据id返回线程 public static ServerConnectClientThread getServerConnectClientThread(String userId) &#123; return hashMap.get(userId); &#125;&#125; 以上双方的通信基本打通，验证一下没问题 完善一下客户端用户数据，先用集合保存在服务里 java123456789 //考虑多线程用ConcurrentHashMap，线程同步static ConcurrentHashMap&lt;String,User&gt; validUsers = new ConcurrentHashMap&lt;&gt;();static &#123;//静态代码块，先代替数据库存放用户数据 validUsers.put(&quot;100&quot;,new User(&quot;100&quot;,&quot;123456&quot;)); validUsers.put(&quot;200&quot;,new User(&quot;200&quot;,&quot;123456&quot;)); validUsers.put(&quot;123&quot;,new User(&quot;123&quot;,&quot;123456&quot;)); validUsers.put(&quot;我是账户名&quot;,new User(&quot;我是账户名&quot;,&quot;我是对应密码&quot;)); validUsers.put(&quot;老亚萨西了&quot;,new User(&quot;老亚萨西了&quot;,&quot;123456&quot;));&#125; 二、实现拉取在线用户功能1.增加数据类型（两端都要） java123456789public interface MessageType &#123; //在接口中定义常量，表示不同的消息类型 String MESSAGE_LOGIN_SUCCEED = &quot;1&quot;;//表示登录成功 String MESSAGE_LOGIN_FAIL = &quot;2&quot;;//登录失败 String MESSAGE_COMM_MES =&quot;3&quot;;//普通信息包 String MESSAGE_GET_ONLINE_FRIEND =&quot;4&quot;;//要求返回在线用户列表 String MESSAGE_RET_ONLINE_FRIEND =&quot;5&quot;;//返回在线用户列表 String MESSAGE_CLIENT_EXIT =&quot;6&quot;;//客户端请求退出&#125; 客户端发送拉取在线用户请求并接收 点击显/隐内容 java123456789101112131415161718192021222324252627282930313233根据用户输入1拉取在线列表，创建一个方法在客户端的服务里//请求服务端获取在线好友列表 public void olineFriendList()&#123; //发送请求 Message message = new Message(); //设置数据类型 message.setDataType(MessageType.MESSAGE_GET_ONLINE_FRIEND); //设置发送者 message.setSender(u.getName()); try &#123; //获取相关用户线程对应的socket，可以通过线程集合来获取 Socket userSocket = ManageClientConnectServiceThread. getClientConnectServerThread(u.getName()).getSocket(); //根据socket得到输出流 ObjectOutputStream oos = new ObjectOutputStream(userSocket.getOutputStream()); //发送请求给服务端 oos.writeObject(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;这段代码在用户线程的run方法里，一直读取服务端数据 //判断message数据类型，进行相应处理 if (message.getDataType().equals(MessageType.MESSAGE_RET_ONLINE_FRIEND)) &#123; //默认好友在线列表以字符串形式且以“”隔开 String[] onlineUsers = message.getContent().split(&quot; &quot;); System.out.println(&quot;\\n=========当前在线用户列表============&quot;); for (int i = 0; i &lt; onlineUsers.length; i++) &#123; System.out.println(&quot;用户:&quot; + onlineUsers[i]); &#125; &#125; 客户端接收请求并返回在线用户列表数据 点击显/隐内容 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950服务端接收并返回数据@Override public void run() &#123; while (true) &#123; try &#123; System.out.println(&quot;服务端和客户端&quot; + userId +&quot;保持通信，读取数据&quot;); ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); //这里由于外层判断用户确认连接后调用此线程来接收用户发送的消息，所以转Message Message message = (Message) ois.readObject(); //根据接收的数据类型进行相应业务处理 //如果数据类型为获取在线好友列表请求 if (message.getDataType().equals(MessageType.MESSAGE_GET_ONLINE_FRIEND)) &#123; /* 好友列表格式为 100 200 老亚萨西了 考虑到线程池有所有在运行的用户，所以在那里编写方法获取userId */ System.out.println(message.getSender() + &quot;要在线用户列表&quot;); //获取要发送的在线用户列表 String onlineUserList = ManageClientConnectServiceThread.getUserId(); Message message2 = new Message(); message2.setDataType(MessageType.MESSAGE_RET_ONLINE_FRIEND); message2.setContent(onlineUserList); //message发送者getSender是谁，接收者就设置成谁 message2.setReceiver(message.getSender()); ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(message2); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 服务端接收数据后的还未返回时对数据的处理过程 //返回在线用户id public static String getUserId()&#123; String onlineUserList = &quot;&quot;; //从hashmap中取，遍历 //1.取迭代器 Iterator&lt;String&gt; iterator = hashMap.keySet().iterator(); while (iterator.hasNext())&#123; onlineUserList += iterator.next() + &quot; &quot;; &#125; System.out.println(onlineUserList); return onlineUserList; &#125; 功能实现截图 无异常退出 点击显/隐内容 java123456789101112131415161718192021222324252627用户选择9退出时调用此方法 //编写方法给服务端发送message通知关闭线程 public void closeThread()&#123; Message message = new Message(); message.setSender(u.getName()); //消息数据类型为客户端申请退出 message.setDataType(MessageType.MESSAGE_CLIENT_EXIT); try &#123; OutputStream outputStream = socket.getOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(outputStream); oos.writeObject(message);//发送数据给服务端 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; 服务端对应线程处 //如果数据类型为请求关闭类型 if(message.getDataType().equals(MessageType.MESSAGE_CLIENT_EXIT))&#123; //从线程池里移除数据包里面对应的发送者 ManageClientConnectServiceThread.removeServerConnectClientThread(message.getSender()); socket.close();//关闭连接 System.out.println(message.getSender() + &quot;下线了&quot;); loop = false; &#125; 私聊功能 打包——转发——拆包 点击显/隐内容 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455打包/** * 用于客户端私聊/群聊 **/public class MessageClientService &#123; //私发消息的功能 /** * * @param sendId 发送者 * @param receiver 接收者 * @param content 发送内容 */ public void privateChat(String sendId, String receiver, String content)&#123; //设置数据基本属性，发送者接收者，数据类型，发送内容 Message message = new Message(); message.setSender(sendId); message.setDataType(MessageType.MESSAGE_COMM_MES); message.setContent(content); message.setReceiver(receiver); //日期设置 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd E hh:mm:ss a&quot;); String strDate = sdf.format(new Date()); message.setData(strDate); //给客户端自己提示一句话 System.out.println(&quot;\\n&quot; + sendId + &quot;对&quot; + receiver + &quot;说:&quot; + content); //将数据发送到服务端 try &#123; ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServiceThread.getClientConnectServerThread(sendId).getSocket().getOutputStream()); oos.writeObject(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;转发if(message.getDataType().equals(MessageType.MESSAGE_COMM_MES))&#123; //从数据包里面提取发送者想要私聊的对象 String receiver = message.getReceiver(); //根据接收者的userId来获取对应的线程socket Socket socket = ManageClientConnectServiceThread.getServerConnectClientThread(receiver).socket; ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(message); //后面考虑加入离线的情况 &#125;拆包//如果数据类型为普通信息包 if(message.getDataType().equals(MessageType.MESSAGE_COMM_MES))&#123; String sender = message.getSender(); String content = message.getContent(); System.out.println(&quot;\\n&quot; + sender+ &quot;对&quot; + message.getReceiver() + &quot;说：&quot; + content + &quot;\\t&quot; + message.getData()); &#125; 群聊功能 点击显/隐内容 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465用户选择 case &quot;2&quot;: System.out.println(&quot;请输入群发消息内容&quot;); String groupContent = Utility.readString(50); mcs.groupChat(userId, groupContent); break;客户端发送数据包/** * @param sendId 发送者 * @param content 发送内容 */ public void groupChat(String sendId, String content)&#123; //设置数据基本属性，发送者接收者，数据类型，发送内容 Message message = new Message(); message.setSender(sendId); message.setDataType(MessageType.MESSAGE_GROUP_MES); message.setContent(content); //日期设置 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd E hh:mm:ss a&quot;); String strDate = sdf.format(new Date()); message.setData(strDate); //给客户端自己提示一句话 System.out.println(&quot;\\n&quot; + sendId + &quot;对所有人说:&quot; + content); //将数据发送到服务端 try &#123; ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServiceThread.getClientConnectServerThread(sendId).getSocket().getOutputStream()); oos.writeObject(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 服务端处理//如果数据类型为群聊 else if(message.getDataType().equals(MessageType.MESSAGE_GROUP_MES))&#123; ManageClientConnectServiceThread.groupChat(userId,message); System.out.println(userId + &quot;给所有人发了消息&quot;); &#125; //群聊消息 public static void groupChat(String userId , Message message)&#123; Iterator&lt;ServerConnectClientThread&gt; iterator = hashMap.values().iterator(); while (iterator.hasNext())&#123; ServerConnectClientThread next = iterator.next(); if( next != hashMap.get(userId))&#123; Socket socket = next.getSocket(); try &#123; ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;客户端再接收//如果数据类型为群聊包 if(message.getDataType().equals(MessageType.MESSAGE_GROUP_MES))&#123; String content = message.getContent(); String sender = message.getSender(); System.out.println(&quot;\\n&quot; + sender+ &quot;对所有人说：&quot; + content + &quot;\\t&quot; + content); &#125; 发文件功能 点击显/隐内容 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677客户端发送文件case &quot;4&quot;:System.out.println(&quot;请输入发送文件给哪个用户:&quot;);String fileReceiver = Utility.readString(50);System.out.println(&quot;请输入发送文件的路径:&quot;);String sourcePath = Utility.readString(50);System.out.println(&quot;请输入发送文件至对方的的路径:&quot;);String targetPath = Utility.readString(50);fileClientService.sendFile(userId,sourcePath,fileReceiver,targetPath);break;public class FileClientService &#123;//给其它客户端传送文件/*** @param sender 发送者* @param sourcePath 发送路径* @param receiver 接收者* @param targetPath 接收路径*/public void sendFile(String sender,String sourcePath,String receiver,String targetPath)&#123;//数据包初始化发送者接收者，发送路径，接收路径，数据包类型Message message = new Message();message.setSender(sender);message.setReceiver(receiver);message.setSourcePath(sourcePath);message.setTargetPath(targetPath);message.setDataType(MessageType.MESSAGE_FILE_MES);//根据指定路径，将输入流转成字节数组，打包进messageInputStream inputStream = null;try &#123;inputStream = new FileInputStream(sourcePath);byte[] bytes = StreamUtils.streamToByteArray(inputStream);message.setBytes(bytes);//根据发送者id--&gt;线程池--&gt;socket--&gt;getOutputStream()OutputStream outputStream = ManageClientConnectServiceThread.getClientConnectServerThread(sender).getSocket().getOutputStream();ObjectOutputStream oos = new ObjectOutputStream(outputStream);//发送数据包oos.writeObject(message);System.out.println(&quot;\\n&quot; + sender + &quot;把来自&quot; + targetPath + &quot;的文件发送给了&quot;+ receiver);&#125; catch (Exception ex) &#123;ex.printStackTrace();&#125;&#125;&#125;服务端转发//判断数据类型为文件else if(message.getDataType().equals(MessageType.MESSAGE_FILE_MES))&#123;//获取接收者String receiver = message.getReceiver();//根据接收者获取对应线程ServerConnectClientThread scct = ManageClientConnectServiceThread.getServerConnectClientThread(receiver);//根据线程获取socketSocket socket = scct.getSocket();//把读取到的数据发送到对应线程OutputStream outputStream = socket.getOutputStream();ObjectOutputStream oos = new ObjectOutputStream(outputStream);oos.writeObject(message);//提示信息System.out.println(&quot;\\n&quot; +message.getSender() + &quot;发送文件给&quot; + receiver);&#125;客户端接收 //如果数据类型为文件if(message.getDataType().equals(MessageType.MESSAGE_FILE_MES))&#123;//拆包获取数据String sender = message.getSender();String receiver = message.getReceiver();String targetPath = message.getTargetPath();byte[] bytes = message.getBytes();FileOutputStream fileOutputStream = new FileOutputStream(targetPath);fileOutputStream.write(bytes);if(fileOutputStream != null)&#123; fileOutputStream.close();&#125;System.out.println(&quot;\\n&quot; +receiver + &quot;接收了&quot; + sender + &quot;发送的文件并存入了&quot; + targetPath);&#125; 推送消息功能 点击显/隐内容 java123456789101112131415161718192021222324252627282930313233343536** * 一个独立线程负责推送消息 **/public class SendNewsToAllService extends Thread &#123; @Override public void run() &#123; //可反复推送消息 while (true) &#123; System.out.println(&quot;请输入你想推送的消息(输入exit表示退出推送服务线程):&quot;); String news = Utility.readString(100); if(news.equals(&quot;exit&quot;))&#123; break; &#125; //设置要发送的数据包 Message message = new Message(); message.setSender(&quot;服务器&quot;); message.setDataType(MessageType.MESSAGE_GROUP_MES); message.setContent(news); //发送给所有线程 HashMap&lt;String, ServerConnectClientThread&gt; hashMap = ManageClientConnectServiceThread.getHashMap(); Iterator&lt;ServerConnectClientThread&gt; iterator = hashMap.values().iterator(); while (iterator.hasNext()) &#123; ServerConnectClientThread next = iterator.next(); Socket socket = next.getSocket(); try &#123; ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(message);//发送数据包 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 扩展部分：离线消息和离线文件离线消息 java12345678910111213141516171819202122232425262728293031323334/** * 监视线程，保证离线用户上线后第一时间收到消息 **/public class OfflineUserPackage extends Thread&#123; Message message; public Message getMessage() &#123; return message; &#125; public void setMessage(Message message) &#123; this.message = message; &#125; @Override public void run() &#123; boolean loop = true; while (loop)&#123; //从数据包里获取接收者 String receiver = message.getReceiver(); //获取线程集合hashMap HashMap&lt;String, ServerConnectClientThread&gt; hashMap = ManageClientConnectServiceThread.getHashMap(); if(hashMap.get(receiver) != null) &#123; ServerConnectClientThread serverConnectClientThread = hashMap.get(receiver); Socket socket = serverConnectClientThread.getSocket(); try &#123; ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(message); loop = false; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 离线文件 java123456789101112131415161718给离线文件和消息都加了个筛选if(hashMap.get(receiver) != null &amp;&amp; message.getDataType().equals(MessageType.MESSAGE_FILE_MES)) &#123; //根据接收者获取对应线程 ServerConnectClientThread serverConnectClientThread = hashMap.get(receiver); //根据线程获取socket Socket socket = serverConnectClientThread.getSocket(); //把读取到的数据发送到对应线程 try &#123; OutputStream outputStream = socket.getOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(outputStream); oos.writeObject(message); loop = false; //提示信息 System.out.println(&quot;\\n&quot; + message.getSender() + &quot;发送文件给&quot; + receiver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}